{
  "team_id": "aline123",
  "items": [
    {
      "title": "PDF Chunk 1",
      "content": "BEYOND CRACKING the CODING INTERVIEW Pass Tough CODING Interviews, get noticed, and Negotiate succesfully SNEAK PEEK amazon.com/dp/195570600X 0 INTERVIEW CHECKLIST BEYOND CRACKING THE CODING INTERVIEW 1 STUDY PLAN BEYOND CRACKING THE CODING INTERVIEW BOOSTERS CRACKING THE CODING INTERVIEW 189 PROGRAMMING QUESTIONS AND SOLUTIONS CRACKING THE PM CAREER THE SKILLS, FRAMEWORKS, AND PRACTICES TO BECOME A GREAT PRODUCT MANAGER CRACKING THE PM INTERVIEW HOW TO LAND A PRODUCT MANAGER JOB IN TECHNOLOGY CRACKING THE TECH CAREER INSIDER ADVICE ON LANDING A JOB AT GOOGLE, MICROSOFT, APPLE, OR ANY TOP TECH COMPANY BEYOND CRACKING the CODING INTERVIEW GAYLE L. MCDOWELL MIKE MROCZKA ALINE LERNER NIL MAMANO CareerCup, LLC Palo Alto, CA BEYOND CRACKING THE CODING INTERVIEW Copyright © 2025 by CareerCup. All rights reserved. No part of this book may be reproduced in any form by any electronic or me- chanical means, including information storage and retrieval systems, without permission in writing from the author or publisher, except by a reviewer who may quote brief passages in a review. Published by CareerCup, LLC, Palo Alto, CA. Compiled Jun 3, 2025. For more information, or to enquire about bulk or university copies, contact support@careercup.com. Please report bugs or issues at beyondctci.com. 978-1955706001 (ISBN 13) To my favorite coders, Davis and Tobin— Gayle To my dog, my wife, and our readers (and not necessarily in that order)— Mike To my two wonderful kids (or if I have more, then whichever two are the most wonderful)— Aline Als meus pares— Nil WHAT’S INSIDE I. __init__() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 README . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 Hello World. Hello Reader. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 Crash & Learn: Our Failed Interviews . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 II. Ugly Truths & Hidden Realities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 Ch 0. Why Job Searches Suck. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 Ch 1. A Brief History of Technical Interviews . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 Ch 2. What’s Broken About Coding Interviews. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 Ch 3. What Recruiters Won’t Tell You . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 Ch 4. What Interviewers Won’t Tell You. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 Ch 5. Mindset and the Numbers Game. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 III. Job Searches, Start to Finish . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 Ch 6. Resumes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 Ch 7. Getting in the Door . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 Ch 8. Mechanics of the Interview Process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 Ch 9. Managing Your Job Search. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78 IV. Offers & Negotiation. . . . . . . .",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 2",
      "content": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96 Ch 10. Components of the Offer. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98 Ch 11. The What & Why of Negotiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .108 Ch 12. Pre-Offer Negotiation Mistakes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .111 Ch 13. Getting the Offer: Exactly What to Say . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .120 Ch 14. How to Negotiate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .123 V. Behavioral Interviews . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136 Ch 15. When and How They Matter. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .138 Ch 16. Content: What to Say . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .141 Ch 17. Communication: How to Say It . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .154 VI. Principles of Coding Interviews. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166 Technical README. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .168 Ch 18. How to Practice. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .170 Ch 19. How You Are Evaluated. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .180 Ch 20. Anatomy of a Coding Interview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .190 Ch 21. Big O Analysis. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .206 Ch 22. Boundary Thinking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .231 Ch 23. Trigger Thinking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .243 Ch 24. Problem-Solving Boosters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .249 VII. Catalog of Technical Topics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280 Ch 25. Dynamic Arrays. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .282 Ch 26. String Manipulation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .288 Ch 27. Two",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 3",
      "content": "Pointers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .294 Ch 28. Grids & Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .312 Ch 29. Binary Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .326 Ch 30. Sets & Maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .345 Ch 31. Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .361 Ch 32. Stacks & Queues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .379 Ch 33. Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .392 Ch 34. Linked Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .412 Ch 35. Trees. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .429 Ch 36. Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .456 Ch 37. Heaps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .489 Ch 38. Sliding Windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .509 Ch 39. Backtracking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .537 Ch 40. Dynamic Programming. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .564 Ch 41. Greedy Algorithms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .584 Ch 42. Topological Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .598 Ch 43. Prefix Sums . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .610 VIII. exit() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 624 Acknowledgments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .626 Post-Mortem Example Log . . . . . . . . . . . .",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 4",
      "content": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .629 Reference Materials . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .630 My Notes & Reminders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .639 You can access all of our online materials and bonus chapters here: Talk with the authors, get help if you're stuck, and geek out with us on Discord. bctci.cobctci.co/discord Get $50 Off on Mock Interviews Practice anonymously on interviewing.io with FAANG interviewers: bctci.co/discount-X3A4 I TECHNICAL README This chart represents how we see the landscape of interview questions: Figure 1. Landscape of Interview Questions, for someone who prepares with BCtCI. Our goal with this book is twofold: 1. Teach you the 80% most common topics and ideas used in interview problems. That's what Part VII: The Catalog of Technical Topics, is all about. The remaining 20% are niche topics. PRINCIPLES AND CATALOG ▸ TECHNICAL README 169 2. Teach you problem-solving strategies so you can ! gure out 80% of questions on your own, even if you haven't seen the idea before. This is what the problem-solving boosters (Chapter 24: Problem-Solving Boosters, pg 249) are for. The remaining 20% of questions rely on tricks (ideas that are really hard to come up with on your own if you haven't seen them before). 1 Combining these two, after going through the book, you should be able to tackle all but 20% * 20% = 4% of questions, which are those based on niche topics and requiring tricks. But if that happens, you've been truly unlucky. THE PRINCIPLES AND THE CATALOG Besides solving problems, we want to help you practice e\" ectively and know how to navigate an interview setting. This is covered in Part VI: Principles of Coding Interviews (pg 166). It includes: •Study Plan: A detailed study plan for how to practice using this book's materials. •Universal Rubric: How you're evaluated by interviewers. •Interview Checklist: Breaking down each step you should take in a coding interview. •Big-O Analysis: In-depth coverage of the \"language\" of technical interviews. •Problem-Solving Strategies: Boundary thinking, trigger thinking, and problem-solving boosters. The second part is a Catalog of data structures and algorithms topics. We've broken the technical topics into tiers, with Tier 1 being the highest priority. •Tier 1: Essential topics from sets & maps to trees and graphs. •Tier 2: Intermediate topics like heaps, sliding windows, and pre! x sums. • Tier 3: Niche (online-only) topics that didn't warrant a spot in the physical book because they don’t come up that often (this is where we enter the niche 20% territory). The online-only chapters can be found at bctci.co/bonus. Chapter 18: How to Practice (pg 170) should be your entry point to the rest of the book. TOPICS, RECIPES, AND REUSABLE IDEAS There are three related concepts you'll ! nd as you peruse the Catalog: topics, reusable ideas, and recipes. Here's a quick de! nition to keep them straight: •Topic: A chapter from the Catalog, like Binary Search. • Reusable Idea: A coding idea that can typically be used across problems (and even across topics). They are tactical tips worth remembering, such as \"pass indices, not strings in recursive code to avoid using extra space.\" You'll typically ! nd them next to the ! rst problem where they are used (look for the icon). •Coding Recipe: A pseudo-code template related to a speci! c topic that can be used as a building block to solve similar problems with small tweaks. Questions, comments, or bugs? Report bugs at bctci.co/bugs or geek out with the authors on Discord: bctci. co/discord. 1 Our mantra? If you encounter something once, it’s a trick; if you encounter it repeatedly, it’s a tool. CHAPTER 29 A I interviewer, replays, and more materials for this chapter at bctci.co/binary-search I CHAPTER 29 I CHAPTER 29 II BINARY SEARCH ▶Prerequisites: None When it comes to binary search, software engineers are split in half: One camp thinks it's too basic to be an interview question, and the other dreads it because they always mess up the index manipulation. The ! rst group overlooks the fact that binary search has many uses beyond the basic \"! nd a value in a sorted array.\" Far from it, binary search has many non-obvious applications, which we'll cover in this chapter. For the second group, we'll provide a recipe focusing on simplicity and reusability across applications—even the unconventional ones we just foreshadowed. BINARY SEARCH IS EASY TO MESS UP Let's start with something simple—the classic binary search setting—and then build up to harder problems. PROBLEM 29.1 S E A R C H I N S O R T E D A R R A Y Given a sorted array of integers, arr, and a target value, target, return the target's index if it exists in the array or -1 if it doesn't. ▶Example: arr = [-2, 0, 3, 4, 7, 9, 11], target = 3 Output: 2. ▶Example: arr = [-2, 0, 3, 4, 7, 9, 11], target = 2 Output: -1. SOLUTION 29.1 S E A R C H I N S O R T E D A R R A Y We assume most engineers are familiar with the basic premise of binary search: two pointers move inward from the ends of a sorted array, closing in on the target by checking if the midpoint is too small or too large. Pop",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 5",
      "content": "quiz! Here is an attempted solution, but it has a bug. Can you spot it? 1 def BUGGED_binary_search(arr, target): # DON'T USE IN INTERVIEWS! 2 l, r = 0, len(arr) 3 while l <= r: 4 mid = (l + r) // 2 5 if mid == target: 6 return mid 7 if target > mid: 8 r = mid+1 9 else: 10 l = mid-1 11 return -1 CHAPTER 29 ▸ BINARY SEARCH 327 Check the solution in the footnote. 1 Regardless of what you found, the point is that it is easy to miss errors in a binary search implementation. Here is one way to do it correctly: 1 def binary_search(arr, target): 2 n = len(arr) 3 if n == 0: 4 return -1 5 l, r = 0, n - 1 6 if arr[l] >= target or arr[r] < target: 7 if arr[l] == target: 8 return 0 9 return -1 10 while r - l > 1: 11 mid = (l + r) // 2 12 if arr[mid] < target: 13 l = mid 14 else: 15 r = mid 16 if arr[r] == target: 17 return r 18 return -1 Figure 1. Binary search for target 3. We'll punt on breaking down this solution until we talk about our transition-point recipe (pg 330). BINARY SEARCH HAS SURPRISING APPLICATIONS Imagine that your bike had gotten stolen, and your only chance of getting it back hinged on your ability to explain binary search to a police o# cer. That is the very situation Tom Whipple, a science journalist, found himself in. 2 The rack from which the bike went missing was right under a security camera, but the police told him they didn't have the resources to watch many hours of footage just to identify when the bike was stolen. Tom explained that this wouldn't be necessary: they could skip ahead to the middle of the video and check if the bike was still there. If it was, the bike was stolen during the latter half; if not, it was stolen earlier. This could be repeated to quickly narrow down the time of the crime. In the end, the thief was never caught—the footage was too grainy. Regardless, the story showcases an unconventional use of binary search. We can formalize it into an interview question: PROBLEM 29.2 C C T V F O O T A G E You are given an API called is_stolen(t) which takes a timestamp as input and returns True if the bike is missing at that timestamp and False if it is still there. You're also given two timestamps, t1 and t2, representing when you parked the bike and when you found it missing. Return the timestamp when the bike was ! rst missing, minimizing the number of API calls. Assume that 0 < t1 < t2, is_stolen(t1) is False, and is_stolen(t2) is True. 1 We were not completely honest—there isn't just one bug; there are closer to six, depending on how you count them. (1) r is initialized out of bounds, (2 & 3) we check mid instead of arr[mid] (twice!), (4) we update r when we should be updating l, (5) l should be set to mid+1, not mid-1, and (6) r should be set to mid-1, not mid+1. 2 https://www.thetimes.com/article/i-have-owned-11-bikes-this-is-how-they-were-stolen-d3r553gx3 328 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co Figure 2. SOLUTION 29.2 CCTV FOOTAGE This problem is quite di\" erent from Problem 29.1: Search In Sorted Array (pg 326): it doesn't have an array input, and we don't have a target value. In fact, if we tried to use the same binary search code from earlier, we'd have to change almost every line in the algorithm before it would work correctly. That many tweaks make it easy to reintroduce bugs. Nonetheless, we can still use binary search because the range of possible answers can be broken down into two regions: (1) before the bike was stolen and (2) after it was stolen. We are searching for the transition point from 'before' to 'after’: Figure 3. Initially, we don't know where the transition point is, but we can binary search for it: Figure 4. 1 def is_before(val): 2 return not is_stolen(val) 3 4 def fi nd_bike(t1, t2): 5 l, r = t1, t2 6 while r - l > 1: 7 mid = (l + r) // 2 8 if is_before(mid): 9 l = mid 10 else: CHAPTER 29 ▸ BINARY SEARCH 329 11 r = mid 12 return r At the beginning, l is in the 'before' region, and r is in the 'after' region. From there, l never leaves the 'before' region and r never leaves the 'after' region, but they end up next to each other: at the end, l is the last 'before' and r is the ! rst 'after.' Here is the kicker: every binary search solution can be reframed as ! nding a transition point. For instance, Problem 29.1: Search In Sorted Array can be reframed as ! nding the \"transition point\" from elements smaller than target to elements greater than or equal to target. If we learn a recipe for ! nding transition points, we'll be able to use it for every binary search problem. We don't need specialized recipes for various problem types. T R A N S I T I O N $P O I N T R E C I P E In an important interview—with tensions mounting and anxiety running high—you are not working at total capacity. We joke that you are ~20% dumber than during practice. To counter this, it helps to have a recipe you know well for tricky algorithms like binary search. A good recipe should be easy to remember, have straightforward edge cases, and make it easy to avoid o\" -by-one errors. RECIPE 1. TRANSITION\"POINT RECIPE transition_point_recipe() defi ne is_before(val) to return whether val is 'before' initialize l and r to",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 6",
      "content": "the fi rst and last values in the range handle edge cases: - the range is empty - l is 'after' (the whole range is 'after') - r is 'before' (the whole range is 'before') while l and r are not next to each other (r - l > 1) mid = (l + r) / 2 if is_before(mid) l = mid else r = mid return l (the last 'before'), r (the fi rst 'after'), or something else, depending on the problem The point of the initialization and the initial edge cases is to get to a setting that looks like the ! rst row of Figure 4: lmust be in the 'before' region, and rmust be in the 'after' region. The three edge cases are designed to ensure this. Once we get to that point, the main while loop is the same for every problem—no tweaking needed! The loop has the following invariants, which are guarantees that make our lives easier: • From start to end, l is in the 'before' region, and r is in the 'after' region. They are never equal and never cross over. 3 •The midpoint is always strictly between l and r (l < mid < r), which guarantees we always make progress (we don't need to worry about in! nite loops). •When we exit the loop, l and r are always next to each other. 3 If we were a little more willing to buck conventions, we'd rename from l and r to b and a, since they always map to 'before' and 'after' values. However, you might get odd looks from an interviewer if you do this! 330 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co Something that is typically tricky with binary search is the exit condition of the loop. Here, we keep going until l and r are next to each other (i.e., until the 'unknown' region in Figure 4 is empty), which happens when r - l is 1. That's why the condition says r - l > 1. 4 Another tricky part is knowing what to return. With this recipe, we just need to reason about the transition point: do we need the ! nal 'before' or the ! rst 'after'? We recommend starting by de! ning the is_before() function. Keep in mind that, for binary search to work, we must de! ne it in such a way that the search range is monotonic: all the 'before' elements must appear before all the 'after' elements. That's why binary search doesn't work on unsorted arrays. Revisiting Solution 29.1 Here is how we applied the recipe in Solution 29.1: we de! ned the 'before' region as the elements <target, and the 'after' region as the elements ≥target. In the initialization, we have the three edge cases from the recipe to ensure that l is 'before' and r is 'after': 1 if n == 0: 2 return -1 3 l, r = 0, n - 1 4 if arr[l] >= target or arr[r] < target: 5 if arr[l] == target: 6 return 0 7 return -1 The while loop is just like the recipe, except that we didn't factor out is_before() into a helper function: 1 while r - l > 1: 2 mid = (l + r) // 2 3 if arr[mid] < target: 4 l = mid 5 else: 6 r = mid Finally, when we ! nd the transition point, we consider what that means: l is at the largest value smaller than the target, and r is at the smallest value greater than or equal to the target. So, if the target is in the array at all, it must be at index r. 1 if arr[r] == target: 2 return r 3 return -1 What to do at the end depends on how we de! ne the 'before' region. We could have also de! ned 'before' as \"less than or equal to the target,\" in which case, at the end, we would have to check the element at l instead of r. This recipe is a bit like a one-size-! ts-all pair of socks. While more concise (but less reusable) implementations may exist for some problems, there is value in needing only one easy-to-remember recipe. TRANSITION-POINT PROBLEM SET For each of the following problems: •Reframe it as ! nding a transition point by de! ning 'before' and 'after' regions. •Find the location of l and r after ! nding the transition point for the given example input. 4 We could have also written this in other ways, like r > l + 1. One way to remember the formula for the number of elements between l and r, r-l-1, is that it looks like a sleepy cat. CHAPTER 29 ▸ BINARY SEARCH 331 •Identify what to return after ! nding the transition point. You don't need to code anything yet—focus on the transition logic. QUESTION 1 GIT COMMITS Find the ! rst commit that fails a test in a sequence of Git commits. We know the test was passing for every commit until it started failing at some point. [\"pass\", \"pass\", \"pass\", \"pass\", \"fail\", \"fail\", \"fail\"] QUESTION 2 SQUARED TARGET Given a sorted array of positive integers and a target value, ! nd the largest number in the array that can be squared and still be less than or equal to the target, if any. Return the number (not its index). [2, 3, 4, 5, 6, 7, 8, 11, 20, 21, 23, 25, 25], target = 36 QUESTION 3 FIRST NON\"NEGATIVE Return the index of the ! rst non-negative integer in a sorted array (duplicates allowed), if any. [-21, -15, -9, -5, -5, -1, -1, 0, 0, 4, 7, 12, 21] QUESTION 4 FIRST 'P' Find the ! rst word that begins with 'p' in an array of words in dictionary order, if any. [\"apple\", \"banana\", \"peach\", \"strawberry\"] QUESTION 5 N E",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 7",
      "content": "A R E S T E L E M E N T In a sorted array of integers (duplicates allowed), ! nd the last occurrence of a given target value. If the target does not exist, return the index of the next closest value (it could be smaller or larger than the target). [1, 3, 5, 6, 7, 7, 8, 11, 13, 21], target = 7 QUESTION 6 DECK CUT Yo u ' r e g i v e n a n a r r a y t h a t c o n t a i n s e a c h n u m b e r f r o m 1 to 52 once, representing a deck of playing cards. The deck started in order, but it was then \"cut,\" meaning that a random number of cards was taken from the top (the front of the array) and moved as a block to the bottom (the back of the array). Determine the index where you must \"cut\" the deck again to return to sorted order (that is, the index with the 52). [36, 37, 38, ..., 50, 51, 52, 1, 2, 3, ..., 33, 34, 35] PROBLEM SET SOLUTIONS In the solutions below, we circled which of the two pointers we should return at the end. ANSWER 1 GIT COMMITS 332 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co ANSWER 2 SQUARED TARGET We should return arr[l], since the last number in the 'before' region is the largest number that still works. ANSWER 3 FIRST NON\"NEGATIVE Including 0 in the 'before' region would be a mistake: if there are multiple zeros, l would point to the last one, but the goal is to return the ! rst one. ANSWER 4 FIRST 'P' The ‘before’ region consists of words that start with a–o and the ‘after’ region consists of words that start with p–z. If there are words that start with ‘p’, the ! rst one will be at index r. Including words that start with 'p' in the 'before' region would be incorrect: if we inserted another word starting with 'p,' like \"pear,\" l would point to the last word starting with 'p' rather than the ! rst one. ANSWER 5 NEAREST ELEMENT Post-processing requires a bit of thought. If the target is in the array, it will be at l. We can peek at arr[l] and return l if it is the target. Otherwise, we need to ! nd the closest value to it, which could be at l or r. We return either l or r, based on whether arr[l] or arr[r] is closer. ANSWER 6 DECK CUT Trick question! This doesn' t require binar y search as the answer is always 52 - deck[0]. Still, we could ! nd the transition point from 52 back to 1 with a binary search. The 'before' region would be numbers ≥deck[0]. The l pointer would end up at the 52 and the r pointer at the 1. We would return l. VALIDATION & DRAWING ADVICE Visualizing the binary search in an interview is helpful both for you and your interviewer. Instead of trying to verbally explain what you're doing, show them in the shared editor. Our suggestions are similar to the Two Pointers chapter (pg 296): CHAPTER 29 ▸ BINARY SEARCH 333 •Write each pointer (l, r, and m for the midpoint) on its own line so you can move them independently with ease. •Writing indices on the top of the array makes it faster to do midpoint calculations. •You can also draw the transition point between 'before' and 'after.' Instead ofTr y [1, 2, 2, 3, 3, 4, 5, 8, 8] ^ ^ ^ left mid right 0 1 2 3 4 5 6 7 8 [1 2 2 3 3 4|5 8 8] l r m m = (0+8)/2 So, which inputs should you validate and visualize? Consider the following edge cases, when applicable: •The range is empty. •The range only has 'before' elements. •The range only has 'after' elements. •The target is not in the array. •The target is in the array multiple times. ANALYSIS But o# cer, it is O(log n)! In the Big O analysis chapter , we de! ned log 2 (n) as roughly the number of times we need to halve a number to reach 1. Binary search halves the search range at each step, so binary search converges in O(log n) iterations, where n is the size of the range (e.g., t2 - t1 in Problem 29.2: CCTV Footage (pg 327). 5 Some binary search implementations stop early when arr[mid] == target. For simplicity, our recipe doesn't have that, which means that it takes O(log n) time even in the best case. That's ! ne—we mainly care about the worst case. Don't forget to factor in the time it takes to compute is_before() in the runtime calculation if it is not constant! Finally, the extra space is O(1). Binary search can also be implemented recursively, in which case the extra space increases to O(log n) for the call stack. BINARY SEARCH PROBLEM SET Try these problems with AI Interviewer: bctci.co/binary-search-problem-set-1 Let's tackle some problems that require creative approaches for using binary search. The transition-point recipe should prove useful! PROBLEM 29.3 V A L L E Y B O T T O M A valley-shaped array is an array of integers such that: •it can be split into a non-empty pre! x and a non-empty su# x, •the pre! x is sorted in decreasing order, 5 See page 219 for why we \"drop\" the base of the logarithm in big O notation. 334 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co •the su# x is sorted in increasing order, •all the elements are unique. Given a valley-shaped array, arr, return the smallest value. ▶Example:",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 8",
      "content": "arr = [6, 5, 4, 7, 9] Output: 4 ▶Example: arr = [5, 6, 7] Output: 5. The prefix sorted in decreasing order is just [5]. ▶Example: arr = [7, 6, 5] Output: 5. The suffix sorted in increasing order is just [5]. PROBLEM 29.4 2\"ARRAY 2\"SUM Yo u a r e g i v e n t w o n o n - e m p t y a r r a y s o f i n t e g e r s , sorted_arr and unsorted_arr. The ! rst one is sorted, but the second is not. The goal is to ! nd one element from each array with sum 0. If you can ! nd them, return an array with their indices, starting with the element in sorted_arr. Otherwise, return [-1, -1]. Use O(1) extra space and do not modify the input. ▶Example: sorted_arr = [-5, -4, -1, 4, 6, 6, 7] unsorted_arr = [-3, 7, 18, 4, 6] Output: [1, 3]. We can use -4 from the sorted array and 4 from the unsorted array. PROBLEM 29.5 T A R G E T C O U N T D I V I S I B L E B Y K Given a sorted array of integers, arr, a target value, target, and a positive integer, k, return whether the number of occurrences of the target in the array is a multiple of k. ▶Example: arr = [1, 2, 2, 2, 2, 2, 2, 3] target = 2, k = 3 Output: True. 2 occurs 6 times, which is a multiple of 3. ▶Example: arr = [1, 2, 2, 2, 2, 2, 2, 3] target = 2, k = 4 Output: False. 2 occurs 6 times, which is not a multiple of 4. ▶Example: arr = [1, 2, 2, 2, 2, 2, 2, 3] target = 4, k = 3 Output: True. 4 occurs 0 times, and 0 is a multiple of any number. PROBLEM 29.6 R A C E O V E R T A K I N G Yo u a r e g i v e n t w o a r r a y s o f p o s i t i v e i n t e g e r s , p1 and p2, representing players in a racing game. The two arrays are sorted, non-empty, and have the same length, n. The i-th element of each array corresponds to where that player was on the track at the i-th second of the race. We know that: 1. player 1 started ahead (p1[0] > p2[0]), 2. player 2 overtook player 1 once, and 3. player 2 remained ahead until the end (p1[n - 1] < p2[n - 1]). Assume the arrays have no duplicates, and that p1[i] != p2[i] for any index. Return the index at which player 2 overtook player 1. ▶Example: p1 = [2, 4, 6, 8, 10], p2 = [1, 3, 5, 9, 11] CHAPTER 29 ▸ BINARY SEARCH 335 Output: 3 PROBLEM 29.7 S E A R C H I N S O R T E D G R I D Yo u ' r e g i v e n a 2 D g r i d o f i n t e g e r s , grid, where each row is sorted (without duplicates), and the last value in each row is smaller than the ! rst value in the following row. You are also given a target value, target. If the target is in the grid, return an array with its row and column indices. Otherwise, return [-1, -1]. ▶Example: target = 4 grid = [[1, 2, 4, 5], [6, 7, 8, 9]] Output: [0, 2]. The number 4 is found in row 0 column 2. ▶Example: target = 3 grid = [[1, 2, 4, 5], [6, 7, 8, 9]] Output: [-1, -1] PROBLEM 29.8 S E A R C H I N H U G E A R R A Y We are trying to search for a target integer, target, in a sorted array of positive integers (duplicates allowed) that is too big to ! t into memory. We can only access the array through an API, fetch(i), which returns the value at index i if i is within bounds or -1 otherwise. Using as few calls to the API as possible, return the index of the target, or -1 if it does not exist. If the target appears multiple times, return any of the indices. There is no API to get the array's length. PROBLEM SET SOLUTIONS SOLUTION 29.3 V A L L E Y B O T T O M This problem shows that binary search can be used even if the input array is not monotonically sorted. Intuitively, we want to de! ne the 'before' region as the descending pre! x and the 'after' region as the ascend- ing su# x. The tricky part is that an array like [6, 5, 4, 7, 9] can be formed in two ways: •With a descending pre! x [6, 5, 4] and an ascending su# x [7, 9]. •With a descending pre! x [6, 5] and an ascending su# x [4, 7, 9]. We need a clear rule for how to de! ne is_before(). For instance, if we want the 4 to be in the 'before' region, we can say that a number is in the 'before' region if (a) it is the ! rst element, or (b) it's smaller than the previous element. This de! nition is workable, but according to it, an array like [7, 6, 5] only contains 'before' elements; we need to check for that case during preprocessing. With this de! nition, elements in the ‘after’ region are always greater than the previous element, so the small- est value in the entire array will be the last one in the ‘before’ region. 1 def valley_min_index(arr): 2 def is_before(i): 3 return i == 0 or arr[i]",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 9",
      "content": "< arr[i-1] 4 l, r = 0, len(arr)-1 5 if is_before(r): 6 return arr[r] 7 while r - l > 1: 8 mid = (l + r) // 2 336 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALO G OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co 9 if is_before(mid): 10 l = mid 11 else: 12 r = mid 13 return arr[l] Interestingly, in the variation of this problem where we allow duplicates in the input, binary search does not work: if mid lands on a value that is the same as the previous one and the next one, we can't tell if we are in the descending pre!x or the ascending su#x. 6 SOLUTION 29.4 2\"ARRAY 2\"SUM This problem, which is a variant of the classic 2-sum problem, shows binary search as a building block of a broader algorithm. Let n1 be the length of the sorted array and n2 the length of the unsorted array. The \"only O(1) extra space\" constraint means that we can't use a map-based solution, which would take O(n1) or O(n2) space. Instead, we can iterate through the numbers in the unsorted array and, for each one, binary search for its inverse in the sorted array. The total runtime will be O(n2 * log n1). 1 def two_array_two_sum(sorted_arr, unsorted_arr): 2 for i, val in enumerate(unsorted_arr): 3 idx = binary_search(sorted_arr, -val) 4 if idx != -1: 5 return [idx, i] 6 return [-1, -1] We omit the binary search step because it is the same as Solution 1. SOLUTION 29.5 TA R G E T CO U N T D I V I S I B L E BY K The key is to !nd the !rst and last occurrence of the target, first and last. If present, the number of occur- rences of the target is last - first + 1. We can check if this number is multiple of k. If the target is in the array, we can !nd first and last with a binary search for each: •one de!ning 'before' as '< target' and returning r, •one de!ning 'before' as '< target + 1' and returning l. The runtime is O(2*log n) = O(log n). SOLUTION 29.6 RACE OVERTAKING We say an index is 'before' if player 2 has not overtaken player 1 yet. That is: 1 def is_before(i): 2 return p1[i] > p2[i] According to the statement, index 0 is 'before' and index n-1 is 'after,' so we don't need to worry about the initial edge cases. We just need to !nd the transition point and return r. SOLUTION 29.7 SEARCH IN SORTED GRID We could solve this problem in two steps: 1. Binary search over the rows to !nd a single row that may contain the target. 2. Binary search over the row. 6 In fact, for this variant, we cannot do better than O(n) time. The array could consist of all 1's and a single 0, which could be anywhere and can only be found with a linear scan. CHAPTER 29 ▸ BINARY SEARCH 337 While this works, a trick that makes the implementation easier is to imagine that we \"% atten\" the grid into a single, long array with all the rows consecutively: Figure 5. This would be a sorted array with R*C elements. We can binary search over this '% attened-grid' array without actually creating it. We'd start with l = 0 and r = R*C - 1. To de! ne the is_before() function, we must map the '% attened-grid’ array index to the actual grid coordinates on the % y: 1 def is_before(grid, i, target): 2 num_cols = len(grid[0]) 3 row, col = i // num_cols, i % num_cols 4 return grid[row][col] < target Once we ! nd the transition point, we have to map r back to grid coordinates to check if the target is there and return them. REUSABLE IDEA: GRID FLATTENING If we want to iterate or search through a grid with dimensions RxC as if it was a 'normal' array of length R*C, we can use the following mapping from grid coordinates to \"% attened-grid array\" coordinates: [r, c] → r * C + c and the reverse mapping to go from \"% attened-grid array\" coordinates to grid coordinates: i → [i // C, i % C] For instance, cell [1, 2] in Figure 5 (the 9) becomes index 1 * 4 + 2 = 6, and, conversely, index 6 becomes cell [6 // 4, 6 % 4] = [1, 2]. SOLUTION 29.8 S E A R C H I N H U G E A R R A Y Leveraging the break down the problem booster, we can break the problem into two. One problem is quickly ! nding the target in a huge array. Binary search is an obvious choice here, but it leads to the second problem: our left pointer can start at zero, but where do we start our right pointer without knowing the length of the array? A silly way to solve this would be to keep trying one index after another until the API eventually returns -1. Instead, we can double our index at each step. If the length is n, we'll reach it in approximately log 2 (n) steps. The rest of the problem is a straightforward application of the transition-point recipe. 1 def fi nd_through_api(target): 2 def is_before(idx): 3 return fetch(idx) < target 4 l, r = 0, 1 5 # Step 1: Get the rightmost boundary 6 while fetch(r) != -1: 7 r *= 2 8 # Step 2: Binary search 9 # ... 338 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co The total runtime is O(log n), where n is the size of the huge array. REUSABLE IDEA: EXPONENTIAL SEARCH Whenever we need to search for a value in a range, but the upper bound (or even lower bound) of the",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 10",
      "content": "range is unknown, we can ! nd it e# ciently with repeated doubling. This is often useful in the guess-and-check technique (e.g., Problem 29.10: Water Re! lling, pg 340). G U E S S $A N D $C H E C K T E C H N I Q U E Since I was unable to come up with any approach, I knew the solution was going to be Binary Search. Anonymous Leetcode User, 2023 As the stolen bike story illustrates, binary search is often used in problems where it is not an obvious choice. Now that we have a solid recipe for any binary search problem, we will discuss the guess-and-check tech- nique, which allows us to use binary search on many optimization problems. Recall that an optimization problem is one where you are asked to ! nd some minimum or maximum value, subject to some constraint. For example, consider the following problem: PROBLEM 29.9 M I N \"S U B A R R A Y \"S U M S P L I T Given a non-empty array with n positive integers, arr, and a number k with 1 ≤ k ≤ n, the goal is to split arr into k non-empty subarrays so that the largest sum across all subarrays is minimized. Return the largest sum across all k subarrays after making it as small as possible. Each subarray must contain at least one value. ▶Example: arr = [10, 5, 8, 9, 11], k = 3 Output: 17. There are six ways of splitting the array into three subarrays. The optimal split is: [10, 5], [8, 9], and [11]. The largest sum among the three subarrays is 17. ▶Example: arr = [10, 10, 10, 10, 10], k = 2 Output: 30. SOLUTION 29.9 M I N \"S U B A R R A Y \"S U M S P L I T This is an optimization problem because we have a goal and a constraint: we are trying to minimize the largest subarray sum, subject to having at most k subarrays. Without the constraint, we would just put every element in its own subarray. A naive solution that tries every way of splitting the array into k subarrays would take exponential time. 7 There is a dynamic programming solution that takes O(n*k) time (pg 572). Here, we'll use a di\" erent approach. Given a value, max_sum, we can ask: Is there a way to split arr into k subarrays such that every subarray has sum at most max_sum? •For max_sum < max(arr), the answer is \"no\" (some numbers are too big to be in a subarray, even by themselves). 7 You need to choose k out of n-1 possible splitting points, so there are (n-1 choose k) options, which is O((n-1) k ) = O(n k ) for any constant value of k. If k is n/2, the number becomes exponential on n (O(2 n /√n) to be exact, but you don't need to worry about where that formula comes from). Once k gets larger than n/2, the number of possibilities starts decreasing (if we are picking more than half the points, we can think about picking the points not to split at, of which there are fewer than n/2). CHAPTER 29 ▸ BINARY SEARCH 339 •For max_sum == sum(arr), the answer is \"yes\" (any split will do). We can binary search for the transition point where the answer goes from \"no\" to \"yes\" with our transition point recipe. The value x corresponding to the !rst \"yes\" is the value of the optimal solution. To i m p l e m e n t o u r is_before(max_sum) function, we need to be able to compute the answer to the ques- tion. Thankfully, it is much easier than the original problem: we can grow each subarray up until the point where its sum would exceed max_sum. At that point, we start a new subarray, and so on. If we need more than k subarrays, the answer is \"no.\" Otherwise, the answer is \"yes.\" 1 # \"Is it impossible to split arr into k subarrays, each with sum <= max_sum?\" 2 def is_before(arr, k, max_sum): 3 splits_required = get_splits_required(arr, max_sum) 4 return splits_required > k 5 6 # Returns the minimum number of subarrays with a given maximum sum. 7 # Assumes that max_sum >= max(arr). 8 def get_splits_required(arr, max_sum): 9 splits_required = 1 10 current_sum = 0 11 for num in arr: 12 if current_sum + num > max_sum: 13 splits_required += 1 14 current_sum = num # Start a new subarray with the current number. 15 else: 16 current_sum += num 17 return splits_required 18 19 def min_subarray_sum_split(arr, k): 20 l, r = max(arr), sum(arr) # Range for the maximum subarray sum. 21 if not is_before(arr, k, l): 22 return l 23 while r - l > 1: 24 mid = (l + r) // 2 25 if is_before(arr, k, mid): 26 l = mid 27 else: 28 r = mid 29 return r Let S be the sum of arr. Binary search will take O(log S) steps to converge, and each is_before() check takes O(n) time. The total runtime is O(n log S). Depending on whether O(k) or O(log S) is larger, DP or binary search will be better. Neither dominates the other. To re c a p, t h e guess-and-check technique involves narrowing in on the value of the optimal solution by guessing the midpoint and checking whether it's too high or too low. To start, we need lower and upper bounds for the value of the optimal solution (if the bounds are not obvious, exponential search can help). For minimization problems (like Problem 29.9: Min-Subarray-Sum Split), there is often a transition point where smaller values do not satisfy the constraint, but larger values do. Conversely, for maximization problems, there is often a transition point where larger values do not satisfy the constraint, but smaller values do. When should I use the guess-and-check technique?",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 11",
      "content": "We can try it when we have an optimization problem and !nding the optimal value directly is challenging. Ask yourself: 340 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co \"Is it easier to solve the yes/no version of the problem, where we just check if a given value (optimal or not) satis! es the constraint?\" Think of it like making a deal: You get to solve an easier problem (checking if a speci! c value satis! es the constraint), but you pay a 'logarithmic tax' in the runtime (to binary searching for the transition point). We've seen the guess-and-check technique before, in the Boundary Thinking chapter with Problem 22.1: Tunnel Depth (pg 232). It is easier to binary search for the ! rst depth where the tunnel doesn't reach than to try to compute the maximum depth directly. BOUNDARY THINKING IN ACTION 8 INTERVIEW REPLAY View Online:bctci.co/binary-search-replay-1 @ 38:55 - end The Question:Return the maximum tunnel depth in a grid. What You'll See:The candidate chose a graph traversal after seeing the grid, and the interviewer and candidate discussed multiple solutions and how to avoid getting \"tunnel\" vision. Who: Interviewer: Software Engineer at Google Candidate: 7 years exp. GUESS-AND-CHECK PROBLEM SET Try these problems with AI Interviewer: bctci.co/binary-search-problem-set-2 PROBLEM 29.10 W A T E R R E F I L L I N G We have an empty container with a capacity of a gallons of water and another container with a capacity of b gallons. Return how many times you can pour the second container full of water into the ! rst one without over% owing. Assume that a > b. •Constraint: You are not allowed to use the division operation, but you can use still divide by powers of two with the right-shift operator, >>. Recall that x >> 1 is the same as x // 2. ▶Example: a = 18, b = 5 Output: 3. After pouring 5 gallons three times, the first container will be at 15, and 5 more gallons would make it overflow. PROBLEM 29.11 MIN PAGES PER DAY You have upcoming interviews and have selected speci! c chapters from BCtCI to read beforehand. Given an array, page_counts, where each element represents a chapter’s page count, and the number of days, days, until your interview, determine the minimum number of pages you must read daily to ! nish on time. Assume that: •You must read all the pages of a chapter before moving on to another one. 9 8 I (Mike) am the interviewer in this particular interview. This question was the opener for the Boundary Thinking chapter and you can see a candidate make the same mistakes we discuss in that chapter and me walking through the boundary thinking mentality. 9 Hypothetically! It's ! ne to jump around chapters when reading this actual book. CHAPTER 29 ▸ BINARY SEARCH 341 •If you ! nish a chapter on a given day, you practice for the rest of the day and don't start the next chapter until the next day. •len(page_counts) ≤ days. ▶Example: page_counts = [20, 15, 17, 10], days = 14 Output: 5. We can read 5 pages daily and finish all chapters. At a maximum of 5 pages per day, we spend: 4 days on the first chapter. 3 days on the second chapter. 4 days on the third chapter (stopping when we finish early). 2 days on the fourth chapter. In total, we spent 13 days reading 5 pages a day, which is the lowest amount we can read daily and still finish on time. ▶Example: page_counts = [20, 15, 17, 10], days = 5 Output: 17 PROBLEM 29.12 TIDE AERIAL VIEW You are provided a series of aerial-view pictures of the same coastal region, taken a few minutes apart from each other around the time the tide rises. Each picture consists of an nxn binary grid, where 0 represents a part of the region above water, and 1 represents a part below water. • The tide appears from the left side and rises toward the right, so, in each picture, for each row, all the 1's will be before all the 0's. •Once a region is under water, it stays under water. •All pictures are di\" erent. Determine which picture shows the most even balance between regions above and below water (i.e., where the number of 1's most closely equals the number of 0's). In the event of a tie, return the earliest picture. Figure 6. Example input for Problem 9. The empty cells are 0's and the cells with water are 1's. ▶Example: The pictures from Figure 6. Output: 2. The pictures at index 2 and 3 are equally far from having 50% water. We break the tie by picking the earlier one, 2. PROBLEM SET SOLUTIONS SOLUTION 29.10 W A T E R R E F I L L I N G Tr y to solve this problem manually for a = 182983 and b = 90. Use a calculator if you want, just do not use the division operation. Done? How did you do it? Try toreverse engineer your process and map it to an algorithmic technique. What you de! nitely didn't do is check sequential multiples of 90 until you reached 182983. Most people make guesses in increasingly larger jumps until they ! nd a guess that is too large. If we double the guess at 342 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALO G OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co each time, this is exponential search (pg 338). Then, they start searching between their closest guess below and above the answer, closing in on the number—something we can do with binary search. Despite the problem not having clear triggers for binary search, it's a natural !t for this thought process. 1 def num_refills(a, b): 2 # \"Can we pour 'num_pours' times?\" 3 def is_before(num_pours): 4",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 12",
      "content": "return num_pours * b <= a 5 6 # Exponential search (repeated doubling until we find an upper bound). 7 k = 1 8 while is_before(k * 2): 9 k *= 2 10 11 # Binary search between k and k*2 12 l, r = k, k * 2 13 while r-l > 1: 14 gap = r - l 15 half_gap = gap >> 1 # Bit shift instead of division 16 mid = l + half_gap 17 if is_before(mid): 18 l = mid 19 else: 20 r = mid 21 return l SOLUTION 29.11 MIN PAGES PER DAY For a given value daily_limit, we pose the question: Can I !nish all the chapters in time reading at most daily_limit pages a day? We can guess and check for the answer to this question. Since we can only !nish one chapter per day, the maximum answer is the longest chapter (20 pages in the example). The minimum is 1 page per day. We can binary search between these bounds and simulate reading the guessed amount of pages per day. If the guess allows us to !nish within the given days, we try a smaller number. If it takes too many days, we try a larger number. 1 def days_to_finish(page_counts, daily_limit): 2 days = 0 3 for pages in page_counts: 4 days += math.ceil(pages / daily_limit) 5 return days 6 7 def is_before(page_counts, daily_limit, days): 8 return days_to_finish(page_counts, daily_limit) <= days SOLUTION 29.12 TIDE AERIAL VIEW We can binary search for the transition point where it goes from majority above water to majority underwater. The 'before' pictures are < 0.5 water, and the 'after' pictures are ≥ 0.5 water. The answer will be the last 'before' or the !rst 'after.' However, if you constructed the is_before() function to just loop through the matrix, counting the number of cells underwater, you missed something! Besides doing a binary search across the range of pictures, we can CHAPTER 29 ▸ BINARY SEARCH 343 speed up the count of underwater cells by also doing a binary search on each row: the rows are monotonic, with all 1's followed by all 0's. 1 def get_ones_in_row(row): 2 if row[0] == 0: 3 return 0 4 if row[-1] == 1: 5 return len(row) 6 7 def is_before_row(idx): 8 return row[idx] == 1 9 10 l, r = 0, len(row) 11 while r - l > 1: 12 mid = (l + r) // 2 13 if is_before_row(mid): 14 l = mid 15 else: 16 r = mid 17 return r 1 def is_before(picture): 2 water = 0 3 for row in picture: 4 water += get_ones_in_row(row) 5 total = len(picture[0])**2 6 return water/total < 0.5 Checking the number of ones in a row takes O(log n) time. Checking the number of ones in an entire grid takes O(n log n) time. The total time is O(n log n log k), where k is the number of pictures. BINARY SEARCH GONE WRONG INTERVIEW REPLAY View Online:bctci.co/binary-search-replay-2 @ 2:45 - 26:07:00 The Question:Write an algorithm to compute the square root of a given non-negative number What You'll See:The candidate struggled to implement a working version of binary search, and each change led to further problems with the algorithm. Who: Interviewer: Software Engineer at Meta Candidate: 7 years exp. CONCLUSIONS Binary Search triggers: The input is a sorted array/string. The brute force involves repeated linear scans. We are given an optimization problem that's hard to optimize directly. Keywords: sorted, threshold, range, boundary, ! nd, search, minimum/maximum, ! rst/last, small- est/largest. Binary search is often a step or a possible optimization in more complicated algorithms. Binary search is so common that it can (and will) be seen alongside almost every other Catalog topic, like Graphs (Problem 36.9: First Time All Connected, pg 468), Sliding Windows (Chapter 38: Longest Repeated Substring, pg 523), and Greedy Algorithms (Problem 41.6: Time Traveler Max Year, pg 593). The key idea in this chapter is that we can reframe every binary search problem as ! nding a transition point. This way, we only need one recipe for every scenario—the transition-point recipe (pg 329)—and we can focus our energy on more complicated parts of the code. 344 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co At this point, you should be ready to start adding binary search problems to your practice rotation. You can ! nd the problems in this chapter and additional problems in the companion AI interviewer. ONLINE RESOURCES Online resources for this chapter include: •A chance to try each problem in this chapter in AI Interviewer • Interview replays that show speci! c mistakes people make with binary search problems • Full code solutions for every problem in the chapter in multiple programming languages Try online at bctci.co/binary-search. CHAPTER 38 A I interviewer, replays, and more materials for this chapter at bctci.co/sliding-windows I CHAPTER 38 I CHAPTER 38 II SLIDING WINDOWS ▶Prerequisites: None In this chapter, we will use the sliding window technique to tackle problems about ! nding or counting subarrays. 1 We will use the following setting for problems throughout this chapter: a bookstore is looking at the number of book sales. The sales for each day are stored in an array of non-negative integers called sales. We say a good day is a day with at least 10 sales, while a bad day is a day with fewer than 10 sales. An interviewer could ask questions such as the following: •Find the most sales in any 7-day period (Problem 1). •Find the most consecutive days with no bad days (Problem 5). •Find the longest period of time with at most 3 bad days (Problem 8). •Find the shortest period of time with more than 20 sales, if any (Problem 14). •Count the number of subarrays of sales with at most 10 bad days (Problem 18). •Count the number of subarrays of sales with exactly 10 bad days (Problem",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 13",
      "content": "19). •Count the number of subarrays of sales with at least 10 bad days (Problem 20). All these questions receive an array as input, sales. The ! rst four ask us to ! nd a subarray, while the last three ask us to count subarrays, making them ideal candidates for the sliding window technique. In this chapter, we will cover variants of the sliding window technique to tackle each of the mentioned problems and more. The basic idea of a sliding window is to consider a subarray (the \"window\"), marked by left (l) and right (r) pointers. We move or \"slide\" the window to the right by increasing the l and r pointers, all while computing some value about the current window. 23 1 Beyond DS&A, the term 'sliding window' is also used in network protocols like TCP (https://en.wikipedia.org/wiki/ Transmission_Control_Protocol) and in machine learning architectures like convolutional neural networks (https:// en.wikipedia.org/wiki/Convolutional_neural_network). 2 A sliding window is a special case of the two-pointer technique. Like in the Two Pointers chapter, we use the terms \"pointer\" and \"index\" interchangeably. 3 Sliding windows are usually not useful for problems about subsequences because they don't have a good way of dealing with \"skipping\" elements. Subsequence problems are more commonly tackled with other techniques that we will see later, like dynamic programming or backtracking. Sliding Windows 510 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co Figure 1. Window 1 is a subarray from l = 4 (included) to r = 10 (excluded). We can slide it and get Window 2 by increasing l and r. THE ELEMENTS OF A SLIDING WINDOW PROBLEM Problems where sliding windows may be useful tend to involve the following: •You have to ! nd a subarray of an input array. • This subarray must satisfy some constraint, which separates the subarrays into valid and invalid. Examples of constraints: »The length must be k (for some given value k). »The sum must be at least / at most / exactly k. »It must contain or not contain speci! c elements. »It must not contain repeated elements. •There is usually an objective that makes some subarrays \"better\" than others. For example: »Maximize/minimize the length of the window. »Maximize/minimize the sum of the elements in the window. »Maximize/minimize the number of distinct elements in the window. •Less commonly, if there is no objective, the goal may be to count the number of valid subarrays. For instance, in the ! rst bookstore problem, the constraint is \"the length of the subarray must be 7,\" and the objective is to maximize the sum. In the last one, the constraint is \"at least 10 bad days,\" and there is no objective since it is a counting problem. Can you identify the constraints and objectives for the other bookstore problems? BRUTE FORCE BASELINE Most sliding window problems can be solved with a brute force algorithm that checks every subarray one by one. If the subarray is valid, then we check if it's the best one so far. The brute force solution is correct, but we'd ideally like a more optimized solution. Before diving into how to do this, it can be useful to consider what our upper bound, lower bound, and target runtimes might be (see the Boundary Thinking chapter). • Upper bound: O(n 3 ) will be the most common brute force upper bound across sliding window prob- lems, where n is the length of the input array. There are O(n 2 ) subarrays to search through. For each of those, checking whether it is valid and the best so far in a naive way could take O(n) time. • Lower bound: if we don't look at every element in the input, we won't even know what some substrings look like, so O(n) is the natural lower bound. • Ta rg e t : t h e s l i d i n g w i n d ow te c h n i q u e o f te n a l l ows u s to re a c h a l i n e a r r u nt i m e, s o we s h o u l d a i m fo r t h at. CHAPTER 38 ▸ SLIDING WINDOWS 511 H O W T O S L I D E A W I N D O W To make things easy to remember, we follow some conventions for initializing and updating all sliding windows in this chapter: 1. The window goes from the element at index l (inclusive) to the element at index r(exclusive). This means: »the window is empty when l == r, »r points to the ! rst element after the window (if any), and »the length of the window is r - l. 2. We always initialize l and r to 0, meaning the window starts empty. 3. We grow the window by incrementing r. We can only grow it when r < len(arr). 4. We shrink the window by incrementing l. We can only shrink it when l < r. 5. We always have 0 ≤ l ≤ r ≤ len(arr). Consistency enables us to predict what our possible o\" -by-one errors are likely to be. For instance, r - l always means \"the size of the window,\" and l == r always means \"the window is empty,\" without worrying about o\" -by-one errors. 4 ANALYZING SLIDING WINDOWS Every sliding window consists of a main loop, where, at each iteration, we either grow or shrink the window, or both. Since r never decreases and runs from 0 to n, our window can only grow n times. By this same token, the window can only shrink (by increasing l) n times. This means that any properly implemented sliding window does at most O(2n) = O(n) iterations. To get the total runtime, we need to multiply the number of iterations, O(n), by the",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 14",
      "content": "time per iteration. As long as each iteration grows or shrinks the window (or both), a sliding window algorithm takes O(n*T) time, where n is the size of the array we are sliding over and T is the time per iteration. Typically, we will be unlikely to reduce the number of iterations—we must reach the end of the array—so we should focus on reducing T: the time per iteration. We should try to get it down to constant time. In terms of space analysis, remember that the window is not materialized, it is just identi! ed by the two pointers. So, the space analysis will depend on what other information about the window we need to store. FIXED$LENGTH WINDOWS In ! xed-length window problems, we have to ! nd a subarray under the constraint that it has a given length. Such problems, which are fairly common, are on the easier side because there are not many subarrays to consider: for a value k in the range 1 ≤ k ≤ n, an array only has n-k+1 = O(n) subarrays of length k—a lot fewer than O(n 2 ). Recall the ! rst opening problem: PROBLEM 38.1 M O S T W E E K L Y S A L E S Given an array, sales, ! nd the most sales in any 7-day period. ▶Example: sales = [0, 3, 7, 12, 10, 5, 0, 1, 0, 15, 12, 11, 1] 4 Our convention is that l is inclusive and r is exclusive, but this is merely our convention. If you prefer to consider r as inclusive, this is equally correct, but be sure to update the little details like the size of the window (which would now be r - l + 1). Whatever you do, be explicit about your convention and make sure the little details match. 512 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co Output: 44. The 7-day period with the most sales is [5, 0, 1, 0, 15, 12, 11] ▶Example: sales = [0, 3, 7, 12] Output: 0. There is no 7-day period. SOLUTION 38.1 M O S T W E E K L Y S A L E S The fact that we are only looking for windows of length 7 gives us a simple strategy for when to grow and shrink the window: 1. Grow the window until it has length 7. 2. Grow and shrink at the same time so that the length stays at 7. Here is a full solution: 1 def most_weekly_sales(sales): 2 l, r = 0, 0 3 window_sum = 0 4 cur_max = 0 5 while r < len(sales): 6 window_sum += sales[r] 7 r += 1 8 if r - l == 7: 9 cur_max = max(cur_max, window_sum) 10 window_sum -= sales[l] 11 l += 1 12 return cur_max Figure 2. The sliding window of most_weekly_sales(). On top of our window pointers, l and r, we have: • window_sum: the sum of elements in the window, which corresponds to the objective we have to maximize. The key is to update it whenever the window grows or shrinks and not compute it from scratch at each iteration. •cur_max: where we keep the current maximum we have seen so far. Each iteration starts by growing the window, which involves two things: updating window_sum to re% ect that sales[r] is now in the window, and increasing r. The order of these operations matters! After growing the window, we check if it is valid, meaning the window length (r - l) is 7. If it is valid, we check if it is the best one seen so far and update cur_max accordingly. CHAPTER 38 ▸ SLIDING WINDOWS 513 If the window has a length of 7, we end the iteration by shrinking it so that when we grow it in the next itera- tion, it will have the right size again. Like growing, shrinking consists of two actions: updating window_sum and increasing l. The algorithm ends when the window can no longer grow (r == len(sales)). We can put these ideas together in a general recipe for ! xed-length window problems: RECIPE 1. FIXED\"LENGTH WINDOW RECIPE. fi xed_length_window(arr, k): initialize: - l and r to 0 (empty window) - data structures to track window info - cur_best to 0 while we can grow the window (r < len(arr)) grow the window (update data structures and increase r) if the window has the correct length (r - l == k) update cur_best if needed shrink the window (update data structures and increase l) return cur_best By \"data structures,\" we mean any information about the window that we need to maintain as we slide it in order to evaluate each window quickly. The data structures that we need change from problem to problem, and they could range from nothing at all to things like sets and maps. In the following problem set, you will have to consider what information to store about the window and how to update it e# ciently. # Maintaining information about the window as it slides is a key idea in designing e# cient sliding windows. NESTED LOOPS ARE TOO SLOW FOR SLIDING WINDOW QUESTIONS INTERVIEW REPLAY View Online:bctci.co/sliding-windows-replay-1 @ 10:36 - 47:30 The Question:Given an array of positive numbers and a positive number k, ! nd the maxi- mum sum of any contiguous subarray of size k. What You'll See:The candidate struggled to identify the problem as a sliding window prob- lem and coded the brute force instead of an optimal answer. Who:Interviewer: Software Engineer at FAANG+ Candidate: College student FIXED-LENGTH WINDOWS PROBLEM SET Try these problems with AI Interviewer: bctci.co/sliding-windows-problem-set-1 We will continue with the bookstore setting. In addition to the sales array, we have an array of strings, best_seller, with the title of the most sold book for each day. Constraints: sales and best_seller have a length of at most 10 6 .",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 15",
      "content": "Each book title in best_seller has a length of at most 100. 514 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co PROBLEM 38.2 M O S T S A L E S I N K D A Y S Given the array sales and a number k with 1 ≤ k ≤ len(sales), ! nd the most sales in any k-day period. Return the ! rst day of that period (days start at 0). If there are multiple k-day periods with the most sales, return the ! rst day of the ! rst one. ▶Example: sales = [8, 1, 3, 7], k = 2 Output: 2. The subarray of length 2 with maximum sum is [3, 7], which starts at index 2. PROBLEM 38.3 U N I Q U E B E S T S E L L E R S T R E A K Given the array best_seller and a number k with 1 ≤ k ≤ len(sales), return whether there is any k-day period where each day has a di\" erent best-selling title. ▶Example: best_seller = [\"book3\", \"book1\", \"book3\", \"book3\", \"book2\", \"book3\", \"book4\", \"book3\"], k = 3 Output: True. There is a 3-day period without a repeated value: [\"book2\", \"book3\", \"book4\"]. ▶Example: best_seller = [\"book3\", \"book1\", \"book3\", \"book3\", \"book2\", \"book3\", \"book4\", \"book3\"], k = 4 Output: False. There are no 4-day periods without a repeated value. PROBLEM 38.4 E N D U R I N G B E S T S E L L E R S T R E A K Given the array best_seller and a number k with 1 ≤ k ≤ len(sales), return whether there is any k-day period where every day has thesame best-selling title. ▶Example: best_seller = [\"book3\", \"book1\", \"book3\", \"book3\", \"book2\"], k = 3 Output: False. ▶Example: best_seller = [\"book3\", \"book1\", \"book3\", \"book3\", \"book2\"], k = 2 Output: True. PROBLEM SET SOLUTIONS SOLUTION 38.2 M O S T S A L E S I N K D A Y S We can reuse our solution to the previous problem, tweaking it slightly: replacing 7 with k and tracking the position of the best window in addition to its sum. SOLUTION 38.3 U N I Q U E B E S T S E L L E R S T R E A K In this problem, we need to check each window of length k for duplicate titles. Checking for duplicates in an array can be done in linear time using a hash map, assuming we can hash each element in constant time (recall that 'checking for duplicates' is a trigger for hash sets and maps). As mentioned, e# cient sliding window algorithms usually maintain information about the window. In this case, the information we need is a frequency map (the reusable idea from pg 348): a hash map from the titles in the window to the number of times that they appear in the window. So, for a window like [\"book3\", \"book1\", \"book3\"], the map would be {\"book3\": 2, \"book1\": 1}. We can update this map in O(1) time whenever the window grows or shrinks. CHAPTER 38 ▸ SLIDING WINDOWS 515 We remove book titles from the map if their count goes back down to 0. This way, the size of the map always represents the number of unique keys (book titles) in the window, and the window satis! es the constraint if the map size is k. The extra space of our solution is O(k). 5 1 def has_unique_k_days(best_seller, k): 2 l, r = 0, 0 3 window_counts = {} 4 while r < len(best_seller): 5 if not best_seller[r] in window_counts: 6 window_counts[best_seller[r]] = 0 7 window_counts[best_seller[r]] += 1 8 r += 1 9 if r - l == k: 10 if len(window_counts) == k: 11 return True 12 window_counts[best_seller[l]] -= 1 13 if window_counts[best_seller[l]] == 0: 14 del window_counts[best_seller[l]] 15 l += 1 16 return False #Frequency maps are often useful in sliding window problems. SOLUTION 38.4 E N D U R I N G B E S T S E L L E R S T R E A K This problem can be solved exactly the same way as the previous one, just by changing the window validity condition from len(window_counts) == k to len(window_counts) == 1. However, this solution requires O(k) extra space for the frequency map. Can you think of a constant-space solution? We'll see one in the next section about the next type of sliding windows: resetting windows. RESETTING WINDOWS We call the next type of sliding window \"resetting windows.\" It is for problems where a bigger window is usually better, but a singleelement in the array can make the whole window invalid. Our approach will be simple: grow the window if we can, and otherwise reset it to empty past the problematic element. Recall the second opening bookstore problem: PROBLEM 38.5 L O N G E S T G O O D D A Y S T R E A K Given an array, sales, ! nd the most consecutive days with no bad days (fewer than 10 sales). ▶Example: sales = [0, 14, 7, 12, 10, 20] Output: 3. The subarray [12, 10, 20] has no bad days. SOLUTION 38.5 L O N G E S T G O O D D A Y S T R E A K This is a resetting window problem because if we encounter a bad day, whatever window we have so far needs to be discarded. This gives us a simple strategy for when to grow and shrink the window: 1. If the next day is good, grow the window. 2. If the next day is bad, skip it and reset the window. 5 Don't forget that when storing strings in a map, the space complexity of the map is not just the number of strings, as we also need to factor in the length of the strings. For this",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 16",
      "content": "problem, we said that all the titles would have length at most 100, so the space complexity is O(100 * k) = O(k). 516 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co 1 def max_no_bad_days(sales): 2 l, r = 0, 0 3 cur_max = 0 4 while r < len(sales): 5 can_grow = sales[r] >= 10 6 if can_grow: 7 r += 1 8 cur_max = max(cur_max, r - l) 9 else: 10 l = r+1 11 r = r+1 12 return cur_max Figure 3. Illustration of the sliding window for max_no_bad_days(). Unlike in the ! xed-length window case, a resetting window stays valid throughout the algorithm. We also introduced a can_grow variable to decide whether to growor reset. 6 When sales[r] is a bad day, we reset the window by moving both l and r past the problematic element. Once the window cannot grow anymore (r == len(sales)), we stop, as we surely won't ! nd a bigger window by shrinking it. We can put these ideas together in a general recipe for resetting window problems. RECIPE 2. RESETTING WINDOW RECIPE. resetting_window(arr): initialize: - l and r to 0 (empty window) - data structures to track window info - cur_best to 0 while we can grow the window (r < len(arr)) if the window is still valid with one more element grow the window (update data structures and increase r) update cur_best if needed else reset window and data structures past the problematic element return cur_best Now that we have seen two types of sliding windows, it is worth mentioning that problems can ! t the criteria for more than one window type. Recall Problem 38.4: \"Given the array best_seller and a number k with 1 ≤ k ≤ len(sales), return whether there is any k-day period where every day has thesame best-selling title.\" We can solve it with a ! xed-length window like we saw, or with a resetting window: 6 You could skip declaring the variable can_grow and put the condition directly in the if statement, but the name \"can_grow\" makes it clear what the if/else cases correspond to, so it is extra easy for the interviewer to follow. CHAPTER 38 ▸ SLIDING WINDOWS 517 We grow the window when it is (a) empty or (b) the next title is the same as every element in the window. We reset the window when the next element is di\" erent from the ones in the window. In that case, rather than skipping over the element that is di\" erent; we start growing a new window from that new element. 1 def has_enduring_best_seller_streak(best_seller, k): 2 l, r = 0, 0 3 cur_max = 0 4 while r < len(best_seller): 5 can_grow = l == r or best_seller[l] == best_seller[r] 6 if can_grow: 7 r += 1 8 if r - l == k: 9 return True 10 else: 11 l = r 12 return False This solution improves the extra space to O(1). RESETTING WINDOWS PROBLEM SET Try these problems with AI Interviewer: bctci.co/sliding-windows-problem-set-2 PROBLEM 38.6 M A X S U B A R R A Y S U M Given a non-empty array arr of integers (which can be negative), ! nd the non-empty subarray with the maximum sum and return its sum. ▶Example: arr = [1, 2, 3, -2, 1] Output: 6. The subarray with the maximum sum is [1, 2, 3]. ▶Example: arr = [1, 2, 3, -2, 7] Output: 11. The subarray with the maximum sum is the whole array. ▶Example: arr = [1, 2, 3, -8, 7] Output: 7. The subarray with the maximum sum is [7]. ▶Example: arr = [-2, -3, -4] Output: -2. The subarray cannot be empty. PROBLEM 38.7 L O N G E S T A L T E R N A T I N G S E Q U E N C E Given the array sales, ! nd the longest sequence of days alternating between good days (at least 10 sales) and bad days (fewer than 10 sales). ▶Example: sales = [8, 9, 20, 0, 9] Output: 3. The only good day is day 2, so the subarray [9, 20, 0] alternates from bad to good to bad. ▶Example: arr = [0, 0, 0] Output: 1. Every day is bad, so we cannot find any pair of consecutive days that alternate. 518 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co PROBLEM SET SOLUTIONS SOLUTION 38.6 M A X S U B A R R A Y S U M This is such a classic problem that the resetting window algorithm for it has its own name: Kadane's algorithm. Let's consider the logic for when to grow and shrink our window. If we encounter a positive number, we de! nitely want to grow the window, as it makes the window sum bigger. If we encounter a negative number, should we keep it and keep growing (as in Example 2), or should we reset the window past it (as in Example 3)? The answer depends on the sum of the window elements so far: • If our current window plus the negative element is still positive, it is worth keeping the current window even with the negative element. •If the negative element makes the window sum negative, it is not worth keeping; we should reset it. 7 1 def max_subarray_sum(arr): 2 max_val = max(arr) 3 if max_val <= 0: # Edge case without positive values. 4 return max_val 5 l, r = 0, 0 6 window_sum = 0 7 cur_max = 0 8 while r < len(arr): 9 can_grow = window_sum + arr[r] >= 0 10 if can_grow: 11 window_sum += arr[r] 12 r += 1 13 cur_max = max(cur_max, window_sum) 14 else: 15 window_sum = 0 16 l = r+1 17 r = r+1 18 return cur_max SOLUTION 38.7 L O N G",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 17",
      "content": "E S T A L T E R N A T I N G S E Q U E N C E This is a resetting window problem because if we ! nd two consecutive days that are both good or both bad, the whole window becomes invalid and we need to reset it (starting from the second of the two consecutive elements of the same type). We can grow the window when (a) it is empty or (b) the next element does not break the \"chain\" of alternating days ((sales[r - 1] < 10) != (sales[r] < 10)). MAXIMUM WINDOWS We are going to tackle general maximization problems (maximum length, maximum sum, etc.) with what we call maximum windows. Maximum windows grow when they can and shrink when they must. They are similar to resetting windows, but when we encounter an element that makes the window invalid, we don't discard the whole window and reset it. Instead, we shrink it element by element (by increasing l) until it becomes valid again. 7 In both cases, we need to increment r. You can see in our implementation that we could factor out that increment outside of the if/else cases and save a line of code. However, as we mentioned on page 297, when trying to come up with a valid solution, it is easier to think about each case independently ! rst—shared code between the cases can make it harder to reason about the correctness of your code. If you have time, once you are sure your code is correct, you can do a 'clean-up' pass to tidy up the code. CHAPTER 38 ▸ SLIDING WINDOWS 519 Recall the third opening bookstore problem: PROBLEM 38.8 MAXIMUM WITH AT MOST 3 BAD DAYS Given an array sales, ! nd the most consecutive days with at most 3 bad days (fewer than 10 sales). ▶Example: sales = [0, 14, 7, 9, 0, 20, 10, 0, 10] Output: 6. There are two 6-day periods with at most 3 bad days, [14, 7, 9, 0, 20, 10] and [9, 0, 20, 10, 0, 10]. SOLUTION 38.8 MAXIMUM WITH AT MOST 3 BAD DAYS We can follow this strategy for when to grow and shrink the window: 1. If the next day is good or the window contains fewer than 3 bad days, grow the window. 2. Otherwise, shrink it. Here is a full solution: 1 def max_at_most_3_bad_days(sales): 2 l, r = 0, 0 3 window_bad_days = 0 4 cur_max = 0 5 while r < len(sales): 6 can_grow = sales[r] >= 10 or window_bad_days < 3 7 if can_grow: 8 if sales[r] < 10: 9 window_bad_days += 1 10 r += 1 11 cur_max = max(cur_max, r - l) 12 else: 13 if sales[l] < 10: 14 window_bad_days -= 1 15 l += 1 16 return cur_max Figure 4. Sliding window for max_at_most_3_bad_days(). 520 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co Many elements of the solution should look similar to the resetting window recipe, like the can_grow variable. The only new part is what happens when we cannot grow the window. We remove onlythe ! rst element in the window (sales[l]). Here is a recipe for maximum windows. Note how, before shrinking the window, we need to check the case where the window is empty (l == r)—an empty window cannot be shrunk! For many problems, an empty window is always valid, so we can omit this check (for example, in this problem, an empty window is always valid because it has 0 bad days). RECIPE 3. MAXIMUM WINDOW RECIPE. maximum_window(arr): initialize: - l and r to 0 (empty window) - data structures to track window info - cur_best to 0 while we can grow the window (r < len(arr)) if the window would still be valid with one more element grow the window (update data structures and increase r) update cur_best if needed else if the window is empty advance both l and r else shrink the window (update data structures and increase l) return cur_best MAXIMUM WINDOWS PROBLEM SET Try these problems with AI Interviewer: bctci.co/sliding-windows-problem-set-3 Follow the maximum window recipe to tackle the following questions. PROBLEM 38.9 A D C A M P A I G N B O O S T Imagine that our little bookstore has an array, projected_sales, with the projected number of sales per day in the future. We are trying to pick k days for an advertising campaign, which we expect to boost the sales on those speci! c days by at least 20. If we pick the days for the advertising campaign correctly, what is the maximum number of consecutive good days in a row we can get? (Recall that a good day is a day with at least 10 sales.) ▶Example: projected_sales = [5, 0, 20, 0, 5], k = 2 Output: 3. The only good day is day 2. We can boost days 0 and 1, days 1 and 3, or days 3 and 4. For instance, if we boost days 0 and 1, the projected sales become [25, 20, 20, 0, 5], with 3 consecutive good days. ▶Example: arr = [0, 10, 0, 10], k = 1 Output: 3. We can boost day 2; boosting day 0 is suboptimal. PROBLEM 38.10 A D C A M P A I G N W I T H S M A L L B O O S T S In the previous problem, what would change if the boost from the advertising campaign was only 5 books instead of 20? You cannot boost the same day more than once. What is the maximum number of consecutive good days in a row we can get? CHAPTER 38 ▸ SLIDING WINDOWS 521 ▶Example: projected_sales = [8, 4, 8], k = 3 Output: 1. We can boost all 3 days, resulting in [13, 9, 13] projected sales. The max consecutive good days is 1.",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 18",
      "content": "▶Example: projected_sales = [10, 5, 8], k = 1 Output: 2. We should boost day 1, resulting in [10, 10, 8] projected sales. PROBLEM 38.11 B O O S T I N G D A Y S M U L T I P L E T I M E S In Problem 38.9, what would change if the boost from the advertising campaign was only 1 book instead of 20, but you can boost the same day more than once? What is the maximum number of consecutive good days in a row we can get? ▶Example: projected_sales = [5, 5, 15, 0, 10], k = 12 Output: 3. We can reach 3 consecutive good ways in two ways: boosting days 0 and 1, so both reach 10 sales, or boosting day 3. ▶Example: projected_sales = [5, 5, 15, 0, 10], k = 15 Output: 4. We can boost days 1 and 3. PROBLEM 38.12 L O N G E S T P E R I O D A T \"M O S T K D I S T I N C T Given an array of strings, best_seller, that lists the title of the most sold book for each day, and a number k ≥ 1, ! nd the maximum consecutive days with at most kdistinctbest-selling books. ▶Example: projected_sales = [\"book1\", \"book1\", \"book2\", \"book1\", \"book3\", \"book1\"], k = 2 Output: 4. The subarray [\"book1\", \"book1\", \"book2\", \"book1\"] contains only 2 distinct titles. Constraints:best_seller has a length of at most 10 6 , and each book title in best_seller has a length of at most 100. PROBLEM SET SOLUTIONS SOLUTION 38.9 A D C A M P A I G N B O O S T This problem introduces a new dimension: we need to make choices that \"modify\" the window that we are sliding over. This seems complicated at ! rst since there could be many choices. A naive solution would be to consider all possible sets of k days we could pick, but that would be very ine# cient. 8 The key for this type of problem is usually to use the REFRAME THE PROBLEM booster. We want to ! n d a w a y t o reframe it in a way that eliminates the choice aspect. For our problem, instead of choosingk days to turn from bad to good, we can look for the longest window with at mostk bad days because we can pick those bad days and turn them into good days. With this reframing, the question becomes just like Problem 38.8, which we solved previously, but with a generic limit of k bad days instead of 3. # When a problem asks you to choose k elements to change (or % ip, remove, etc.), the problem can often be reframed in terms of ! nding a window with at most k elements that need to be changed. 8 If k is a constant, the number of subsets of size k, denoted (n choose k), is O(n k ). The worst case is when k is n/2, as (n choose n/2) = O(2 n /√n). Once k gets larger than n/2, the number of possibilities starts decreasing. For instance, there are only n subsets of size n-1. 522 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALO G OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co SOLUTION 38.10 AD CAMPAIGN WITH SMALL BOOSTS We can REFRAME THE PROBLEM as: \"!nd the longest window with at most k values between 5 and 9 and 0 values less than 5.\" Then, it becomes a standard maximum window problem. SOLUTION 38.11 BOOSTING DAYS MULTIPLE TIMES First, we never want to boost a day beyond 10 projected sales, since we only care about the day being 'good.' The 'cost' of turning a day with x sales into a good day is max(10-x, 0). Thus, we can REFRAME THE PROBLEM as: \"Find the longest window where the sum of max(10-x, 0) over each element x in the window is at most k.\" Then, it becomes a standard maximum window problem. 1 def max_consecutive_with_k_boosts(projected_sales, k): 2 l, r = 0, 0 3 used_boosts = 0 4 cur_max = 0 5 while r < len(projected_sales): 6 can_grow = used_boosts + max(10 - projected_sales[r], 0) <= k 7 if can_grow: 8 used_boosts += max(10 - projected_sales[r], 0) 9 r += 1 10 cur_max = max(cur_max, r - l) 11 elif l == r: 12 r += 1 13 l += 1 14 else: 15 used_boosts -= max(10 - projected_sales[l], 0) 16 l += 1 17 return cur_max SOLUTION 38.12 LONGEST PERIOD AT\"MOST K DISTINCT We need to keep track of the number of distinct books in the window. Again, we can use a frequency map from book titles in the window to their number of occurrences. When we shrink the window, if a count goes down to 0, we remove the corresponding key from the map. This way, the size of the map re%ects the number of distinct elements in the window, and the window is valid if the map's size is at most k. 1 def max_at_most_k_distinct(best_seller, k): 2 l, r = 0, 0 3 window_counts = {} 4 cur_max = 0 5 while r < len(best_seller): 6 can_grow = best_seller[r] in window_counts or len(window_counts) + 1 <= k 7 if can_grow: 8 if not best_seller[r] in window_counts: 9 window_counts[best_seller[r]] = 0 10 window_counts[best_seller[r]] += 1 11 r += 1 12 cur_max = max(cur_max, r - l) 13 else: 14 window_counts[best_seller[l]] -= 1 15 if window_counts[best_seller[l]] == 0: 16 del window_counts[best_seller[l]] 17 l += 1 18 return cur_max CHAPTER 38 ▸ SLIDING WINDOWS 523 LIMITATIONS OF MAXIMUM WINDOWS All the problems we solved with a maximum window (as well as a resetting window) have this property: Growing an invalid window never makes it valid. We call this the maximum window property, and it is critical—without it, the maximum window recipe may not work. The intuition is that, without",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 19",
      "content": "it, we may have to grow through invalid solutions in order to get to the optimal one, making it hard to know when to grow or shrink. For example, consider a simpli! ed version of Problem 43.7: Longest Subarray With Sum K (pg 618): Given an array of integers, which may be negative, return if any subarray adds up to 0. This problem looks like a maximum window problem because it asks for the longest subarray satisfying a constraint, but we can't follow the typical maximum window policy of \"grow when you can, shrink when you must.\" For instance, if the input starts with [1, 4, -2, -2, 5, ...] and we (somehow) grow the window up to [1, 4, -2, -2], should we shrink it in order to ! nd a valid window of length 3, or keep growing because there may be a longer solution with the initial 1, like [1, 4, -2, -2, 5, -6]? It is impossible to say. For problems without the maximum window property, it is better to ditch the sliding window approach entirely and think of di\" erent approaches. A linear-time algorithm may also be less realistic (although it is possible for this particular problem using pre! x sums, pg 618). #Sliding windows often don't work with negative values. 9 Finally, there are also problems that have the maximum window property, meaning that the maximum window recipe gives the optimal answer, but it is just really hard to implement e# ciently. Here is an example of a classic problem: PROBLEM 38.13 L O N G E S T R E P E A T E D S U B S T R I N G Given a string, s, return the longest substring that appears more than once in s (overlapping is allowed) or the empty string if there is none. ▶Example: s = \"murmur\" Output: \"mur\" ▶Example: s = \"murmurmur\" Output: \"murmur\" ▶Example: s = \"aaaa\" Output: \"aaa\" SOLUTION 38.13 L O N G E S T R E P E A T E D S U B S T R I N G This can be seen as a maximum window problem because we are looking for the longest window with some property. Further, it has the maximum window property: if a substring is not repeated, it won't suddenly become repeated if we make it longer. The challenge for this problem is assessing whether a substring is valid or not is not easy because it depends on what is outsidethe window instead of what is inside of it. For problems like this, where the maximum window recipe works but is hard to implement e# ciently, we recommend trying something other than sliding windows. 9 Kadane's algorithm (Solution 38.6: Max Subarray Sum (pg 518) for the maximum subarray sum problem is an excep- tion. 524 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co For this particular problem, we can try the guess-and-check technique we learned in the Binary Search chapter (pg 338). That is, we can try to binary search over the length of the optimal window. This approach starts by asking: \"If I somehow knew the length of the optimal window, would that make the problem easier?\" The answer is often yes because then we can use the ! xed-length window recipe, which is the most straightforward one. In this case, the ! xed-length window version of the problem is \"For a given k, is there a substring of length k that appears more than once?\" If we can solve this e# ciently, we can then binary search for the transition point in the range of values of k where the answer goes from \"yes\" to \"no\". The ! xed-length window version can be solved in O(n) time using a rolling hash (bctci.co/set-and-map-implementations, Rolling Hash Algorithm section), leading to O(n log n) total time. # When a problem has the maximum window property, but you cannot ! nd an e# cient way to check if the window is valid or evaluate the window, consider using the guess-and-check technique. For an 'extra' factor of O(log n) in the runtime, it turns the problem into a potentially easier ! xed-length window problem. MINIMUM WINDOWS Minimum window problems are the opposite of maximum window problems. We try to ! nd a window as short as possible, but the constraint restricts how small valid windows can be. We'll use 'minimum windows', which grow when they must and shrink when they can. Recall the fourth opening bookstore problem: PROBLEM 38.14 SHORTEST PERIOD WITH OVER 20 SALES Given an array, sales, return the length of the shortest period of time with over 20 sales, or -1 if there isn't any. ▶Example: sales = [5, 10, 15, 5, 10] Output: 2. The subarray [10, 15] has over 20 sales. ▶Example: sales = [5, 10, 4, 5, 10] Output: 4. [5, 10, 4, 5] and [10, 4, 5, 10] have over 20 sales. ▶Example: sales = [5, 5, 5, 5] Output: -1. There is no subarray with more than 20 sales. SOLUTION 38.14 SHORTEST PERIOD WITH OVER 20 SALES This is a minimum window problem because we are trying to ! nd a window as short as possible. For minimum window problems, the empty window is invalid (in this problem, because it has fewer than 20 sales). We need to grow it until it becomes valid, similar to how we did for ! xed-length window problems. We can follow this strategy for when to grow and shrink the window: 1. If the window has 20 sales or fewer: grow it. 2. Otherwise, shrink it to look for a shorter one with over 20 sales. CHAPTER 38 ▸ SLIDING WINDOWS 525 1 def shortest_over_20_sales(sales): 2 l, r = 0, 0 3 window_sum = 0 4 cur_min = math.inf 5 while True: 6 must_grow = window_sum <= 20 7 if must_grow: 8 if r == len(sales): 9 break",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 20",
      "content": "10 window_sum += sales[r] 11 r += 1 12 else: 13 cur_min = min(cur_min, r - l) 14 window_sum -= sales[l] 15 l += 1 16 if cur_min == math.inf: 17 return -1 18 return cur_min Figure 5. Illustration of the sliding window of short- est_over_20_sales(). Unlike the other recipes, we initialize the result (cur_min) to in! nity because we update it by taking the minimum. At the end, we need to check if it is still in! nity, which means that we didn't ! nd any valid windows. It is a common mistake to forget this ! nal check! In the main loop, we start each iteration by declaring a variable must_grow (instead of can_grow for maxi- mum windows) which indicates if the currentwindow is invalid. If we must grow, there is one edge case to consider: if r == len(sales), we ran out of elements to grow, so we break out of the loop. We have this edge case for minimum windows but not maximum windows because the while-loop condition is di\" erent: we don't stop as soon as r gets to the end because it might still be possible to make the window smaller and get a better answer. If must_grow is false, then we have a valid window, so we update the current minimum ! r s tand then shrink the window to see if we can make it even smaller. We can put these ideas together in a general recipe for minimum window problems. 526 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co RECIPE 4. MINIMUM WINDOW RECIPE. minimum_window(arr): initialize: - l and r to 0 (empty window) - data structures to track window info - cur_best to infi nity while true if the window must grow to become valid if the window cannot grow (r == len(arr)) break grow the window (update data structures and increase r) else update cur_best if needed shrink the window (update data structures and increase l) return cur_best Recall that maximum windows only work for problems that have what we call the maximum window property? For the minimum window recipe to work, we need the opposite property: Shrinking an invalid window never makes it valid. We call this the minimum window property. It means that if the current window is invalid, we de! nitely need to grow it. SUCCESSFULLY SOLVES MINIMUM SLIDING WINDOW PROBLEM INTERVIEW REPLAY View Online:bctci.co/sliding-windows-replay-2 @ 4:15 - 43:23 The Question: Find the smallest substring in s containing all characters of t (including duplicates). What You'll See:The candidate successfully applied a minimum sliding window solution. Who:Interviewer: Sta\" Software Engineer at Meta Candidate: 1 year exp. Outcome:The candidate got the job at Amazon! MINIMUM WINDOWS PROBLEM SET Try these problems with AI Interviewer: bctci.co/sliding-windows-problem-set-4 PROBLEM 38.15 S H O R T E S T W I T H A L L L E T T E R S Given a string, s1, and a shorter but non-empty string, s2, return the length of the shortest substring of s1 that has every letter in s2 (as many times as they appear in s2). If there is no such substring, return -1. ▶Example: s1 = \"helloworld\", s2 = \"well\" Output: 5. The substring \"ellow\" in s1 has all the letters in s2. ▶Example: s1 = \"helloworld\", s2 = \"weelll\" Output: -1. s1 does not have 2 e's. PROBLEM 38.16 S M A L L E S T R A N G E W I T H K E L E M E N T S Given an array of integers, arr, and an integer k with 1 ≤ k ≤ len(arr), return a pair of values, [low, high], with low ≤ high, representing the smallest range such that there are at least k elements in arr with values at least low and at most high. If there are multiple valid answers, return any of them. CHAPTER 38 ▸ SLIDING WINDOWS 527 ▶Example: arr = [1, 2, 5, 7, 8], k = 3 Output: [5, 8]. The range has 3 elements in arr (5, 7, and 8) and it is smaller than other ranges with 3 elements, such as [1, 5]. ▶Example: arr = [5, 5, 2, 2, 8, 8], k = 3 Output: [2, 5]. The range has 4 elements in arr (5, 5, 2, and 2) and there is no smaller range with at least 3 elements. [5, 8] is also a valid answer. ▶Example: arr = [0], k = 1 Output: [0, 0]. PROBLEM 38.17 S T R O N G S T A R T A N D E N D I N G We have an array, projected_sales, with the number of book sales we expect each day of the fall season. We would like to start and close the season strong. We want to have as many consecutive good days as possible starting from day 0 and as many consecutive good days as possible ending on the last day (a good day is a day with at least 10 sales). We can pick k days to boost with advertising, which we expect to boost the sales on those speci! c days by at least 20. What's the maximum number of combined initial good days and ! nal good days we can have? ▶Example: projected_sales = [10, 0, 0, 0, 10, 0, 0, 10], k = 2 Output: 5. We should boost days 5 and 6 so that the projected sales after boosting are [10, 0, 0, 0, 10, 20, 20, 10]. This way, we have 1 initial and 4 final good days. ▶Example: arr = [0, 10, 0, 10], k = 1 Output: 3. We can boost either day 0 or day 2. PROBLEM SET SOLUTIONS SOLUTION 38.15 S H O R T E S T W I T H A L L L E T T E R S This is a minimum window problem since we have to minimize",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 21",
      "content": "the window length. A window is valid if the count for each letter is at least as big as the count in s2. The key information we need to maintain about the window is a frequency map counting how many times each letter from s2 is missing. We can also keep a separate count of the number of distinct letters that are missing. When this counter is at 0, the window is valid. 1 def shortest_with_all_letters(s1, s2): 2 l, r = 0, 0 3 missing = {} 4 for c in s2: 5 if not c in missing: 6 missing[c] = 0 7 missing[c] += 1 8 distinct_missing = len(missing) 9 cur_min = math.inf 10 while True: 11 must_grow = distinct_missing > 0 12 if must_grow: 13 if r == len(s1): 14 break 15 if s1[r] in missing: 16 missing[s1[r]] -= 1 528 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALO G OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co 17 if missing[s1[r]] == 0: 18 distinct_missing -= 1 19 r += 1 20 else: 21 cur_min = min(cur_min, r - l) 22 if s1[l] in missing: 23 missing[s1[l]] += 1 24 if missing[s1[l]] == 1: 25 distinct_missing += 1 26 l += 1 27 return cur_min if cur_min != math.inf else -1 SOLUTION 38.16 SMALLEST RANGE WITH K ELEMENTS This is an interesting problem because we are not looking for a subarray of the input but rather a window on the values in the array. Nonetheless, we can still use a minimum window to !nd this range. First, we sort the input since we do not care about the original order, and it will help us !nd values in arr that are close together. After sorting, the problem can be REFRAMED as follows: Find the window containing at least k elements, minimizing the di\"erence between its maximum and minimum. Now that we have a constraint and an objective for the window, this is a standard minimum window problem. Thanks to sorting, the minimum and maximum in the window are easy to calculate as they are the !rst and last elements. Sorting is the runtime bottleneck in this solution, so it takes O(n log n) time instead of O(n) as usual. 1 def smallest_range_with_k_elements(arr, k): 2 arr.sort() 3 l, r = 0, 0 4 best_low, best_high = 0, math.inf 5 while True: 6 must_grow = (r - l) < k 7 if must_grow: 8 if r == len(arr): 9 break 10 r += 1 11 else: 12 if arr[r - 1] - arr[l] < best_high - best_low: 13 best_low, best_high = arr[l], arr[r - 1] 14 l += 1 15 return [best_low, best_high] SOLUTION 38.17 STRONG START AND ENDING It is not obvious at all how a problem about maximizing pre!x and su#x lengths is related to minimum windows, but we will show a clever trick to REFRAME THE PROBLEM into a minimum window problem. What is between a pre!x and a su#x? A window! Finding a pre!x and a su#x is the twin problem of !nding the subarray between them. The next question is: \"If we look for a subarray instead of for a pre!x and a su#x, what property should the subarray have?\" Let's say projected_sales has B bad days in total. We know we can %ip k of them into good days, so we will end up with B - k bad days (if B - k is 0 or negative, we can convert all bad days into good days, so CHAPTER 38 ▸ SLIDING WINDOWS 529 the answer is the length of the input array). If we can ! nd the smallestwindow with B - k bad days, then we can % ip every bad day outside the window and maximize the pre! x and su# x without bad days. With this reframing, the problem becomes a standard minimum window problem. EXTRA CREDIT: COUNTING PROBLEMS By this point, we have seen many sliding window problems in which the constraint that the window must satisfy is of the form \"at most/at least/exactly k of something.\" In this section, we talk about how to count the number of subarrays under a constraint like that, including the ! nal three opening bookstore problems. AT -M O S T -K CO U N T I N G PROBLEM 38.18 C O U N T S U B A R R A Y S W I T H A T M O S T K B A D D A Y S Given an array, sales, count the number of subarrays with at most k bad days (days with fewer than 10 sales). ▶Example: sales = [0, 20, 5], k = 1 Output: 5. [20] has 0 bad days, and [0], [0, 20], [20, 5], and [5] have 1 bad day each. SOLUTION 38.18 C O U N T S U B A R R A Y S W I T H A T M O S T K B A D D A Y S We can leverage an interesting property about the maximum window recipe: if a problem has the maximum window property (pg 523), whenever we grow the window by adding an element arr[r - 1], the new window is the longest valid window that ends at arr[r - 1]. This means that the valid subarrays ending at arr[r - 1] are those starting at arr[l], arr[l + 1], and so on, up to arr[r - 1] itself. Thus, there are r - l valid subarrays ending arr[r - 1]. As we saw in the Problem-Solving Boosters chapter, we can often leverage properties into algorithmic ideas. In this case, we can follow the maximum window recipe—as if we were trying to ! nd the longest window with at most k bad days—and whenever we grow the window by adding an element arr[r - 1], we add r - l to a running count of valid subarrays. Here is a full solution based on",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 22",
      "content": "this idea: 530 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co 1 def count_at_most_k_bad_days(sales, k): 2 l, r = 0, 0 3 window_bad_days = 0 4 count = 0 5 while r < len(sales): 1 can_grow = sales[r] >= 10 or 2 window_bad_days < k 3 if can_grow: 4 if sales[r] < 10: 5 window_bad_days += 1 6 r += 1 7 count += r - l 8 else: 9 if sales[l] < 10: 10 window_bad_days -= 1 11 l += 1 12 return count Figure 6. Sliding window for count_at_most_k_bad_days(sales, 2). Every time we grow the window, we show all the valid subarrays that we add to the running count (16 in total). Note that the code is exactly the same as max_at_most_3_bad_days() from the previous section except for computing count instead of cur_max (and k instead of 3). # If a problem has the maximum window property, the maximum window recipe also works for At-Most-K counting problems. Whenever we add an element to the window, we add to the running count all the valid subarrays ending at that element. Fortunately, At-Most-K counting problems are a bit of a 'freebie' because we can reuse the maximum window recipe. In the next section, we'll see a trick that makes Exactly-K counting problems equally easy! As mentioned, this only works if the problem has the maximum window property. For instance, if we allow negative numbers in the array in this problem, we cannot use the algorithm anymore. EXACTLY-K COUNTING PROBLEM 38.19 C O U N T S U B A R R A Y S W I T H E X A C T L Y K B A D D A Y S Given an array, sales, count the number of subarrays with exactlyk bad days (days with fewer than 10 sales). ▶Example: sales = [0, 20, 5], k = 1 Output: 4. The subarrays [0], [0, 20], [20, 5], and [5] have 1 bad day each. SOLUTION 38.19 C O U N T S U B A R R A Y S W I T H E X A C T L Y K B A D D A Y S This time, we will start with the solution and then break it down: 1 def count_exactly_k_bad_days(sales, k): 2 if k == 0: 3 return count_at_most_k_bad_days(sales, 0) 4 return count_at_most_k_bad_days(sales, k) - CHAPTER 38 ▸ SLIDING WINDOWS 531 5 count_at_most_k_bad_days(sales, k-1) We re-used the At-Most-K counting function count_at_most_k_bad_days() from the previous section. For k == 0, 'at most 0' and 'exactly 0' are the same. For k == 1, the code works because the number of subarrays with exactly 1 bad day is equal to the number of subarrays with at most 1 bad day (meaning 0 or 1 bad days) minus the number of subarrays with at most 0 bad days. This applies to any higher k as well! For example, Figure 7 shows an example sales array and all 16 subarrays with at most 2 bad days. Of those, 10 have at most 1 bad day, meaning there are 16 - 10 = 6 subarrays with exactly 2 bad days. By the same logic, there are 10 - 2 = 8 subarrays with exactly 1 bad day. Figure 7. The set of all subarrays with at most 2 bad days, which contains the set of subarrays with at most 1 bad day, which contains the set of subarrays with no bad days. Since we need to make two calls to the At-Most-K solution, the runtime is twice as long, which is still O(n). Exactly-K counting problems can also be solved in linear time with pre! x sums: see Problem 38.6: Max Subarray Sum (pg 517). The pre! x-sums approach works even if the array has negative numbers. AT -L E A S T -K CO U N T I N G PROBLEM 38.20 COUNT SUBARRAYS WITH AT LEAST K BAD DAYS Given an array, sales, count the number of subarrays with at leastk bad days (days with fewer than 10 sales). ▶Example: sales = [0, 20, 5], k = 1 Output: 5. The subarrays [0], [0, 20], [20, 5], and [5] have 1 bad day each, and the subarray [0, 20, 5] has 2. SOLUTION 38.20 C O U N T S U B A R R A Y S W I T H A T L E A S T K B A D D A Y S We will see how to reuse the At-Most-K counting solution once again. First, we need to know the total number of subarrays. What's the total number of subarrays? An array of length n has (n+1)*n/2 non-empty subarrays. Each subarray is de! ned by a pair of indices, [start, end]. There are n 2 [i, j] pairs where i and j are valid indices (0 ≤ i, j < n). Of those, there are n pairs where i == j, which de! ne single-element subarrays. Of the remaining n 2 - n pairs, half have i < j and half have i > j. 532 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co The latter half does not identify valid subarrays, so we don't count them. In total, we have n + (n 2 - n)/2 = (n+1)*n/2 subarrays. The subarrays with at least k bad days are those with k bad days, those with k+1 bad days, those with k+2 bad days, and so on. Therefore, to count the subarrays with at least k bad days, we can start with the count of allsubarrays (of which there are n*(n+1)/2) and subtract the number of subarrays with at most k-1 bad days. Something we already saw how to compute! 1 def count_at_least_k_bad_days(sales, k): 2 n = len(sales) 3 total_subarrays = n*(n+1)//2 4 if k == 0: 5 return total_subarrays 6 return total_subarrays -",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 23",
      "content": "count_at_most_k_bad_days(sales, k-1) #If the At-Most-K version of a counting problem has the maximum window property, it can be reused to solve the At-Least-K version. REUSABLE IDEA: TRANSFORM EXACTLY-K/AT-LEAST-K COUNTING TO AT-MOST-K COUNTING If the At-Most-K version of a counting problem has the maximum window property, it can be reused to solve the Exactly-K and At-Least-K versions. 1. 'Exactly k' is equivalent to 'at most k' minus 'at most k - 1'. 2. 'At Least k' is equivalent to 'total count' (n*(n+1)/2) minus 'at most k - 1'. The At-Most-K version can be solved by tweaking the maximum window template, as in Solution 18. There are counting problems that do not ! t into any of the At-Most-K / Exactly-K / At-Least-K categories. We should tackle such problems on a case-by-case basis. Here is an example: PROBLEM 38.21 C O U N T S U B A R R A Y S W I T H G O O D S T A R T A N D E N D I N G Given an array, sales, return the number of subarrays that start and end on a good day (a day with at least 10 sales). SOLUTION 38.21 C O U N T S U B A R R A Y S W I T H G O O D S T A R T A N D E N D I N G For this particular problem, the key property to leverage is that each distinct pair of good days in sales contributes 1 to the ! nal count. Thus, the answer is g*(g + 1)/2, where g is the number of good days in sales. COUNTING PROBLEM SET Try these problems with AI Interviewer: bctci.co/sliding-windows-problem-set-5 PROBLEM 38.22 C O U N T S U B A R R A Y S W I T H D R O P S Given an array of integers, arr, and an integer k, count how many subarrays have (1) at most k drops, (2) exactly k drops, and (3) at least k drops. A drop is a sequence of two consecutive numbers where the ! rst is larger than the second. ▶Example: arr = [1, 2, 3], k = 1 Output: (1) 6. The array has no drops, so every subarray has 0 drops. CHAPTER 38 ▸ SLIDING WINDOWS 533 (2) 0. The array has no drops. (3) 0. The array has no drops. ▶Example: arr = [3, 2, 1], k = 1 Output: (1) 5. [3, 2] and [2, 1] have 1 drop and [3], [2], and [1] have 0 drops. (2) 2. [3, 2] and [2, 1] have exactly 1 drop. (3) 3. [3, 2] and [2, 1] have 1 drop and [3, 2, 1] has 2 drops. PROBLEM 38.23 C O U N T S U B A R R A Y S W I T H B A D D A Y S I N R A N G E Given the array sales and two numbers k1 and k2 with 0 ≤ k1 ≤ k2, count the number of subarrays with at leastk1 bad days and at mostk2 bad days (days with fewer than 10 sales). ▶Example: sales = [0, 20, 5], k1 = 2, k2 = 2 Output: 1. [0, 20, 5] has 2 bad days. ▶Example: sales = [0, 20, 5], k1 = 1, k2 = 2 Output: 5. [0, 20, 5] has 2 bad days, and [0], [0, 20], [20, 5], and [5] have 1 bad day. PROBLEM 38.24 C O U N T S U B A R R A Y S W I T H A L L R E M A I N D E R S Given an array of positive integers, arr, return the number of subarrays that have at least one of each of the following: •a multiple of 3, •a number with remainder 1 when divided by 3, and •a number with remainder 2 when divided by 3. ▶Example: arr = [9, 8, 7] Output: 1. [9, 8, 7] counts because 9 % 3 is 0, 7 % 3 is 1, and 8 % 3 is 2. ▶Example: arr = [1, 2, 3, 4, 5] Output: 6. The subarrays are [1, 2, 3], [2, 3, 4], [3, 4, 5], [1, 2, 3, 4], [2, 3, 4, 5], and [1, 2, 3, 4, 5]. ▶Example: arr = [1, 3, 4, 6, 7, 9] Output: 0. There are no numbers with remainder 2 when divided by 3. PROBLEM 38.25 C O U N T G O O D S U B A R R A Y S W I T H A T L E A S T K S A L E S Given an array, sales, and a positive integer k, return the number of subarrays with no bad days and at least k total sales (bad days are days with fewer than 10 sales). ▶Example: arr = [15, 20, 5, 30, 25], k = 50 Output: 1. The subarrays with no bad days are [15], [15, 20], [20], [30], [30, 25], and [25]. Of those, only [30, 25] has at least 50 sales. PROBLEM SET SOLUTIONS SOLUTION 38.22 C O U N T S U B A R R A Y S W I T H D R O P S This is a direct application of the techniques we discussed. 1 def count_at_most_k_drops(arr, k): 2 l, r = 0, 0 534 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALO G OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co 3 window_drops = 0 4 count = 0 5 while r < len(arr): 6 can_grow = r == 0 or arr[r] >= arr[r-1] or window_drops < k 7 if can_grow: 8 if r > 0 and arr[r] < arr[r-1]: 9 window_drops += 1 10 r += 1 11 count += r - l 12 else: 13 if arr[l] > arr[l+1]: 14 window_drops -= 1 15 l += 1 16 return",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 24",
      "content": "count 17 18 def count_exactly_k_drops(arr, k): 19 if k == 0: 20 return count_at_most_k_drops(arr, 0) 21 return count_at_most_k_drops(arr, k) - count_at_most_k_drops(arr, k-1) 22 23 def count_at_least_k_drops(arr, k): 24 n = len(arr) 25 total_count = n*(n+1)//2 26 if k == 0: 27 return total_count 28 return total_count - count_at_most_k_drops(arr, k-1) SOLUTION 38.23 COUNT SUBARRAYS WITH BAD DAYS IN RANGE The same idea for Exactly-K counting problems also applies to a range: 10 1 def count_bad_days_range(sales, k1, k2): 2 if k1 == 0: 3 return count_at_most_k_bad_days(sales, k2) 4 return count_at_most_k_bad_days(sales, k2) - 5 count_at_most_k_bad_days(sales, k1-1) SOLUTION 38.24 COUNT SUBARRAYS WITH ALL REMAINDERS Every number has a remainder of 0, 1, or 2 when divided by 3. The count of subarrays that have a number from each group is equal to the total number of subarrays (n*(n+1)/2) minus the subarrays that have numbers from at most 2 of those groups. For the latter, we use the at-most-k counting technique. 1 def count_all_3_groups(arr): 2 n = len(arr) 3 total_count = n * (n + 1) // 2 4 return total_count - count_at_most_2_groups(arr) 5 6 def count_at_most_2_groups(arr): 7 l, r = 0, 0 8 window_counts = {} 9 count = 0 10 while r < len(arr): 11 can_grow = arr[r] % 3 in window_counts or len(window_counts) < 2 10 This is the same logic behind how we use pre!x sums to answer range sum queries (pg 612). CHAPTER 38 ▸ SLIDING WINDOWS 535 12 if can_grow: 13 if not arr[r] % 3 in window_counts: 14 window_counts[arr[r] % 3] = 0 15 window_counts[arr[r] % 3] += 1 16 r += 1 17 count += r - l 18 else: 19 window_counts[arr[l] % 3] -= 1 20 if window_counts[arr[l] % 3] == 0: 21 del window_counts[arr[l] % 3] 22 l += 1 23 return count We could have made the code a bit more e#cient by replacing the dictionary with an array of length 3, since the set of keys that we are using is {0, 1, 2}. SOLUTION 38.25 COUNT GOOD SUBARRAYS WITH AT LEAST K SALES We can use the 'break down the problem' booster: 1. First, we can use a resetting window to !nd all maximal subarrays without any bad days. Then, we can focus on each subarray we found without worrying about bad days. 2. For each subarray, sub, from Step 1, we need to count the number of subarrays of sub with at least k total sales. To do this, we can use the trick for At-Least-K counting: counting the total number of subar- rays in sub and subtracting the number of subarrays in sub with at most k-1 total sales. KEY TAKEAWAYS If you want to try using a sliding window, your !rst goal should be identifying the constraint and the objective. Based on those, you can choose the most appropriate window type: see the !xed-length window recipe (pg 513), the resetting window recipe (pg 516), the maximum window recipe (pg 520), and the minimum window recipe (pg 526). Once you choose a recipe, the next question is: ▶What information do I need about the window to check its validity and evaluation e#ciently? Based on the answer, we will pick which window data structures to maintain as we slide the window (and remember, if you can't !nd appropriate window data structures, you can always try the binary search guess- and-check technique (pg 338). Finally, we implement the sliding window. We recommend following some conventions such as those described on page 511. Here are some edge cases to keep an eye for: •Make sure to consider the case where no valid window is found, especially for minimization problems. •Make sure not to shrink an empty window or grow a window past the end of the array. Even better, update your own personal Bug List (pg 172) with the edge cases that you tend to forget about. Counting problems are less common, but we can use the trick to adapt the maximum window recipe to At-Most-K counting problems (pg 530). For Exactly-K/At-Least-K counting problems, see the reusable idea for transforming them to At-Most-K problems (pg 532). For maximization problems without the maximum window property (pg 523) or minimization problems without the minimum window property (pg 526), sliding windows may be the wrong technique! Consider other techniques commonly used on subarray problems, like two pointers, pre!x sums, and dynamic programming. 536 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co Sliding window triggers: The input type is just an array of numbers or a string, and maybe a number. The lower bound is linear. Keywords: subarray, substring, length, contiguous, consecutive, range, longest, or shortest. At this point, you should be ready to start adding sliding window problems to your practice rotation. You can ! nd the problems in this chapter and additional problems in the companion AI interviewer. ONLINE RESOURCES Online resources for this chapter include: •A chance to try each problem in this chapter in AI Interviewer •Interview replays that show speci! c mistakes people make with sliding windows problems • Full code solutions for every problem in the chapter in multiple programming languages Try online at bctci.co/sliding-windows.",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peak BCTCI - Sliding Windows & Binary Search - June 2025.pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 1",
      "content": "BEYOND CRACKING the CODING INTERVIEW Pass Tough CODING Interviews, get noticed, and Negotiate succesfully SNEAK PEEK amazon.com/dp/195570600X 0 INTERVIEW CHECKLIST BEYOND CRACKING THE CODING INTERVIEW 1 STUDY PLAN BEYOND CRACKING THE CODING INTERVIEW BOOSTERS CRACKING THE CODING INTERVIEW 189 PROGRAMMING QUESTIONS AND SOLUTIONS CRACKING THE PM CAREER THE SKILLS, FRAMEWORKS, AND PRACTICES TO BECOME A GREAT PRODUCT MANAGER CRACKING THE PM INTERVIEW HOW TO LAND A PRODUCT MANAGER JOB IN TECHNOLOGY CRACKING THE TECH CAREER INSIDER ADVICE ON LANDING A JOB AT GOOGLE, MICROSOFT, APPLE, OR ANY TOP TECH COMPANY BEYOND CRACKING the CODING INTERVIEW GAYLE L. MCDOWELL MIKE MROCZKA ALINE LERNER NIL MAMANO CareerCup, LLC Palo Alto, CA BEYOND CRACKING THE CODING INTERVIEW Copyright © 2025 by CareerCup. All rights reserved. No part of this book may be reproduced in any form by any electronic or me- chanical means, including information storage and retrieval systems, without permission in writing from the author or publisher, except by a reviewer who may quote brief passages in a review. Published by CareerCup, LLC, Palo Alto, CA. Compiled Jun 3, 2025. For more information, or to enquire about bulk or university copies, contact support@careercup.com. Please report bugs or issues at beyondctci.com. 978-1955706001 (ISBN 13) To my favorite coders, Davis and Tobin— Gayle To my dog, my wife, and our readers (and not necessarily in that order)— Mike To my two wonderful kids (or if I have more, then whichever two are the most wonderful)— Aline Als meus pares— Nil WHAT’S INSIDE I. __init__() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 README . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 Hello World. Hello Reader. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 Crash & Learn: Our Failed Interviews . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 II. Ugly Truths & Hidden Realities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 Ch 0. Why Job Searches Suck. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 Ch 1. A Brief History of Technical Interviews . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 Ch 2. What’s Broken About Coding Interviews. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 Ch 3. What Recruiters Won’t Tell You . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 Ch 4. What Interviewers Won’t Tell You. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 Ch 5. Mindset and the Numbers Game. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 III. Job Searches, Start to Finish . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 Ch 6. Resumes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 Ch 7. Getting in the Door . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 Ch 8. Mechanics of the Interview Process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 Ch 9. Managing Your Job Search. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78 IV. Offers & Negotiation. . . . . . . .",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 2",
      "content": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96 Ch 10. Components of the Offer. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98 Ch 11. The What & Why of Negotiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .108 Ch 12. Pre-Offer Negotiation Mistakes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .111 Ch 13. Getting the Offer: Exactly What to Say . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .120 Ch 14. How to Negotiate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .123 V. Behavioral Interviews . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136 Ch 15. When and How They Matter. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .138 Ch 16. Content: What to Say . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .141 Ch 17. Communication: How to Say It . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .154 VI. Principles of Coding Interviews. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166 Technical README. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .168 Ch 18. How to Practice. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .170 Ch 19. How You Are Evaluated. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .180 Ch 20. Anatomy of a Coding Interview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .190 Ch 21. Big O Analysis. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .206 Ch 22. Boundary Thinking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .231 Ch 23. Trigger Thinking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .243 Ch 24. Problem-Solving Boosters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .249 VII. Catalog of Technical Topics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280 Ch 25. Dynamic Arrays. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .282 Ch 26. String Manipulation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .288 Ch 27. Two",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 3",
      "content": "Pointers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .294 Ch 28. Grids & Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .312 Ch 29. Binary Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .326 Ch 30. Sets & Maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .345 Ch 31. Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .361 Ch 32. Stacks & Queues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .379 Ch 33. Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .392 Ch 34. Linked Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .412 Ch 35. Trees. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .429 Ch 36. Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .456 Ch 37. Heaps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .489 Ch 38. Sliding Windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .509 Ch 39. Backtracking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .537 Ch 40. Dynamic Programming. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .564 Ch 41. Greedy Algorithms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .584 Ch 42. Topological Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .598 Ch 43. Prefix Sums . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .610 VIII. exit() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 624 Acknowledgments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .626 Post-Mortem Example Log . . . . . . . . . . . .",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 4",
      "content": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .629 Reference Materials . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .630 My Notes & Reminders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .639 You can access all of our online materials and bonus chapters here: Talk with the authors, get help if you're stuck, and geek out with us on Discord. bctci.cobctci.co/discord Get $50 Off on Mock Interviews Practice anonymously on interviewing.io with FAANG interviewers: bctci.co/discount-X3A4 __INIT__() Interview Replay: Recordings of actual mock interviews. Snippet: Material that you can copy/paste online, including email templates and code recipes. Resource: Bonus chapters, worksheets, and other material. Problems, Solutions, and AI Interviewer: You can try every problem in the book with the AI Interviewer. Solutions are online in four languages (Python, Java, JavaScript, and C++). Watch for these speech-bubble icons, which mean there is online content. PAR T I __INIT__ !\" I README This is a big book, and yes, it needs an instruction manual. We ask (beg?) you to read this. We'll keep it short and to the point. We also know lots of books have online materials, and they're often junk. We promise this isn't the case with ours. Before we do that, we’d like to address the relationship between this book and interviewing.io. Yo u ' l l s e e a l o t o f r e fe r e n c e s t o i t . T h i s b o o k i s n o t from interviewing.io, but we do partner with them for access to lots of data, interview replays, and an AI Interviewer. Because of this relationship, we know that sometimes mentioning interviewing.io might sound promotional. We’ve tried to avoid that as much as we could. We hope—trust—that you'll forgive this in exchange for access to lots of data, resources, and tools (and the discount code). The book is roughly split into two segments: the # rst segment (Parts I–V) is the soft squishy stu$ (backed up by a lot of qualitative and quantitative data). The second segment (Parts VI and onwards) is the technical content, which has its own README (pg 168). Please read it before diving into those parts. ONLINE MATERIALS AND DISCUSSION You can access all of our online materials and bonus chapters here: Talk with the authors, get help if you're stuck, and geek out with us on Discord. bctci.co bctci.co/discord __INIT__!\" ▸ README 11 ICONS Whenever you see an icon wrapped in a speech bubble, it means that there’s online content that goes with it, like so: Problems, Solutions, and AI Interviewer: Each problem in the book has a Python solution (without any fancy Python-speci# c tricks). We also provide Java, JavaScript, and C++ solutions online. We encourage you to try each problem with AI Interviewer and to only look at the solution if you get stuck. Interview Replay: These are recordings of actual mock interviews from interviewing.io’s collection, conducted by engineers from FAANG and other top companies. We use them to showcase real-life examples of successes and mistakes. Snippet: These are snippets that you can copy and paste. Sometimes they’re code. Sometimes they’re text that you can steal verbatim (e.g., emails to recruiters). Resource or document: These are bonus chapters, downloadable problem sets, or worksheets (e.g., an equity calculator, a calculator to help you # gure out the order in which to approach companies). BUGS, QUESTIONS, AND CONTACT Website:beyondctci.com Bugs:bctci.co/bugs Errata: bctci.co/errata Email: beyond@gayle.com Get $50 o! anonymous mock interviews on interviewing.io While this book gives you the tools and strategies to tackle tough tech- nical questions, it is essential to put these tools into practice. With the purchase of this book, you get $50 o$ on interviewing.io mock inter- views. There, you can practice anonymously with FAANG interviewers. Even if you don’t use interviewing.io, # nd a way to practice with another person; grinding problems by yourself quickly reaches the point of diminishing returns. bctci.co/discount-X3A4 I HELLO WORLD. HELLO READER. The only thing worse than technical interviews is not having technical interviews. Oscar Wilde(ish) Always stay gracious, best revenge is your paper. Beyoncé Knowles-Carter Cracking the Coding Interview (CtCI) has been the industry leader in teaching engineers how to get into top tech companies for over a decade. It's referenced in almost every major interview prep source, includ- ing books, podcasts, blogs, and online courses, as the source of truth on how to get into the major tech companies in our industry. And—although this was never the intention—it's even been used as a classroom textbook and a question bank for companies to draw on. So, why write another interview prep book? And why now? While CtCI remains an excellent foundation for interview preparation, the landscape of technical interviews has evolved dramatically since its publication. Online interview resources have changed how candidates practice, and the questions asked in interviews have grown both in di% culty and variety. And, as more candidates are preparing for interviews than ever before, the bar for passing has risen accordingly. But it’s not just the questions that have changed. The process of landing a job at top tech companies has grown even more competitive. The technical interview format has sparked increasing debate, and AI is reshaping how people apply for jobs, how companies screen candidates, and even how interviews are conducted. Amidst these shifts,",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 5",
      "content": "we felt it was time to take a step back and rethink what a modern interview prep book should look like—one that complements existing resources and patches the gaps between what candidates are doing and what they need to be doing. We realized that a new edition wouldn’t cut it. It would have to be a brand new book, and this book would have to: • Focus on understanding, not memorization. We aim to teach you the computer science fundamentals and the interview skills needed to excel, regardless of your educational background. By building a deep understanding of these concepts, you’ll be prepared to tackle problems you’ve never seen before— something memorization alone can’t achieve. __INIT__!\" ▸ HELLO WORLD. HELLO READER. 13 •Cover important non-technical topics. CtCI only brie&y touched on what some call the “squishy” stu$—resumes, negotiation, and managing your job search. This book devotes ~150 pages to these topics because they are now critical to success. We’ll guide you through technical recruiting with practi- cal advice, down to exactly what to say in the situations you’re likely to encounter. • Ground our advice in data. This book draws on a decade of insights from real-world inter views, includ- ing a corpus of over 100,000 interviews conducted on interviewing.io by senior engineers from FAANG+ companies. You’ll get a data-driven perspective on what technical interviews look like at top companies today. Now, to address the angry elephant in the room: technical interviews are &awed, right? Absolutely. We don' t just acknowledge that; we're going to dive into a candid discussion of everything wrong with technical interviews, and what you can do about it. Despite what some have suggested, CtCI didn't invent this format—nor is BCtCI going to end it. As far as we can tell, technical interviewing isn't going anywhere. But we hope to make the process a little less daunting and a lot more transparent—by leveling the playing #eld and giving you access to what was previously insider knowledge. We hope that you’re able to put away your hatred of the format, read this book with an open mind, put in the work, and get your revenge... by nailing your interviews, fearlessly negotiating, and landing the high-paying, challenging, awesome job that you deserve. Before we get on with the real stu$, we have one request for you. Do not read this book—at least not in the traditional sense of left-to-right, top-to-bottom, page-to-page. Rather, we implore you to do this book. Use it. Interact with it. This is so important that we have a literal README on how to use it. We hope you enjoy reading doing this book, inasmuch as one can enjoy a book about interviews and job searches. We really enjoyed writing building it. I CRASH & LEARN: OUR FAILED INTERVIEWS Everyone loves a success story, but failure is often the best teacher. We will share here our most humbling interview experiences—times we bombed, blanked, or were simply unprepared. These stories aren’t just about the mistakes we made; they’re about the lessons we learned and how those failures shaped us. Our hope is that by sharing these moments, you’ll see that even \"experts\" have stumbled, arguably in career- altering ways. More importantly, you’ll learn that just as these interview failures don't re& ect on our skills as engineers, nor do yours. GAYLE Entering my fourth year of a # ve-year undergrad/master's program, I was fortunate to have three Microsoft internships behind me. Determined to try something new for my # nal internship, I sent countless cold emails and resumes into the void of online applications. Somehow, Google picked mine. I was thrilled. From the bits I'd heard about technical interviewing, questions could be anything from implementing an ArrayList to the heavy-ball brainteaser 1 . Imagine my surprise when, instead, I got a math question: \"What is 2^20?\" My answer was the always-brilliant \"Um, I don't know? Can I use a calculator?\" All I could think about was what a stupid question this was and how I de# nitely didn't know the answer. And why should I? Who cares? Just look it up if you need to know it. (Sound familiar?) What I didn't realize then was that—probably—my interviewer wasn't expecting me to just know this. Most likely, she wanted me to start from what I did know, perhaps that 2 10 is about 1000. From there, if I knew my exponent rules, I could solve it: 2 20 = 2 10 * 2 10 is about 1000 * 1000... so approximately 1 million. In her mind, it was a problem-solving question—albeit one that relied on a lot of math 2 . But in my mind, I didn't know the answer, and I was supposed to, and <PANIC>. All I needed to do was focus on what I could solve rather than what I knew. Still a stupid question though 3 . 1 Given a balance (i.e., a scale that only tells you which side is heavier) and eight balls—all the same weight other than one which is slightly heavier—# nd the heavy ball in as few measurements as possible. 2 In general, asking math-heavy questions is a no-no for interviews. However, I'll let her o$ the hook here, a little. I was a computer science major with a math minor. If I didn't know exponent rules, something had gone very wrong. 3 Why is this a bad question? Put aside the \"it's not relevant\" part. The relevant factor is: is it predictive? Approached the right way, this could be a problem solving question. However, it didn't feel like that to me—and perception matters. Additionally, even if I had approached it as a problem-solving question, there is very little \"meat\" to the question; what distinguishes between good and bad other than understanding how to break up the exponents? __INIT__!\" ▸ CRASH & LEARN: OUR FAILED INTERVIEWS 15 MIKE In my #rst year of college as a CS student, I was the only student to get an opportunity to",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 6",
      "content": "interview at Google for their internship position 4 —and I was ecstatic about it. The problem? I hadn't taken my data structures and algorithms class yet. My GPA took a colossal hit that semester as I spent way too much time cutting class to watch YouTube lectures on sorting algorithms and NP-hard problems in an attempt to prepare for my interview. The interview day came, and I had two back-to-back meetings with di$erent Googlers. I described the optimal solution for my #rst interview, which I nervously coded in C++ with a hashmap—but then the second inter- viewer stumped me with a binary tree question 5 . After much fumbling, the interviewer walked me through a viable way to solve the problem, which I coded, but I knew I had bombed my chance at a Google internship. A few years later, I passed Google’s full-time interviews twice—declining the #rst o$er for a remote role at Salesforce and accepting the second for a permanent position at Google. ALINE After graduating from MIT, I spent three years cooking professionally. While my culinary detour could #ll a book, I wasn’t good enough at it to make it a career. Out of money, I returned to coding. Coming o$ three years of &ipping pans, chopping food, and drinking nightly, I found myself back in a well-lit o%ce, standing at a whiteboard, asked to reverse a linked list. Not only had I forgotten what these interviews were like (I was expecting to talk about my past projects), but I completely blanked on what a linked list was, much less how to reverse one. And this particular interview was with Sasha Aickin, Red#n’s CTO, back when they were like #ve people. It’s one of the things I still kick myself for, every now and again. To his credit, Sasha patiently explained how linked lists work, and, through a series of hints, got me to change pointer directions. I clumsily erased and redrew arrowheads, but I don’t think I wrote much code. It was too little, too late. I never forgot how shitty failing that interview felt. I also never forgot how gracious Sasha was, in the face of my failure, and how he patiently walked me through the problem by asking leading questions. Both of those experiences helped me come up with the idea for interviewing.io: a place where people could fail privately, without the stigma, and learn from those failures, by pairing with kind, empathetic people who care. NIL Nil insists that he’s never failed an interview. We would like to clarify that it ’s because he’s only done one—and passed. True to his name, Nil has exactly zero failure stories to share. Classic edge case. 4 For the curious, I sent over 100+ cold email messages to former alumni until someone was willing to refer me. Even back then, I was using the techniques we show you in this book. 5 I was asked to compute the maximum sum of any path in the tree, which did not necessarily start at the root but could include it. For a variant of that problem, see Problem 35.1: Aligned Chain (pg 436). UGLY TRUTHS & HIDDEN REALITIES Interview Replay: Recordings of actual mock interviews. Snippet: Material that you can copy/paste online, including email templates and code recipes. Resource: Bonus chapters, worksheets, and other material. Problems, Solutions, and AI Interviewer: You can try every problem in the book with the AI Interviewer. Solutions are online in four languages (Python, Java, JavaScript, and C++). Watch for these speech-bubble icons, which mean there is online content. PAR T II UGLY TRUTHS & HIDDEN REALITIES I CHAPTER 0 WHY JOB SEARCHES SUCK Job searches suck—especially for engineers, who are, by and large, rational, well-intentioned people who expect the world to function according to some set of predictable rules. Why do job searches suck so much? •Job searches are not deterministic, and neither are interview outcomes. In job searches, e$ ort doesn’t always correlate with results. For technical interviews speci# cally, there’s little predictability in how the same person will perform from interview to interview (pg 26). • No feedback loop. When you apply online and don't get a response, you can't tell if you weren’t a # t or if no one even saw your application. Your insecurities can convince you that not only did a human look, but they quickly sized you up, saw right through you, and lasered in on every single & aw to conclude (correctly, in your mind) that you’re un# t for the job. When you interview, whether you pass or get rejected, you often don’t know why, which makes it di% cult to know how to prepare the next time. • The content of your resume is often eclipsed by the brands in it. If you don’t have brand-name companies or schools, it’s much harder to get noticed. Recruiters are notoriously bad at making value judgments based on resumes 1 . Despite these shortcomings, resumes are still the gold standard, and that means candidates from non-traditional backgrounds enter the game with a signi# cant disadvantage. • To g e t i n t h e d o o r, y o u v e r y l i k e l y h a v e t o k n o w s o m e o n e . Surprisingly, this is even true for candidates who look good on paper; recruiters often ignore online applications because the signal-to-noise ratio is so poor. But it’s especially true if you don’t look good on paper. • Technical interviews are notoriously ! awed and not representative of the actual engineering work you do every day. This one is especially rough, and it bears out in our data. Senior engineers often do worse than juniors in their # rst few interviews because junior engineers have more recently completed an algorithms class or have done extensive interview prep. Senior engineers have been in the trenches, often focusing on",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 7",
      "content": "building applications; there are very few engineering roles where you’re doing the types of academic problems that you get in interviews day in and day out. These are just a few of the challenges, but the strategies in this book will help you navigate them and achieve success—however you de# ne it. Given all these & aws, you might ask: How did we get here, where our technical interviews feel so divorced from the work and so unpredictable in their outcomes? For that, let’s take a brief look at the history of technical interviewing. 1 See https://www.reddit.com/r/recruitinghell/comments/qhg5jo/this_resume_got_me_an_interview/ CHAPTER 1 I CHAPTER 1 I CHAPTER 1 A BRIEF HISTORY OF TECHNICAL INTERVIEWS A de# nitive work on the history of technical interviewing was surprisingly hard to # nd, but we were able to piece together a narrative by scouring books like How Would You Move Mount Fuji, Programming Interviews Exposed, and the bounty of the internets. The story goes something like this. Technical interviewing has its roots as far back as the 1950s, at Shockley Semiconductor Laboratories in Mountain View, California. William Shockley’s 1 interviewing methodology came out of the need to keep up with the innovative, rapidly moving, Cold War-fueled tech sector, something that traditional hiring approaches taken from established, skills-based assembly line industries simply couldn’t handle. And so, Shockley relied on questions that could gauge analytical ability, intellect, and potential quickly. One canonical question 2 in this category has to do with coins: You have eight identical-looking coins, except one is lighter than the rest. Figure out which one it is with just two weighings on a pan balance. The techniques that Shockley developed were adopted by Microsoft during the 1990s, as the success of the desktop computer, and later, the # rst dot-com boom spurred an explosion in tech hiring. Like Shockley, Microsoft also needed to quickly and scalably assess high volumes of candidates for potential. As soft- ware engineering became increasingly complex, it was no longer possible to have a few centralized expert programmers manage the design and then delegate away the minutiae. Even rank-and-# le developers needed to be able to produce under a variety of rapidly evolving conditions, where just mastery of speci# c skills wasn’t enough. The puzzle format, in particular, was easy to standardize because individual hiring managers didn’t have to come up with their own interview questions, and a company could quickly build up its own interchangeable question repository. Over time, most companies did away with puzzle questions 3 for engineers, and moved to algorithmic questions: these questions seemed more relevant but still assessed problem-solving skills. At many top companies, such as Google, this need for interchangeable parts ultimately carried over to the interview process as well—rather than having individual teams run their own processes and pipelines, 1 We are acutely aware that this is the same William Shockley who became the poster boy for eugenics. He was a pretty awful person. 2 A # rst attempt—if you're an engineer—is to do something akin to binary search: split the coins into two sets of four coins each. Then, take the lighter set, and divide it into two sets of two coins each. Then, split in half again. But that will be three weighings, not two. To reduce a weighing, consider that the balance will also tell us if the sets are equal. We can divide the coins into three sets. 3 https://www.nytimes.com/2013/06/20/business/in-head-hunting-big-data-may-not-be-such-a-big-deal.html 20 BEYOND CRACKING THE CODING INTERVIEW ▸ UGLY TRUTHS & HIDDEN REALITIES View online materials for Beyond Cracking the Coding Interview at bctci.co companies standardized it. This way, in addition to questions, you could e$ectively plug and play the inter- viewers themselves—any interviewer within your org could be quickly trained up and assigned to speak with any candidate, independent of the prospective team. At the same time, companies didn’t always create incentives for engineers to work hard at being good interviewers, and as you’ll see later in this book, we believe that much of the &ak that algorithmic interviews get is due to the interviewers conducting them (and, often, lack of training or proper incentives). So where does this leave us? Technical interviews are, at best, a proxy for the day-to-day tasks that a software engineer actually does, and not all interviewers are good. But, regardless, do technical interviews work? Well, that's complicated and depends a lot on your de#nition of \"work.\" For whom, the candidate or the company? For what type of company? Compared to what? We would argue that interviewing as a whole is &awed, and it's really a matter of picking your poison. However, even the most ardent defenders 4 of these sorts of technical interviews agree that false nega- tives—great engineers who get rejected—are common. FAANGs and other companies who adopt these processes tolerate a high false negative rate, under the rationale that it's better to reject a good candidate than to hire a bad one. The process is optimized to reduce false positives. For you, the candidate, that kind of sucks. But it is what it is, and that's what this book is here for: to help you avoid being one of those false negatives. 4 Let's call out the elephant in the room. Some might assume that, as authors of a coding interview book, we must adamantly believe in the value of coding interviews. Not so. Not only has our intimate look at coding interviews exposed many &aws, but the entire existence of coding interview prep means that coding interviews are, at least, a little bit broken. CHAPTER 2 I CHAPTER 2 I CHAPTER 2 WHAT'S BROKEN ABOUT CODING INTERVIEWS This chapter dives into the systemic & aws of technical interviews, from the prevalence of bad questions and bad interviewers to the randomness of interview outcomes and the growing interview-industrial complex. But it’s not all doom and gloom. Once you understand the challenges and accept that the system is & awed, you’ll be able to operate within it and win (and do so with",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 8",
      "content": "con# dence and integrity). IT’S NOT THE WORK YOU DO EVERY DAY One of the most persistent critiques of technical interviews is that they feel disconnected from the work you do every day. If interviews were like the work you did every day, we’d expect that senior engineers would outperform juniors in interviews. As it turns out, that’s not the case: frustratingly, the more experienced you are, the worse you perform. We actually have data for this. If you look at performance in their # rst mock interview on interviewing.io, junior engineers signi# cantly outperform senior ones. In the upcoming graph, you can see the average score that candidates got in their # rst mock interview on interviewing.io, broken out by seniority. Not only do junior engineers signi# cantly outperform experienced engineers, 1 but experienced engineers perform the worst out of all the groups. 1 At this point, you’re probably thinking that the bar is di$ erent for more junior engineers. At some companies, it is. At some, it is not. Our interviewers know the experience level of their candidates and adjust their bar accordingly when giving feedback. With that in mind, new grads likely do the best in interviews because they’re fresh o$ a data structures and algorithms course. 22 BEYOND CRACKING THE CODING INTERVIEW ▸ UGLY TRUTHS & HIDDEN REALITIES View online materials for Beyond Cracking the Coding Interview at bctci.co This e$ ect gets less pronounced as people practice more; once everyone has done a bunch of mock inter- views, they all roughly converge, as you can see in the next graph. But, out of the gate, recency with the material gives you a signi# cant advantage. CHAPTER 2 ▸ WHAT'S BROKEN ABOUT CODING INTERVIEWS 23 You might also notice in this graph that it takes about # ve mock interviews, on average, to start passing these interviews (pg 40). BAD QUESTIONS !AND MEMORIZATION OVER UNDERSTANDING\" There is so much vitriol targeted toward technical interview questions that rehashing it in detail probably isn’t worth the paper this book is printed on. If you’ve ever read any thread on Hacker News about interviewing, you know the main points: 2 •Questions are too academic and obscure. You’ve probably never had to invert a binary tree at work. • Bad questions. Many questions require a serendipitous “Ah-ha!” moment to solve, which even the best engineers may not be able to guarantee. Some questions aren’t well-formulated or require too much domain-speci# c knowledge. • To o m u c h m e m o r i z a t i o n . With how interviewing works today, it’s rational to memorize a bunch of common questions, which turns the exercise into a test of memorization rather than understanding or ability. We do not disagree with any of these points, and yes, these & aws are real. We’ve already talked about how we got here and why technical interviews are the way they are. It’s easier for huge companies to scale if they can reduce interviewer training time and not have to come up with original questions/use LeetCode questions verbatim. Sadly, smaller companies often “cargo cult” large company practices, not realizing that they hire good candidates despite their processes and not because of them. It's also true that memorizing helps a lot. On interviewing.io, after every interview, both interviewers and interviewees # ll out a feedback form. One of the things we ask interviewees is whether they’ve seen this question before. We don’t share whether they have or not with interviewers, so there’s no reason to lie. Here is a graph of the pass rate for algorithmic interviews as a function of whether candidates have seen the question before. As you can see, familiarity with a question before gives you a serious edge in interviews: you are 33% more likely to pass. We expect that this disparity would be even higher if we had rephrased our feedback form to say something like, “Have you practiced this question before?” 2 We’ve also surveyed our users, as part of some research we did to # gure out what makes someone a good interviewer: https://interviewing.io/blog/best-technical-interviews-common 24 BEYOND CRACKING THE CODING INTERVIEW ▸ UGLY TRUTHS & HIDDEN REALITIES View online materials for Beyond Cracking the Coding Interview at bctci.co The fact that memorizing questions gives you an edge is ironic, given that the whole purpose of modern technical interviewing is to evaluate one’s ability to think like an engineer, rather than come to the table with a bunch of speci#c skills. It’s also one of the things that makes it harder to stomach practicing for interviews. It’s a tough pill to swallow to know that, ultimately, you’re competing with memorizers. In this book, we’ll arm you with the kind of foundational understanding that will make memorization less important (but will be just as e$ective at improving your performance). BAD INTERVIEWERS WHO DON’T WANT TO BE THERE Good interviewers can get good signal from a bad question. Bad interviewers cannot even get good signal from a good question. For a good interviewer, the question is just a tool to guide the discus- sion into interesting areas. For bad interviewers, the question is an absolute to which they must hear the exact answer they have in mind. Jos Visser, Member of Technical Sta$ at OpenAI, and formerly of Google, Facebook, and Amazon Ye s , b a d q u e s t i o n s a r e b a d. However, bad interviewers are, in our minds, the biggest problem with technical interviews. A terrible question, in the hands of a skilled, engaged interviewer, can yield meaningful signal. A great question asked by an unskilled, disconnected interviewer will always be bad. We talked about how large companies adopted modern technical interviewing in part because of the “interchangeable parts” approach to provisioning interviewers. However, human beings are not gears or sprockets—each comes with their own unique hangups and proclivities. It’s naive to think that you",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 9",
      "content": "can swap one interviewer for another and achieve the same result. In our experience hiring professional mock interviewers, we saw very quickly that whether some- one likes to conduct interviews is bimodal: either they love it or they hate it, with not much in between. The people who like interviewing tend to enjoy teaching. They tend to have higher-than-average empathy, they remember a time when they were on the other side of the table, and they want to make that experi- ence less painful for their candidates. They also tend to approach interviews with a certain curiosity. They are curious about novel ways to solve the problem, about new rabbit holes their candidates will inevitably go down, and about the candidates themselves. The people who hate interviewing treat it as a disruption—a necessary evil between shipping features. They do the bare minimum, and it shows. Over the years, we've listened to a lot of interviews. You can immediately identify when an interviewer is checked out. You’ll hear them typing. You’ll hear them go silent for a while. They’ll often need to ask the candidate to repeat themselves. You certainly won’t hear them collaborating with their candidate or gently guiding them away from a perilous rabbit hole. Most of us have been on the receiving end of an interviewer’s callous indi$erence and know what it feels like. CHAPTER 2 ▸ WHAT'S BROKEN ABOUT CODING INTERVIEWS 25 Bad interviewers are common across companies, even top-tier ones, 3 and there is an added complication: companies don’t usually track who their best interviewers are, 4 nor do they reward them. Sadly, it’s often the opposite—bad interviewers get rewarded because they focus on writing code instead of conducting interviews. In other words, curmudgeons who alienate their recruiting team (and get scheduled less often as a result) get rewarded. Engineers who end up being less present in their interviews because their mind is elsewhere, still churning through the code they were writing when they got interrupted, get rewarded. In the rare instances where we’ve seen companies really care about interviewer quality, it’s because an eng leader there has taken it upon themselves, as a labor of love. Why does it matter if an interviewer is bad, outside of it being a poor experience for candidates? In this graph, you can see the average interview pass rates on interviewing.io, broken out by interviewer quality. 5 Interviewer quality matters because the purpose of a technical interview is not to see if you can get the perfect answer. You’re not just solving a coding problem online by yourself. As such: •Bad interviewers miss out on critical two-way interactions with the candidate. You’re meant to discuss approaches with your interviewer and ask questions, all in the service of determining if you’re the kind of person who can pick up new skills in a rapidly changing landscape and work well with other smart people. When your interviewer is not holding up their end, it’s much harder for you to hold up yours, and it turns into a contest of who’s memorized the most questions. •Bad interviewers are incentivized to be unnecessarily harsh. Better to say no to a good candidate than risk hiring a bad one, right? 3 Some people assume that top-tier companies invest more into interviewer training than others. In our experience, that isn’t true. We won’t throw speci# c companies under the bus in this book, but if you read interviewing.io’s guide to FAANG interview processes (https://interviewing.io/guides/hiring-process), you’ll see how much or how little some of them invest in interviewer training. 4 https://interviewing.io/blog/best-technical-interviews-common 5 We determine quality as a function of how highly rated interviewers are by their candidates with respect to question quality, hint quality, and how excited the candidate would be to work with that person. It’s a “candidate experience” score, in other words. Candidates submit these ratings before they know how they did. This graph is also not about interviewer leniency—for what it’s worth, the best-calibrated interviewers tend to be the best-rated, and those who are too lenient tend to be among the worst. 26 BEYOND CRACKING THE CODING INTERVIEW ▸ UGLY TRUTHS & HIDDEN REALITIES View online materials for Beyond Cracking the Coding Interview at bctci.co •Bad interviewers will judge too much on super# cial grounds, which is especially unfair to candidates who come from a non-traditional background or lack some little bit of institutional knowledge. For all their perceived objectivity (and certainly they’re more objective than ones where you talk about your experience), coding interviews are a complex interaction between two humans. When one of the parties isn’t truly present, the candidate pipeline su$ ers, and you end up with fewer candidates to choose from and, ultimately, worse hires. N O N 'D E T E R M I N I S T I C O U T C O M E S Anyone who’s done multiple technical interviews has probably felt in their gut that outcomes are somewhat arbitrary. So much depends on serendipity and, well, clicking! Did you click with your interviewer? Did some- thing click in your head at the right time when trying to solve the problem? If you’ve felt like this, you’re not alone, and we have the data to prove it. On interviewing.io, after every interview, you get a technical score from your interviewer, on a scale of 1 to 4. The same candidate can do multiple interviews, each of which is with a di$ erent interviewer and/or di$ erent company, and this opens the door for some pretty interesting and somewhat controlled comparative analysis. With that in mind, we looked at how the same person performed from interview to interview. We analyzed inter viewing.io’s data to understand how individuals per formed across multiple inter- views (for this analysis, we included people who did between 3 and 20 interviews). Each circle or diamond represents people with that speci# c average score and standard deviation across their interviews. The y-axis is the standard deviation of performance; a higher",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 10",
      "content": "standard deviation re& ects more volatility. Some surprising takeaways from this analysis: CHAPTER 2 ▸ WHAT'S BROKEN ABOUT CODING INTERVIEWS 27 •Only 25% of people are consistent from interview to interview (standard dev of <= 0.5). Everyone else is all over the place. •64% of the people who scored at least one 4 have also scored at least one 1 or one 2. So, what did the most highly volatile performers have in common? The answer appears to be, well, nothing. About half were working at top companies. About 60% had attended top schools. And years of experience didn’t have much to do with it either—a plurality of interviewees had between 2 and 6 years of experience, with the rest all over the board (varying between 1 and 20 years). When we corrected for interviewer strictness, the e$ect didn’t go away either. Why is this bad? This inconsistency means randomness signi#cantly impacts your career. In a way, interviews serve the same function as standardized tests—giving an organization a way to make a value judgment about someone’s ability relatively quickly and without a lot of priors, in a way that’s consistent and repeatable. For all their &aws and biases, standardized testing providers have made a lot of e$ort to make sure that their results are repeatable because their results often determine the social mobility and livelihoods of millions of students every year. Even though they have a similar impact on outcomes for millions of engineers, tech companies have not done the same for their interviews. BUCKETED SCORING Imagine that we wanted to evaluate whether students in a given classroom were tall or short. But rather than measuring people’s heights, we #rst bucketed them into “very short,” “short,” “tall,” or “very tall.” Inevitably, there will be many cases where two students are nearly the same height, but a few millimeters make the di$erence between “short” and “tall.” Any bucketed scoring will lose precision and create arbitrariness, but it’s even worse when we have few buckets and split the middle zone—which is common. That is, if, rather than providing a bucket for “average height” (where most people might fall), we split these people into “short” and “tall” depending on whether they cross some threshold. Now, we don’t just have some arbitrary scores; we have a lot of them. This is e$ectively what’s happening in many technical interviews. In fact, it can be a triple-whammy. • Bucketed Scoring: Interviewers don’t score you as a 2.6; almost always, interviewers are forced into bucketed scores, such as 1, 2, 3, or 4 (or its qualitative equivalent: strong no-hire, no-hire, hire, strong hire). •Risk-Averse Scoring: Interviewers are encouraged to be risk-averse: “better to reject a good one than hire a bad one,” they say. That 2.6 interview is more likely to be reported as a 2 than a 3. •Splitting the Middle: In many cases, interviewers are bucketed into just four buckets— with no place for \"average\" or \"maybe.\" The average score is often around a 2.5 to 2.7, so a four-point scale splits the middle candidates. This means that a lot of people will get rounded up or down into “hire” or “no-hire.” A candidate who gets {3.2, 3.3, 2.7, 3.4} on a four-point scale may be hired, but the candidate who gets {3/ hire, 3/hire, 2/no-hire, 3/hire} (a possible risk-averse rounding equivalent) may not be. We've e$ectively lost the information that the \"no-hire\" was actually really close to a \"hire.\" No matter how you bucket, bucketed scoring e$ectively forces interviewers to translate very typical scores into something more extreme and loses #delity in the process. No wonder we have so much variability in interviews! 28 BEYOND CRACKING THE CODING INTERVIEW ▸ UGLY TRUTHS & HIDDEN REALITIES View online materials for Beyond Cracking the Coding Interview at bctci.co INTERVIEW PREP BEGETS INTERVIEW PREP Te c h n i c a l i n t e r v i e w i n g h a s g i ve n r i s e t o a b o o m i n g p re p a r a t i o n i n d u s t r y. This is somewhat ironic, as it defeats the purpose of this form of interviewing; the goal was to understand the candidate's aptitude, independent of what they currently know. The reality is that—as we've shown—interview prep works. We might not like it, but people do better with preparation. That's why interview prep is a multi-billion dollar industry, including everything from books and courses to asynchronous coding challenges and mock interviews. This also means that you are being compared to candidates who are prepping for interviews (and, in many cases, simply memorizing a ton of questions), which means that the expectations for you have gone up too. What do you do about this? You, of course, prepare for interviews too. It's an unfortunate cycle; interview prep begets interview prep. 6 But for the record, memorizing problems without also working on understanding goes against our preparation philosophy, and it’s honestly not that e$ective. All that said, it’s time to change our lens and talk about how to work the system. Technical interviews are here to stay, and if you want a job at a top-tier tech company, you have to jump through this hoop. 6 Would it be better if we did the impossible and magically got rid of all interview prep? Probably not. Before today's industry, there were still some books and resources—but it relied more on word of mouth and \"inside\" sources (friends telling you what to expect). This favored people with connections. The bar might have been lower, but the playing #eld was more unfair. CHAPTER 3 I CHAPTER 3 I CHAPTER 3 WHAT RECRUITERS WON'T TELL YOU Show me the incentives, and I’ll show you the outcome. Charlie Munger It is di% cult to get a man to understand something when his salary depends on his not understanding it. Upton Sinclair Even though",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 11",
      "content": "recruiters try to position themselves as your advocate, remember this: recruiters are not your friend, and they don’t work for you. I (Aline) used to be a recruiter. I ran my own third-party agency, and I also worked in-house before starting interviewing.io. That means I’ve had to struggle with the tangled incentive structure 1 that comes with being a recruiter. There’s always tension; recruiters are, by and large, good human beings who genuinely want to help their candidates, but they also have an employer they’re beholden to, as well as a comp/bonus structure that rewards certain behaviors, some of which run counter to candidates’ best interests. There’s some distinction between in-house recruiters and third-party recruiters (recruiters who work for an agency that does placement, rather than a speci# c company that’s hiring engineers). T H I R D 'P A R T Y R E C R U I T E R S Working with third-party recruiters (also known as agency recruiters) is, at best, mixed. The most important thing to realize about them is that you are not the customer. The employer is. As such, even when they're paid a commission based on your salary, their incentives are, at best, sometimes aligned with yours. Ultimately, a recruiter's incentive is to get the deal done, not to get you the best possible deal. Here’s why. A recruiter, depending on market conditions, gets anywhere from 8% - 25% of a candidate’s base salary when they make a placement. However, that cut is going to the recruiting agency as a whole rather than to the individual recruiter; you will almost always end up working with large agencies rather than a single person. Let's say that you get an o$ er. You talk to your third-party recruiter and tell them that you would like more money. The recruiter may go to the hiring manager and try to advocate for you, but they're not going to 1 https://blog.alinelerner.com/if-youre-an-engineer-who-wants-to-start-a-recruiting-business-read-this-# rst/ W h a t R e c r u i t e r s W o n ’ t T e l l Y o u 30 BEYOND CRACKING THE CODING INTERVIEW ▸ UGLY TRUTHS & HIDDEN REALITIES View online materials for Beyond Cracking the Coding Interview at bctci.co push very hard because the incremental di$erence in their cut is going to be pretty small 2 , and to them the thing that matters is making the hire. After all, they're evaluated on the number of hires they make, #rst and foremost, independent of compensation. Third-party recruiters are incentivized to get the deal done, not to risk the deal by negotiating hard for you. This means: •If they have multiple clients potentially matching the same company, and they know you're less likely to take their o$er, they'll #ght for the other candidates more than you. • They may expose information to the company that reveals whether you'll demand a high salary. Remem- ber: they're paid by the company, not you. If the company likes them, that's good for them. • They may encourage you to take a lower salary. Sure, they get a slightly higher commission if you negotiate a higher salary, but they get no commission until the deal is done. •They may encourage an employer to lowball you, if they think you’ll take it. 3 So, when you work with third-party recruiters: •Do not tell them anything about your job search. •Do not share your compensation history/expectations. • Always deal directly with the companies they introduce you to, once you establish a point of contact there. • Assume that anything you tell your recruiter is going to get back to every company you’re working with. IN'HOUSE RECRUITERS Some in-house recruiters get a bonus for hires, but this bonus is rarely tied to your compensation. In fact, in some cases, they may get a bigger bonus if they’re able to negotiate you down. At big companies, in particular, in-house recruiters follow a playbook, and are evaluated accordingly. They’re trained to make o$ers within speci#c bands, and they’re trained to mobilize such that they don’t lose candi- dates to other big companies; if you wave a Facebook countero$er in front of Google, they will act. If you tell them you’re interviewing at a startup, they will not, because they know that startups don’t pay as much. Because of this playbook 4 —and because they are working for the employer—their incentives do not align with yours. They’re incentivized, #rst and foremost, to follow the rules their head of department sets for them. This is true for how they evaluate candidates, who they let through, and how they read resumes. And it’s de#nitely true for how they negotiate. Generally speaking, recruiters want to help, and many are rooting for their candidates. But they’re also operating inside a box, and that box isn’t set up to put your interests #rst. 2 Understanding that, let's do the math anyway. Let’s say your o$er has a base salary of $150k. Say that your recruiter goes to bat for you and tries to get you up to $165k. Before, the agency would have gotten paid $15k. Now the agency gets paid $16.5k. That incremental $1.5k isn’t worth risking a deal over (even a few thousand dollars would not justify jeopardizing the deal). On top of that, the individual recruiter is only going to maybe get a few hundred dollars total from that increase. 3 Why would a recruiter recommend that an employer not pay you more? It seems counterintuitive, but remember that the employer is their customer, not you. A savvy business person will often take a short-term hit in the service of building an enduring relationship with their customer. Telling an employer that they don’t need to pay a candidate more (even though paying the candidate more would get the recruiter marginally more money) builds trust and makes it more likely that that employer will keep coming back to them for future searches. Employers often work with several agencies at",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 12",
      "content": "once and cycle between agencies, so anything agencies can do to retain employers is a win. 4 For more insight, watch this video on how recruiting leaders think about looking at resumes, debrie#ng interviews, and extending o$ers. https://www.youtube.com/watch?v=dHSufqvgUqY CHAPTER 3 ▸ WHAT RECRUITERS WON'T TELL YOU 31 A NOTE ABOUT IN!HOUSE RECRUITER TENURES Many recruiters at FAANG companies are contractors. The longer a contractor works, the more their role may resemble that of a full-time employee. To avoid legal risks, companies often limit contract durations to around 6 months. While this practice is most common in California due to its strict labor laws, similar limitations are applied in other states, though the typical contract length may vary. Why do recruiter tenures matter to you? • Never assume that the recruiter you're talking to now will still be there in a few months, when you're ready to interview. • Build good rapport with your recruiter. Odds are good that, even if you don't pursue their current company, you might be interested in their future company. • Don't lie about other o$ers—it’s not super likely your recruiter is checking whether you have the o$ers you say you do, but chances are, because recruiters have short tenures and work at lots of companies, your recruiter knows someone there. We’ve seen it happen. We’ll talk a lot more about how to work well with recruiters in future chapters, and now you’ll understand why we give the advice that we do. RECRUITERS WILL TRY TO CALL/TEXT. USE EMAIL INSTEAD. Recruiters are notorious for calling and texting instead of using email. Why? The generous interpretation is that recruiters generally want to move things along quickly. If they can get you to respond quickly, through a synchronous medium like phone or text, then they can likely move you through the process faster as well. There is one other, less generous interpretation—phone and text give recruiters the upper hand. Even the worst recruiters, if they have any work experience at all, quickly become seasoned negotiators. Even inexperienced recruiters have an edge because they are following a script and playbook. They’ve been told what to say in a variety of situations, and they interact with candidates multiple times a day, over years. You, on the other hand, do one job search every few years. Email lets you level the playing #eld. You can craft every word, and #gure out what to say and how much to reveal. Over email, you can play it cool, and you can take the time to get advice from friends or experts. When a recruiter calls you on the phone, they get your impromptu responses. They can see if you're excited about the money, and possibly get you to answer questions that you might not have otherwise answered (e.g., your salary expectations). The phone will keep you o$ balance. While texting allows you to think longer about your response, its casual nature lulls you into a false sense of security. Moreover, the fact that texts interrupt you from something else puts you at a disadvantage—when you get interrupted, your instinct is to quickly respond to make the interruption go away. But knee-jerk responses are rarely the right ones, and you end up giving away information you shouldn’t have. We encourage you to stick to email as much as possible. You will have to get on the phone eventually, of course, likely when they are ready to extend an o$er, but you never have to text. CHAPTER 4 I CHAPTER 4 I CHAPTER 4 II WHAT INTERVIEWERS WON'T TELL YOU Material for this chapter at bctci.co/interviewer-secrets Much of interviewing advice takes an idealistic stance: interviewers are fundamentally well-intentioned rational actors who want to run a fair process, and any & aws in the process itself are circumstantial or occur because of very rare bad actors. That’s not strictly true. As we previously discussed (pg 24), most employers don’t reward strong interview- ing skills, so interviewers have little motivation to improve. Here are some additional interviewing tropes, which may or may not be true. We’ll discuss them all and address them with data. Can you guess which ones are true? • It’s not about whether you get the right answer. Rather it’s about demonstrating your thought process. •Interviewers decide early on if you’ve passed the interview. • If you’re a great communicator and build rapport with your interviewer, you can pass the interview, even if your technical skills are wobbly. IS IT REALLY ABOUT DEMONSTRATING YOUR THOUGHT PROCESS, OR DO YOU NEED TO GET TO AN OPTIMAL SOLUTION? On interviewing.io, candidates who clearly and correctly explained their approach but failed to reach an acceptable working solution received a \"thumbs up\" only 32% of the time, compared to the platform's overall average of 51%. This means that failing to produce a working solution reduces your chances of passing the interview by 37%. 1 How Interview Replays Work and How to Use Them Interview replays come from mock interviews on interviewing.io. Replays are shared with the permission of both participants. Each replay includes the interviewer’s feedback. You can watch just the relevant snippet, but we include the entire interview. We strongly recommend pausing your reading and watching these replays. Hearing real people interview lets you learn from their mistakes—so that you aren’t doomed to repeat them. Where we know it (and where enough time has elapsed since they did mock interviews), we’ll share the candidate’s outcome. 1 To be clear, if you’ve gotten to the optimal solution and have mostly working code (maybe some small syntax errors or an o$ by one error), we believe most interviewers would still give a Hire rating. But if it’s not working, it has to be very close. W h a t Interviewers Won’t Tell You CHAPTER 4 ▸ WHAT INTERVIEWERS WON'T TELL YOU 33 NOT GETTING A WORKING SOLUTION, DESPITE DESCRIBING IT SUCCESSFULLY INTERVIEW REPLAY View Online:bctci.co/interviewers-replay-1 @ 45:50 - end The Question:Given an array of integers, are there elements a,",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 13",
      "content": "b, c such that a + b + c = 0? Find all unique triplets which give the sum of zero. What You'll See:Although the candidate explained the solution well, their code had bugs. The interviewer o$ ered some suggestions on how to improve coding speed and discussed the importance of writing compilable code. Who: Interviewer: Sta$ Software Engineer at Lyft Candidate: 4 years of experience So, why do many interviewers insist on saying that it’s about your thought process rather than the end result? That's complicated, but there are a few reasons: 1. It feels good to say. Interviewers want to believe that they're grading on something deeper and more qualitative than getting the right answers to really hard questions. 2. It is true, in a sense; interviewers prioritize your solving ability, not the answer itself. If you just spit out the right answer because you already know it, this won't be impressive to a good interviewer and could even lead you to getting eliminated for \"cheating.\" 3. It used to be even more true. As standards have increased, there has been a bit less forgiveness for a candidate who made good progress but didn't get to the best solution. The reality is that interviewers are looking for strong problem solvers, and—for a good interviewer—it is about the process, not the solution. However, it's often hard to convince them that you're a strong problem solver if you can't reach the optimal solution. Either way, this trope stresses the importance of practice—the more you practice, the faster you’ll get, and the more likely you get to an acceptable solution. FIRST IMPRESSIONS AREN'T PREDICTIVE. EARLY PERFORMANCE IS. You might have heard that the interviewers decide in the # rst few minutes whether you've passed the interview; we've certainly heard that plenty. But even supposing that's true, is it true for technical interviews? Given that technical interviews are focused on problem solving, it would be troubling if interviewers did in fact make such snap judgments before the problem solving had even happened. At interviewing.io, we looked into this claim by analyzing sentiment—interviewers can make a comment during the interview (we call these “annotations”) with an associated sentiment (positive, neutral, or negative), which the candidate will see afterwards. 34 BEYOND CRACKING THE CODING INTERVIEW ▸ UGLY TRUTHS & HIDDEN REALITIES View online materials for Beyond Cracking the Coding Interview at bctci.co Those who believe that the # rst impression is make-or-break might be reassured by this: the interviewer's # rst annotation is aligned with the outcome just 56% of the time—barely better than a coin & ip. The # rst annotation occurs at an average of 13 minutes into the interview, which means the chit-chat is done and we've kicked o$ the problem solving portion. We can't speak for what happens in non-eng interviews, but at least for eng interviews: no, interviewers do not decide in the # rst few minutes. Whew! However, your interviewer’s impression of you by the 18-minute mark is predictive. Figure 1. This graph is based on 7,883 interviews with annotations from the interviewing.io corpus. You can see when the # rst annotation that was predictive of the interview outcome happened. Most happen in the # rst 18 minutes. Moreover, the average sentiment gets worse over time for both successful and unsuccessful candidates, with the sharpest decline occurring in the # rst 15 minutes. CHAPTER 4 ▸ WHAT INTERVIEWERS WON'T TELL YOU 35 Figure 2. This graph is based on 7,883 inter views with annotations from the inter viewing.io corpus. You could interpret these # ndings cynically—all candidates do badly, and interviewers get stuck in precon- ceived (or at least early) notions. But as authors who have—collectively—spoken with thousands of candi- dates and interviewers, we see this in a more positive light. Good interviewers 2 adjust their guidance based on your performance: when you do well, they give you less assistance; when you struggle, they give you more. It's like a live version of computer adaptive testing. This means that while you might do well in the # rst 10 minutes (mostly chit-chat and explaining the problem), good interviewers will adjust so that you struggle just enough. Perhaps seeing that struggle is why sentiment generally gets more negative over time; a good interviewer is purposefully putting you into situations that challenge you, thus creating more room for negative sentiment 3 . But that’s part of the interview process. # This means, for you, don't panic when things get more challenging. Embracethe struggle. Struggling doesn't mean that you're doing poorly; it can just mean that your interviewer is doing their job. They've given a problem of appropriate di% culty and adjusted their guidance to suit your abilities. We also believe, optimistically, that it’s a good thing early-formed opinions are predictive. At the 18 minute mark, we're about 10 minutes into the problem solving portion, by which point our interviewer has seen some of our skills. If the # rst 10 minutes of problem solving were not predictive of the next 30 minutes, that would be a further indictment of the interview process. After all, it's not like we're magically becoming better or worse problem solvers, so our performance at the beginning should typically be predictive of the rest. It's good that we see consistency. It means that our interviewers, if they’re good, are actually looking at our problem solving process, not quantitative metrics like \"number of minutes to solution\" or \"did you get it perfect right away\", nor dinging us because we have some tiny bug. # This means, again, there's no reason to panic at little mistakes; these aren't making interviewers & ip & op. Not all interviewers are good interviewers (unfortunately), but still—interviewers are generally looking at your performance as a process. 2 Fortunately, this data set is limited to interviewers who were rated well by their candidates. Our interpretations of the data do not hold for bad interviewers. As we discussed earlier (pg 24), there are many",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 14",
      "content": "bad interviewers who aren’t engaged and check out after the # rst few minutes. 3 However, this doesn't mean that you are truly doing worse. A good interviewer will also be looking at signal (pg 180), which means that they are taking into account the complexity of the problem. 36 BEYOND CRACKING THE CODING INTERVIEW ▸ UGLY TRUTHS & HIDDEN REALITIES View online materials for Beyond Cracking the Coding Interview at bctci.co COMMUNICATION SKILLS ARE NICE, BUT TECHNICAL SKILLS ARE NICER Communication in technical interviews boils down to two aspects: rapport-building at the start (about yourself, your projects, etc) and clear communication throughout the interview. RAPPORT!BUILDING AT THE START Look, this isn’t the kind of thing you usually say in an interview prep book, but the chit-chat in the #rst few minutes does not matter... much. Data shows positive communication in the #rst #ve minutes increases pass rates by 6 percentage points for underperforming candidates, compared to a 25-point boost from strong technical performance. Be enthusiastic and personable, but don’t stress this unless small talk is a challenge for you. The technical stu$ really does matter more. COMMUNICATION THROUGHOUT THE INTERVIEW Although many candidates believe in coding as soon as possible, the data shows the opposite: successful candidates actually code slightly later (about two minutes later 4 in a one-hour interview). This di$erence is small, but extra surprising given that many unsuccessful candidates will be quite delayed in coding because they lack a working approach. So why would coding later be linked to better outcomes? Communication, essentially. Candidates who explain their approach do better in interviews, but communication takes time. Thinking out loud is essential in technical interviews, but beyond a baseline, communication may not signi#- cantly impact outcomes—at least for roles below Sta$. On interviewing.io, candidates are rated on technical skills, problem-solving ability, and communication skills (all on a 1 - 4 scale), alongside a pass/fail score. Our analysis found that once a candidate scores 2 / 4 in communication, additional improvements yield diminishing returns. In contrast, boosting technical or problem-solving scores by 1 or 2 points can increase the odds of passing by 1.5X to 2.4X, emphasizing the greater importance of these skills. As roles become more senior though, communication and behavioral skills play an increasingly critical role in interview outcomes. At the Sta$ level and beyond, our anecdotal experience—supported by feedback from interviewers—shows that the evaluation criteria shift signi#cantly to emphasize these skills. All that said, we can't fully tease apart technical ability and communication skills; when a candidate can't communicate their solution, interviewers are also less likely to be impressed by their approach—and they are less able to give you hints to help you along. Where does this leave you? •Don’t worry about practicing speci#cally for the #rst 5 minutes of the interview. You can prepare for it a little, but don't stress about it. •Get used to thinking out loud. •Spend the bulk of your time getting better at solving problems. Fortunately, practicing thinking out loud doesn't come at the cost of practicing solving problems. You can quite literally do them at the same time. 4 Candidates with successful interviews #rst run code 27% of the way through the interview, whereas candidates with unsuccessful interviews #rst run code 23.9% of the way into the interview. This di$erence is small, but nonetheless statistically signi#cant. https://interviewing.io/blog/we-analyzed-thousands-of-technical-interviews-on-everything- from-language-to-code-style-here-s-what-we-found#user-content-fnref-3 CHAPTER 5 I CHAPTER 5 I CHAPTER 5 MINDSET AND THE NUMBERS GAME No matter how good an engineer you are, if you get too much in your head during interviews, you’ll fail. We’ve seen countless candidates self-sabotage because they jumped into the interview prep material before they accepted some fundamental truths about the journey. This chapter is about how to approach these interviews, and we encourage you to take it seriously. It’s not woo-woo nonsense. It’s our way of making sure you can apply your full potential for the rest of the book. With that in mind, here are the things you need to internalize and truly believe before you begin your studies. TECHNICAL INTERVIEWING IS A NUMBERS GAME Technical interviews are a numbers game, but many engineers underestimate just how much. It takes doing many interviews, and even more importantly, access to a peer group going through the same thing, to really internalize it. Here, we’ll try to short-circuit all of that and convince you that failing an interview doesn’t re& ect on your engineering skills or potential; it’s often the byproduct of a broken system. Remember the graph (pg 26) where we showed that most people’s technical interview performance is all over the place? Here it is again (Figure 1). Only 25% of people performed consistently, and about two thirds of people who got at least one 4 also got at least one 1 or 2. Due to this inconsistency, even great engineers routinely fail interviews. This is a particularly big issue in tech- nical phone screens, where interviewers must decide if someone gets to onsite based on just one data point. Many candidates go into the process assuming it’s repeatable, like a standardized test—a reasonable but & awed assumption. The truth is, unless you’ve been through the wringer, and unless you have people around you who have also been through the wringer, you’re unlikely to realize just how unpredictable and variable the process can be. For me (Aline), this became clear when I was a student at MIT. Attending a top-tier computer science program o$ ered a number of advantages, but one of the most important (and least obvious) was access to a peer group that was going through the same things. Having this group around me meant that we could all practice with each other, share our successes and failures, and have multiple shots on goal at top companies. Everyone was interviewing everywhere, and we quickly learned that bombing a Microsoft interview did not mean that you weren’t meant to be an engineer. It just meant that you needed to work some more problems, do",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 15",
      "content": "some more mock interviews, and try again at Google. 38 BEYOND CRACKING THE CODING INTERVIEW ▸ UGLY TRUTHS & HIDDEN REALITIES View online materials for Beyond Cracking the Coding Interview at bctci.co Figure 1. Standard deviation vs. mean interview performance (33,052 interviews; 7,161 interview- ees). We analyzed interviewing.io’s data to understand how individuals performed across multiple interviews (for this analysis, we included people who did between 3 and 20 interviews). Each circle or diamond represents people who had that speci# c average score and standard deviation across their interviews. One of the most critical things to internalize is that if you fail an interview, that’s all it is. It is not a well-reasoned indictment of your potential as an engineer. Keep practicing and try again. Unfortunately, dusting yourself o$ and trying again is harder for some groups than for others. PERSEVERANCE AFTER FAILURE IS HARDER FOR ENGINEERS FROM NON'TRADITIONAL BACKGROUNDS Many years ago, we noticed that on interviewing.io, women were performing signi# cantly worse in technical interviews than men. This disparity still exists today. But before you jump to conclusions, the reason is not that women are actually technically weaker. Let us explain. Figure 2. Gender di$ erences in interview passthrough rate. CHAPTER 5 ▸ MINDSET AND THE NUMBERS GAME 39 When we # rst noticed this disparity, we wondered if it was due to bias against women. So, we ran an experi- ment 1 using a real-time voice modulator that could change the pitch of the user's voice (making women sound like men, and vice versa). Contrary to what we expected, masking gender had no e! ect on interview performance. Perhaps the women were less senior? Doing di$ erent work? Nope. Neither of those factors seemed to di$ er meaningfully between groups. What was di$ erent then? Women left interviewing.io roughly seven times as often as men after they do badly in an interview. And the numbers for two bad interviews aren’t much better. 2 Figure 3. Attrition after poor interview performance. When you correct for attrition, the di$ erence between men and women goes away entirely. 3 Figure 4. Average passthrough rate by gender when correcting for people who drop out after two failures. 1 We split our users into three groups: unmodulated (the control group), modulated without pitch change (another control; we needed it because modulated voices sound somewhat processed, and the last thing we wanted was for interviewers to guess the gender of their interviewees because anyone who sounded processed and male must actually be a woman and vice versa), and modulated with pitch change. This last one was the treatment group. https:// interviewing.io/blog/voice-modulation-gender-technical-interviews 2 The di$ erences between men and women are extremely statistically signi# cant with P < 0.00001. 3 We have not studied this e$ ect in race or in socioeconomic status, but we’d expect that you’d see a disparity in persever- ance between groups, with engineers from non-traditional backgrounds being more likely to quit. 40 BEYOND CRACKING THE CODING INTERVIEW ▸ UGLY TRUTHS & HIDDEN REALITIES View online materials for Beyond Cracking the Coding Interview at bctci.co We are calling this out because we want it to change your behavior: everyone fails these interviews, regardless of background. If you're a woman, and very likely if you’re from a non- traditional background, know that failure isn't a career end. Accept the system's &aws and learn to navigate them. This means learning as much as you can, practicing as much as you can, then learning some more, and then practicing some more. End-to-end, the practice journey may take anywhere from two to six months, depending on where you start and your previous exposure to algorithms and data structures. But, no matter who you are, you will need to practice, and you will fail some interviews. This is an axiom of our book. It might take two failures before things turn around. It might take #fteen. But we implore you to exert yourself and keep going. If you approach technical interviewing from a place of curiosity, we promise that you’ll get through it and #nd success at the end... which brings us to our #nal point. PRACTICE IS REALLY IMPORTANT CRITICAL It's all well and good to talk about who is doing well in mock interviews, but at the end of the day, your goal is to do well in real interviews. To understand what is driving strong performance in real interviews, we surveyed interviewing.io users about how well they did in real interviews at Google, Meta, and Amazon and compared their performance at these companies against their past total interview count (both mock and real), gender, whether they had a computer science degree, and how they learned to code. The factor that stood out most was how many technical interviews an engineer had done in the past. Across all users, people who had completed #ve or more interviews had higher rates of passing a phone interview than those who had done fewer. The number of interviews mattered more than people’s starting technical pro#ciency, and it also mattered more than gender and pedigree (those factors didn’t actually matter). 4 PROBABILITY OF PASSING A TECHNICAL PHONE SCREEN 1 \" 4 INTERVIEWS BEFOREHAND 5+ INTERVIEWS BEFOREHAND Amazon65%81% Meta40%71% Google51%80% Figure 5. The probability of passing phone screens at Amazon, Google, and Meta, as a function of how many technical interviews candidates had done previously, based on data from interviewing. io users. Practice helps, and the “tipping point” is #ve interviews. But what, speci#cally, is it about practice that is so impactful? According to survey results, it's about direct feedback (when candidates were fortunate enough to get it; most often it was in mock interviews, rarely in real ones). Engineers typically can’t gauge how they did in interviews, 5 so they probably can’t gauge why they passed or failed—although, unfortunately, they often think they can. As a result, they are bound to over-index on the wrong things and neglect the ones that truly matter. We’ll talk more about",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 16",
      "content": "the limited utility of using real interviews for practice in “What about using companies for practice?” on page 79. Mock interviews o$er direct, honest feedback from other people so that you know how you're perceived and what to improve. 4 https://interviewing.io/blog/how-know-ready-interview-faang 5 https://interviewing.io/blog/people-cant-gauge-their-own-interview-performance-and-that-makes-them-harder- to-hire CHAPTER 5 ▸ MINDSET AND THE NUMBERS GAME 41 Finally, practicing can help resolve some of your (valid 6 ) frustrations about technical interviewing. Working for a FAANG+ means having to do algorithmic interviews, and if you're resentful of the format, you will not learn as quickly or e$ectively. Making peace with the format—whether that's seeing its bene#ts or just putting aside your feelings—will make your preparation much more e$ective (and probably much less unpleasant). As one engineer we know put it: [Practicing] unambiguously changed the game for me. I went from hating interviews and ranting about whiteboarding to \"If you go to med school you have to take the MCAT.\" THE TWO FUNDAMENTAL METRICS The two most important metrics to getting a job boil down to: 1. How many interviews do you have in your pipeline? 2. How good are you at passing technical interviews? Let's suppose you pass 70% of your interviews. Not bad, right? Most interviewers would like to hire you. But if a company does one phone screen plus four onsite interviews, this means that you only have a 17% chance 7 of getting an o$er from this company. Not so good—especially if you're trying to hold out for one speci\"c company. If you can raise this from a 70% to a 90% pass rate, this means you'll get most o$ers you try for. If that seems overwhelming, you can instead try for more interviews. With a 17% o$er rate, you can inter view with four companies and have a greater than 50% chance of at least one o$er. In reality, you'll want to optimize both of these metrics. A pass-rate of 80% will give you an o$er rate of 33%—and require just two companies to probably get an o$er. Your odds of getting a better o$er at a more desirable company only go up as you interview with more companies. To g e t a n o $e r t h a t yo u ' re e xc i t e d a b o u t , yo u ' l l w a n t t o fo c u s o n b o t h g e t t i n g m o re i n t e r v i e w s and doing better in those interviews. The goal of this book is to increase both of these metrics. 6 We’ve already talked about how, in our view, bad, unmotivated inter viewers are a bigger problem than the format itself. 7 Yes, yes, this is horribly handy-wavy. It assumes a 70% pass-rate on all interviews, when in reality it might vary by company or interview type—or just luck. JOB SEARCHES, START TO FINISH Interview Replay: Recordings of actual mock interviews. Snippet: Material that you can copy/paste online, including email templates and code recipes. Resource: Bonus chapters, worksheets, and other material. Problems, Solutions, and AI Interviewer: You can try every problem in the book with the AI Interviewer. Solutions are online in four languages (Python, Java, JavaScript, and C++). Watch for these speech-bubble icons, which mean there is online content. PAR T III JOB SEARCHES, START TO FINISH CHAPTER 6 I CHAPTER 6 I CHAPTER 6 II RESUMES Material for this chapter at bctci.co/resumes You might have heard these two seemingly con& icting statements about resumes: •They're super duper important! They're what get you in the door! •People only skim them. These aren't necessarily con& icting, but they do seem at least somewhat at odds. Muddling all of this is the incredible amount of resources out there about optimizing resumes: books, blog posts, resume writers, free and paid resume templates, and so on. What's the truth? The truth is that recruiters don't spend too long reviewing your resume, it's hard to di$ er- entiate yourself with it, and much of what they do look for is out of your hands. This doesn't mean skip this—if you're going to spend weeks or months on interview prep, you might as well spend a little time on your resume. But realistically, this is not the place to stress. Optimize, but don't overoptimize. ▶ What about LinkedIn? While we're using the term \"resume\" here, almost everything here applies to LinkedIn. Consider LinkedIn your online resume. W H A T R E C R U I T E R S L O O K A T In 2024, interviewing.io ran a study 1 where they asked 76 recruiters to look at resumes and indicate which candidates they’d want to interview. They were most likely to contact you if: • Yo u l o o k g o o d o n p a p e r, i . e . , y o u h a v e t o p - t i e r c o m p a n i e s a n d / o r s c h o o l s o n y o u r r e s u m e ( i n o u r e x p e r i - ence, companies matter more) • You belong to a group that’s been traditionally underrepresented in tech (i.e., you’re a woman or a person of color) •To some extent, if you have niche skills (e.g., ML engineering) What's missing? Things like, for example, having a quanti# able impact or demonstrating teamwork. Essen- tially, everything recruiters look for is stu$ that you either have or you don't. 1 https://interviewing.io/blog/are-recruiters-better-than-a-coin-& ip-at-judging-resumes CHAPTER 6 ▸ RESUMES 45 Since you can’t magic FAANG+ experience or professional experience with niche skills, or belonging to an underrepresented group out of thin air 2 , how do you use this information to your",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 17",
      "content": "advantage? We'll get there, but # rst you need to understand something else. Should you do side projects? As an engineer, I’d never discourage side projects—they can be fun, educational, and possibly take your career in a new direction. However, side projects are best pursued well in advance of a job search or simply because you enjoy it. Once you're actively looking for a job, your time is better spent on interview prep and outreach. You simply don't have enough time to make a cool enough project that it makes you that much more attractive to hiring managers. It isn't that these things have no value; they are just less likely to convert to a job. THEY AREN'T READING In this same study, we also learned that when recruiters do look at resumes, they spend an average of 30 seconds reviewing them. That's not enough time to read every bullet. Instead, they are mainly skimming for recognizable companies and schools. Here is an excellent example 3 —one that was successfully sent to recruiters—that makes this di$ erence very clear. This resume certainly passes the skim-test: good companies, appropriate roles, and a good university too. 2 This is why I generally view resume writers as selling snake oil. Either you have the things recruiters are looking for or you don’t. Additionally, non-technical resume writers will often focus on less relevant attributes because that's what they understand. For the most part, resume writers are a waste of time and money, and in some cases harmful. 3 https://www.reddit.com/r/recruitinghell/comments/qhg5jo/this_resume_got_me_an_interview/ 46 BEYOND CRACKING THE CODING INTERVIEW ▸ JOB SEARCHES, STAR T TO FINISH View online materials for Beyond Cracking the Coding Interview at bctci.co It's only when you read the resume that you learn that not only is this resume obviously fake, but it also celebrates accomplishments like \"Spread Herpes STD to 60% of intern team.\" And yet, it got a 90% callback rate. Recruiters just aren't reading the details. THEY AREN'T CONSISTENT In this same interviewing.io study, we also learned that recruiters were only slightly better than a coin &ip at identifying talent. And, what’s more, they all disagreed with each other about what a good resume looked like. 4 Recall all that resume advice you've probably heard, and stop and think: if people can't agree with each other on what makes a good resume, how can you optimize so much for this? We're saying all this not to suggest that you shouldn't care, but rather to encourage you to care a bit less. Do an adequate job and then put your focus elsewhere. AN ADEQUATE RESUME If recruiters are skimming your resume—not reading it—what do you do? You make your resume skimmable. That is, make the things recruiters are looking for—if you have them—really easy for recruiters to spot. 5 And if you don’t have these traits? It will still help you to do this. Everyone is aided by making their best stu$ easy to spot. These are the #ve easy steps to making an adequate resume: 1. Use a template. Any template will do. 2. Keep it to one or two pages. 3. Write up your work experience. Use clear, concise bullets. 4. Add your skills, education, and other sections. 5. Proofread. That's it. And, please, skip the resume writers 6 . RESUME TEMPLATES There are many templates online. Look for one which has: •Sections for Skills, Education, and Work Experience. •Columns for your companies, or something else that makes it very easy to see where you worked. •Will allow you to #t your resume on one (or two) pages. • Reasonable white space. Some resume templates put the headings like \"Skills\" and \"Experience\" as one big column, which takes up a lot of space. Unless you're struggling to #ll a single page, it's best to avoid these ones. •Uses bullets. 4 This was the second study of its kind that we did. We #rst got these results in 2014: https://blog.alinelerner.com/ resumes-suck-heres-the-data/ 5 Of course, whether you want to lead with underrepresented minority status is a personal decision. We’ve heard di$ering opinions on this and are not here to judge. All we can do is share the data—do with it what you will. 6 While there are some resume writers who produce good work, most do not. They will waste your money since, as we've explained, they're optimizing for things that mostly don't matter. On top of this, it's not unusual that a resume writer will actually cause damage. Most are not technical and don't know how to write a technical resume. They end up &u%ng your resume up with \"leadership\" and killing o$ the technical stu$. CHAPTER 6 ▸ RESUMES 47 The vast majority of resumes either # t these criteria or can be easily modi# ed to # t them. For your convenience though, we've provided some templates online at bctci.co/resume-templates. NOT!TOO!LONG RESUME Resumes should be one or two pages, generally. A good rule of thumb is that if you have held multiple jobs and have 10+ years of experience, you might be able to justify two pages. Other people should generally stick with one. In fact, for the vast majority of people, it's in your best interest to stick with one page. Remember that people are only spending 30 seconds or so on your resume because all they need to decide is \"interview or no interview.\" When your resume is multiple pages, it's a lot easier to miss the highlights, like a great project or award. When it's all on one page, the best stu$ is more likely to jump out at them. If your current resume is too long Despite this advice, we routinely see resumes that are sometimes three or four pages (my record is seventeen pages... from someone with only a few years of experience!). If you have a super long resume and just don't know how to cut it down, here's our recommendation: don't cut it down. Start over! It is very di% cult to",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 18",
      "content": "\"edit\" a resume from # ve pages down to just a page and a half. When you try to, you often # nd yourself wasting a lot of time condensing content that doesn't make much sense and isn't relevant. Just start over; it's faster. WRITING UP YOUR EXPERIENCE I'm reminded of Michael Pollan's healthy living suggestion: ▶Eat food. Not too much. Mostly plants. Here's mine for resumes: ▶Write stu$ . Not too much. Mostly highlights. Almost as catchy, right? Identify Your Highlights What are the top few things that would make a recruiter say, \"Yes, I want to interview you?\" Design your resume around those items such that, in a 30-second glance, a recruiter will notice them. Let’s say you’re fortunate enough to have FAANG experience or niche skills. How do you make sure that stands out to recruiters? Take a look at the before and after screenshots of this resume. 7 He actually has two of the three things that recruiters look for: FAANG experience and a niche title (ML engineer). But both are buried! And the section that gets the most attention is wasted on undergraduate awards. 7 We realize that recruiters won’t always have access to your resume when doing outreach and are likely looking at your LinkedIn instead. The same advice stands. Make sure that your About section has all the most important tidbits about you, front and center. Also, even though we didn’t see the same strong preference for FAANGs and underrepresented minority status when applying online (more on that in the next section), making these types of changes to your resume certainly won’t hurt. 48 BEYOND CRACKING THE CODING INTERVIEW ▸ JOB SEARCHES, START TO FINISH View online materials for Beyond Cracking the Coding Interview at bctci.co As you can see, he spent almost 3 years at Apple, but a recruiter skimming his resume might not notice that because it was a while ago. Instead, he showcases an undergrad award and some technologies/languages that he knows. Neither of those is nearly as useful to recruiters as FAANG experience. His current title is also ML engineer, and one at the Principal level at that. But it wasn’t always: He went from back-end to SRE to a little bit of everything to ML, and because of that, it’s possible a recruiter would miss it as well. We edited this candidate’s resume to put all the things recruiters look for at the very top of the resume and moved the buzzword soup to the bottom. This candidate is obviously well-positioned because he has FAANG CHAPTER 6 ▸ RESUMES 49 experience, several top schools, and niche skills—but before, many recruiters didn’t spot them. After he made these changes, the number of interviews he got increased by 8X. Clear, Concise Bullets Bullets don’t matter that much, but you have to have something there, so you might as well take a few minutes to clean them up. Bullet points should be clear and concise, demonstrating what you worked on and its impact. For example: • Clear impact: Created and launched a service that collects product opinions and recommendations from Twitter. The service #nds related tweets, removes spam, analyzes sentiment and creates a struc- tured database of everything that was said about particular products. • Unclear impact: Designed software application including: data modeling, software architecture design, software-hardware integration, user interface design, and database management. Where possible, use metrics to back up the impact. Don't force it though; many accomplishments don't have associated metrics. Be careful that your bullets aren't too long, either. Bullets should be a mix of 1 - 2 lines. Giant blocks of text are very hard to understand. When you only have time (or only feel like spending the time) to skim, paragraphs are going to get skipped. Company/Team Summaries For each company where you worked, if it’s not a household name, write a 1 - 2 sentence summary of what the company did. If it is a household name, write a 1 - 2 sentence summary of what your team’s purpose was. If it's really obvious (e.g., front-end on Google Docs), you can skip it if you're short on space. This is mostly here to set context for your bullets. SKILLS, EDUCATION AND OTHER SECTIONS While you'll typically have a section for Skills and Education on your resume, there are no hard-and-fast rules for what sections you can and can't have. •Got some cool projects? Great! Go for it. That's pretty common, in fact. •Contribute to a lot of open source projects? Okay, you can have an \"open source\" section. •Won some relevant awards? Okie dokie. An awards section it is. The point is to make your awesomeness standout, quickly. Do what you need to do to make that happen. About Whether you have an About section is really up to you. It can be a useful way to showcase details that might otherwise be missed (e.g., FAANG+ experience that isn't recent), but this isn't something you need to include. Our recommendation is to not include it during your #rst draft, but then to put it in if your highlights are otherwise being missed. Education Yo u ' r e t y p i c a l l y g o i n g t o h a v e a n E d u c a t i o n s e c t i o n o n y o u r r e s u m e. As a mediocre rule of thumb, current students or fresh grads will typically list education #rst, and professionals will list work experience #rst. This is convention, but it came to be for a very good reason: it showcases what is typically more relevant. Screw convention. If this isn't what's best for you, then do something di$erent. • If, for example, you are currently attending a no-name university with an Economics degree but have some FAANG+ internships as a Software Engineer, then you probably are better o$ listing",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 19",
      "content": "your work experience #rst. 50 BEYOND CRACKING THE CODING INTERVIEW ▸ JOB SEARCHES, STAR T TO FINISH View online materials for Beyond Cracking the Coding Interview at bctci.co •If you went to, say, MIT but then went to work as a chef for a few years before trying to claw your way back into coding, perhaps your education is more relevant. (That's probably a silly example 8 , right?) Yes, some people might initially misread your resume, but that's perhaps a risk worth taking. GPA You don't have to list your GPA on your resume and most people don't care a whole lot—or, at least, they say they don't. If you're a current student or new grad, the conventional wisdom is: •List your GPA if it's above a 3.0 •Skip it if it's below a 3.0 This is one of those cases where conventional wisdom is reasonable. Note that, because this is the conven- tional wisdom, recruiters will often make the assumption that \"no GPA\" implies \"low GPA.\" # Again, people don't care much about your GPA. However, your GPA typically gets listed on the same line as your degree, so it also doesn't take up additional space. If you have a good GPA and you've graduated recently, it doesn't hurt you to list it. If you have considerable experience, you probably want to just leave o$ your GPA. It just looks weird when someone has 20+ years of experience and still has their GPA on their resume. Skills It's standard to list what languages and technologies you know. But do you list everything you ever worked with? Just what you're comfortable being tested on right now? What you could brush up on fairly quickly? What exactly does an interviewer assume by the listing of a speci#c language on your resume? I (Gayle) have asked this question to hundreds of interviewers over the years, and answers are all over the map. Some interviewers assume \"pro#ciency\" if a language is on a resume, and then others assume \"you worked with it at some point\"—and many others are in between. What this means for you is that whatever you do is wrong... or right. Here's our advice: •List languages in pro#ciency order •Drop a language if neither of the following is true: »You have worked with it (professionally or personally) in depth in the last three years »You could code a typical interview question with it, with only minor syntax errors •Focus on languages, not &avors of a language (particularly for top-tier companies and most startups). There is stigma 9 at many companies when candidates list every version of a language. If you aren't sure whether a language makes the cut, you can describe your pro#ciency. For example, you can say \"Skills: Python (pro#cient); Java (pro#cient); C++ (prior experience but now rusty). 8 https://www.linkedin.com/in/alinelerner/details/experience/ 9 When people ask why there is stigma, the answer usually goes something about companies hiring in a language agnostic way; if they are okay hiring a Java developer to write Python, then why would they care about which versions of Python you know? That's true, but doesn't address the stigma question. The answer to that is a bit unfair, but it is essentially that while top-tier companies are language agnostic, many lower-tier companies are not. And in fact, the lower-tier companies often do care about the speci#c &avors of a language. When you list the &avors of Java that you know, they bucket you as a developer who would work for a lower-tier company. It's not fair, but it's the truth. CHAPTER 6 ▸ RESUMES 51 Projects If you don't have much work experience, or if you don't have experience in a relevant technology, projects can boost your relevant experience. You might as well show these o$, if you have them. Don't list every project you've done though. Typically, you want to stick to at most three projects. After this, you are typically just #lling in less interesting or relevant projects. PROOFREAD Per a study I (Aline) did when I was head of talent at TrialPay 10 , one of the best predictors of who got an o$er was the number of typos and grammatical errors: the best candidates had two or fewer mistakes. While non-coders often won't be surprised by this (isn't this the advice our moms and dads used to tell us?), it's often a surprise to coders—speci#cally, that this would apply to even an engineering resume. Why would people care so much about typos on an engineer's resume? Is this even fair, particularly given that, for many engineers, English is their second (or third or fourth!) language? We can argue all we want about whether this is \"fair,\" and it might even be merely correlation 11 not causation. Nonetheless, in case it is causal, you'd be advised to proofread. You don’t want your resume to look like this: Read it yourself, use the automated spelling/grammar check, send it to your favorite bot, and have a friend check it 12 . RELAX Let's end with a good (and by good, we mean terrible) story. It’s from an early employee at one of the FAANGs, which we'll call \"Company\" to protect the guilty. A long time ago, when Company was still small, we moved from our small downtown o%ce to a new o%ce in a local business park. Years later, I had a meeting in a conference room I'd never been to before. On my way to the room, I heard some beeps. I went searching for the source of the beeps, and in some small side room, in a deserted corner of the building, was a printer with a big stack of paper in the out tray. I looked at the papers, and they were all cover letters and resumes. I looked into it and found out that this printer was also a fax machine! It turned out that it was the fax number on Company's o%cial 10 https://blog.alinelerner.com/lessons-from-a-years-worth-of-hiring-data/ 11 Perhaps, engineers who proofread their",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 20",
      "content": "resumes carefully are also more likely to check their code thoroughly. Or perhaps they were more passionate about that job and so they proofread their resume more. Or perhaps... a variety of other non-causal explanations. 12 I (Gayle) once received a resume where a candidate described that she was \"inept at Javascript.\" I presume she meant \"adept\" (skilled) and was not intending to reveal herself to be incompetent. 52 BEYOND CRACKING THE CODING INTERVIEW ▸ JOB SEARCHES, STAR T TO FINISH View online materials for Beyond Cracking the Coding Interview at bctci.co jobs page! For years, the fax number mentioned on our jobs page went to a printer in some corner that nobody knew existed. Despite all of this—your resume not actually being the thing that gets you noticed, how little time recruit- ers spend reviewing your resume, how inconsistent reviewers are, how little you can actually do to drive change—we’ve seen candidates agonize over each bullet point, #nessing each and every word. But if the people reading your resume are barely skimming and can't agree on what they're looking for, it is incredibly di%cult to optimize. Yo u n e e d t o g e t s o m e o n e t o c o n s i d e r y o u. That is done through personal outreach, not picking out your resume from the black hole that is an ATS (Applicant Tracking System). Make your resume good enough for when someone opens your email and is intrigued, but don't stress too much about it. Job searches are stressful enough. CHAPTER 7 I CHAPTER 7 I CHAPTER 7 II GETTING IN THE DOOR Material for this chapter at bctci.co/getting-in-the-door We recently surveyed interviewing.io users about which methods of getting in the door at companies worked well for them in their last job search. Here are the results. 1 Interestingly, these results were quite consistent between company types; channels that worked well for FAANGs tended to work well for startups and vice versa. E# ective recruiting channels, ranked from most to least e# ective: •Warm referrals (referrals from people who know you well and have worked with you in the past) •In-house recruiters contact you •Apply online •Cold outreach to hiring managers Ine# ective recruiting channels: •Cold outreach to recruiters •Cold referrals (referrals from people who don’t know you) •Agency recruiters contact you Overall, the most useful channels were in-house recruiters (when they reached out to you) and warm referrals. Obviously, whether you know someone at a company you’re interested in and whether recruiters reach out to you are largely out of your control. So what can you control? Here are all of these channels, graphed with respect to both their e$ ectiveness and how much control you have over them. It turns out that cold outreach to hiring managers, when done right, is both e$ ective and controllable. In our experience, that channel is both misused and underutilized and is the best bet for many candidates (see \"What to Actually Do\" on page 59). Now let’s look at each channel in detail. 1 This data came primarily from surveying experienced engineers (4+ years), rather than juniors. G e t t i n g i n t h e D o o r 54 BEYOND CRACKING THE CODING INTERVIEW ▸ JOB SEARCHES, START TO FINISH View online materials for Beyond Cracking the Coding Interview at bctci.co Figure 1. Channels graphed with respect to both their e$ ectiveness and how much control you have over them. IN'HOUSE RECRUITERS CONTACT YOU You have little control over this. The best thing you can do is to make sure that the things recruiters look for (pg 44) are well-highlighted on your resume (if it’s public-facing) and on your LinkedIn. The rest is luck. A P P L Y O N L I N E If you’ve ever applied to jobs online, then you know it’s kind of like screaming into a black hole. 2 Though some candidates get value out of this channel, it’s still a numbers game. According to recruiting tool Gem, applicants who come from recruiter outreach (called “outbound” in recruiter lingo) are 6 - 10X more likely to get hired than applicants who apply online (called “inbound”). 3 As Lyft recruiting manager Nate Wylie put it: Our data... showed higher pass-through rates for candidates [we reached out to] at each stage of the interview process vs. applicants via the careers page. It’s not that we want to ignore applicants; it’s just that historically we don’t get what we’re looking for—and with speed—through that channel. 4 The silver lining here is that when you don’t hear back from a company (or even when you get an automatic rejection email wishing you \"the best in your future endeavors\"), it’s not because a human looked at your resume and made a deliberate, thoughtful decision about you. It’s tempting to think that way because it plays so well into our insecurities. The reality is that a human probably never saw your resume in the # rst place. 2 Or, like faxing your resume to an old machine buried in a closet that no one has entered in years. 3 https://www.gem.com/blog/outbound-candidates-more-likely-to-be-hired 4 Having been a recruiter myself, I (Aline) can con# rm that many companies do indeed ignore their online careers page. Many years ago, when I # rst joined the recruiting team at a top-tier startup, I spent my # rst few days going through the resumes of people who had applied online. I found a treasure trove of candidates, including very experienced applicants from top-tier companies. But no one had seen these applicants because no one had been monitoring inbound activity for months! CHAPTER 7 ▸ GETTING IN THE DOOR 55 So why do people apply online, despite knowing in their gut that it’s not an e$ ective strategy? Simply put, it’s predictable and easy. You get into a routine, you upload your resume, you connect your LinkedIn, and",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 21",
      "content": "you can knock out hundreds of applications in a matter of hours. # Applying online doesn’t hurt, as long as you don't get personally hurt over it. If you do, it’ll wear you down over time. WARM REFERRALS Warm referrals are, of course, excellent. That is, assuming it's a real referral—someone who can actually vouch for you, and ideally, your work. Per capita, referrals are most companies’ best source of candidates, and they were a great channel for our users across all company types. If you have the network, you should absolutely use it. Just keep in mind that most internal referral forms contain a question about how well you know this person and where this person ranks (top 5%, bottom 10%, etc.) in your estimation, compared to other people you’ve worked with. Just because someone refers you doesn’t mean they’ll be dishonest on this form, so take care to choose your referrers wisely. Even if you have a great history with someone, we know that asking for a referral can be awkward, so if you're struggling with # nding the right words, here are some handy snippets you can use, depending on the situation: bctci.co/outreach-what-to-say-1 Of course, it’s unlikely that you’ll have meaningful connections at every company you want to work at. What do you do then? COLD REFERRALS Should you ask people you don't know to refer you? Our survey data says probably not. While cold referrals once worked, 5 many companies nowadays separate referrals into \"true referrals\" and \"leads.\" It’s great for maintaining the delicate dance of social dynamics, but it’s useless for getting hired— dropping someone’s resume into the “leads” pile is like throwing it into the inbound black hole. Given that cold referrals aren’t zero e$ ort, our advice is to expend that energy elsewhere. More on that shortly. AGENCY RECRUITERS Agency recruiters were the worst channel overall, according to our survey, and were net negative for all company types. FAANGs and FAANG-adjacent companies tend to rely less on agencies than startups, and when they do, it’s to # ll some very speci# c need (rather than “Hey we need more SWEs”), so it’s not surprising that our users didn’t get much value from this channel when applying to FAANGs. 5 Years ago, trying to collect cold referrals was a decent strategy. You could track down someone at the company and ask them to toss your proverbial hat into the ring. Engineers were often happy to refer someone — even someone they didn't know — either to be kind, to avoid the awkwardness of declining, or to collect the potential referral bonus. They couldn't vouch for you, but the referral would ensure that a human looked at your resume. This became so common that Blind spun out an entire referral marketplace where applicants would pay a small sum for a referral. Then, companies wised up and realized that these referrals weren't all that di$ erent from normal inbound applicants. So why treat them di$ erently? 56 BEYOND CRACKING THE CODING INTERVIEW ▸ JOB SEARCHES, STAR T TO FINISH View online materials for Beyond Cracking the Coding Interview at bctci.co While both large and small startups use agencies liberally, clearly the value to candidates is limited. 6 Out of all of our survey respondents, only a handful of our users said that agencies were useful to them, and of those who mentioned agencies, the majority said that they were the worst channel. We won’t belabor the point, but it’s probably not in your best interest to spend much time working with agency recruiters. It has an opportunity cost and not much upside. And you can routinely get screwed in salary negotiations when you work with an agency recruiter (pg 29), if you even get that far. COLD OUTREACH Not all cold outreach is created equal, for two reasons. First, there’s your audience: hiring managers vs. recruiters. And then there’s the quality of the outreach itself. We'll talk more about how to write the kinds of messages that will get you responses (pg 61), but #rst, let’s talk about the audience. Yo u c a n s e e i n o u r s u r v e y r e s u l t s t h a t c o l d o u t r e a c h t o h i r i n g m a n a g e r s w a s n e t p o s i t i v e fo r FA A N G / FA A N G - adjacent companies and neutral for the other company types. Cold outreach to recruiters, on the other hand, was net negative for both FAANG/FAANG-adjacents and small startups and neutral for large startups. Ignoring the quality of the outreach for a moment, which we expect is probably comparable for both types, why does this di$erence exist? If you had to answer the question of who’s the right person to reach out to about jobs, your gut instinct might be to say it’s recruiters. After all, hiring good people is o%cially their job! But what does “good” really mean? COLD OUTREACH TO RECRUITERS DOESN’T WORK When I ran my own recruiting agency, I kept running into the same wall. I’d present candidates who didn’t look good on paper but who I had strong reason to believe were actually good. Recruiters at my client companies, by and large, would not entertain those candidates because it was simply too risky for them. Engi- neering time is precious, and if a recruiter presents a candidate who doesn’t #t the mold and that candidate ultimately doesn’t work out, it’s a strike against the recruiter. On the other hand, if a recruiter continually presents “safe”, name-brand candidates, some of whom make it through and some of whom do not, no one can blame you. It’s the whole adage about how no one ever got #red for choosing IBM, except with",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 22",
      "content": "people. To put it really concretely, I’d expect that as an in-house recruiter, if you presented 10 name-brand candidates, 8 of whom didn’t get an o$er, 1 of whom did but was clearly never interested in your company, and 0 of whom got hired, no one would bat an eye. On the other hand, if you presented 10 candidates, all of whom looked kind of weird on paper, 2 of whom got o$ers, and 1 of whom got hired, you’d probably get a stern talking to. 7 You might think that, over time, companies would start to track which recruiters bring in candidates who actually get hired and reward those recruiters. The reality is that most recruiters aren’t evaluated this way because it takes too long. 6 We’d argue that the value to companies is limited as well. Though there are a handful of excellent agency recruiters out there, most are terrible. The hard thing is that, as an employer, you can’t immediately tell who’s terrible, and you end up wasting a bunch of time reviewing pro#les of candidates who might look promising on the surface, but because of selection bias (these are the people who decided to work with bad agency recruiters, after all) are not a #t. That or they’re not interested in your company (and have possibly never even opted in to talk to you) or both. 7 One of the #rst companies I worked with when I was running my own agency made a deal with me after seeing the non-traditional kinds of candidates I presented. They said that, though they’d be down to talk to the #rst 3 candidates I sent their way, if most of them didn’t make it to at least onsite, I was going to be #red. Not only did they work with me for a long time, this company later became one of interviewing.io’s #rst customers. CHAPTER 7 ▸ GETTING IN THE DOOR 57 In theory, recruiters can be evaluated on what portion of their candidates get o$ers or get to onsite. However, because of candidate drop-o$ and latency (getting an o$er can still take months), your organization has to be pretty good at tracking metrics. Many are not. As such, many recruiting teams prefer simpler, faster metrics: Of the candidates you reached out to, how many responded? Of those who responded, how many resulted in a #rst conversation? The downside of measuring success in a single part of the funnel is that you don’t incentivize people to care about what happens downstream (that is, how many are hired). This would be like if marketers only paid attention to ad clicks, rather than actual purchases (although that’s often how it works with marketers, too). So, if you are typically just measuring the response rates of your reports, you have to set some guardrails and proxies for the types of candidates that you want your team to reach out to. If you don’t, they’ll end up just reaching out to people who are likely to respond instead of people who are a good #t for the job. That brings us back to the idea of a “name-brand” candidate that we discussed earlier. So what does a name-brand candidate look like? You can’t just go on LinkedIn, and say, “Find me good engineers.” 8 That doesn’t exist. So instead, you come up with some proxies that look like this: • Senior engineers. Why seniors? Juniors are generally easier to hire, so companies don’t need to go beyond what they usually do to #ll those roles. For college students, specifically, there’s a separate university department that deals with college hires once a year in September. •Went to a top school •Worked at a top company There may be a few other items on the list if the role requires speci#c skills (e.g., Android development), but by and large, that’s what recruiters are tasked with, and that’s what they’re focused on. # What does this mean for you? If you’re not the type of candidate that recruiters are reaching out to already (senior, well-pedigreed), they will not help you. 8 People think that because recruiters are, generally speaking, not technical, they can’t identify talent. In fairness, hiring managers aren’t very good at identifying talent based on resumes either. When I tested engineers vs. engineering managers vs. recruiters at this task, I learned everyone is bad at it: https://blog.alinelerner.com/resumes-suck-heres- the-data/ 58 BEYOND CRACKING THE CODING INTERVIEW ▸ JOB SEARCHES, STAR T TO FINISH View online materials for Beyond Cracking the Coding Interview at bctci.co With that sad reality in mind, here’s the good news: there is someone who’s actually incentivized to make hires and is much more open-minded: the hiring manager! 9 REACH OUT TO HIRING MANAGERS INSTEAD Unlike recruiters, hiring managers are judged on how quickly and e$ectively they’re able to build stu$, and are—directly or indirectly—incentivized to grow headcount. 10 For hiring managers, it’s not about the appear- ance of doing the work; it’s about the cold, hard reality of whether the work got done. And because they’re judged on actually getting stu$ done, hiring managers are also much more incentivized than recruiters to take risks. Outside of needing more people to build things, hiring managers are also incentivized to hire for their teams because the better they are at recruiting and #lling headcount, the more likely they are to get promoted. So, armed with an understanding of how hiring works behind the scenes, here’s our recommended, hyper- practical approach. It starts with treating your job like a sales funnel. TREAT YOUR JOB SEARCH LIKE A SALES FUNNEL If you’re an engineer, chances are you haven’t ever done sales. 11 But if you do sales for any appreciable amount of time, you’ll start thinking about everything in life as a funnel. Funnels are wide at the top and narrow at the bottom. That’s why they’re such an apt metaphor for the sales process—you do a lot of outreach, and you don’t get many responses.",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 23",
      "content": "Of the responses you do get, relatively few will do the thing you want them to do. And even fewer will ultimately “close” (aka, buying—or, in this case, hiring). In your engineering career, you’ve mastered many abstract concepts that are much more complex than a funnel. Despite its simplicity, however, the funnel is one of the hardest concepts to internalize emotionally, especially for people who are used to having control over outcomes. When you write code for n hours, you can expect that you will build m features. In sales though, you do a lot of work, very little of it will pan out, and when it does pan out, it can feel almost random; an impersonal, mediocre email gets a response while your beautifully targeted email is met with deafening silence. And then there’s rejection. When you apply to jobs online and don’t hear back, it stings, but the sting is softened by the possibility that a human never even saw your application. You’re not reaching out to people when you apply online; you’re dealing with a bureaucratic machine. 9 Note that if you’re interested in smaller startups (Series A and below), you can substitute “founder” for “hiring manager” in these steps. Founders are the most incentivized to get shit done and take risks, regardless of company size and stage, but at larger startups, they may be less likely to read cold emails because they get bombarded with all manners of requests and sales pitches. At a Series B or C company or at public companies with fewer than, say, 3000 employees, in addition to hiring managers, you should also target Directors and VPs — they have the power to get things done and aren’t so far removed from feeling the pain of not #lling roles that making an extra hire or two is out of their purview. At large public companies, targeting Directors and above doesn’t make much sense — they ARE too far removed from doing the work to make individual hires. If you do contact them, the best outcome is that they’ll pass you on to one of their direct reports. 10 Yes, hiring managers are actually sometimes evaluated on their ability to hire. Moreover, the more headcount a manager is able to command, the greater their political capital inside the organization, and the easier it is to not only get promoted but also get hired at their next company for increasingly senior titles. 11 Maybe you had a job in high school selling Cutco knives or magazines, in which case what we’re about to say will resonate. CHAPTER 7 ▸ GETTING IN THE DOOR 59 On the other hand, when you email a real human and they don’t respond, that hurts: you put yourself out there, someone made a value judgment about you, and you lost. The good news is that, after a while, the pain lessens, and you build up some useful emotional calluses and acquire the thousand-yard stare of someone who’s been rejected a million times for a million reasons, ranging from soul-crushingly legitimate to incontrovertibly random. Sadly, there’s no shortcut. You’ve got to do the reps, you’ve got to get the rejections, and you’ve got to pick yourself up again. You get used to it, and then it doesn’t hurt as much, because experience has taught you that if you keep going, you will eventually get to a yes. PREREQUISITES/TOOLING •Buy a month or two of LinkedIn Sales Navigator. This will run you a few hundred dollars, but it’s worth it. •Get an account with an email discovery tool like RocketReach. • Get Streak, which lets you do mail merges in Gmail. You create an email template, with variables for everything from recipient name to long snippets of personalized text, and then you upload a CSV with all the values. The resulting emails feel personalized but get sent to hundreds of people at once. W H A T T O A C T U A L L Y D O Figure out which companies you’re interested in First, make a list of the companies where you want to work. This sounds easy, but it’s not necessarily. Many people will just write down a few FAANGs and whatever companies are hot right now and call it a day. That’s not necessarily a bad strategy. Having a top-tier brand on your resume can legitimize you for future job searches, and they tend to pay well too. But we recommend you look beyond the obvious to other companies whose work might excite you: •Are there any dev tools that you really admire? •Are there any open-source projects you follow? •Are there any engineers you follow on social media whose work you admire? • Look at where your friends work by combing through Facebook or LinkedIn or both. Reach out to them to ask what it’s like (before you even ask for a referral). If you’re not sure how to ask people about the day-to-day, we’ve included a template for you in the Referrals section:bctci.co/outreach-what-to-say-1 Here are some resources to help you # nd companies you might be interested in: Y Combinator’s Work at a Startup, Wellfound, Remote Rocketship, levels.fyi, Glassdoor, and Blind. Get links and more details at: bctci.co/resources-to-# nd-companies Make your target list Once you have your list of companies, use LinkedIn Sales Navigator to # nd hiring managers at those compa- nies (or founders or directors or VPs, as above). If the list is large, consider # lters for: 60 BEYOND CRACKING THE CODING INTERVIEW ▸ JOB SEARCHES, START TO FINISH View online materials for Beyond Cracking the Coding Interview at bctci.co •Just targeting managers, not Directors or VPs. Google is a huge organization. You want the people who are most likely to help, and they’re the ones who are struggling to hire for their teams. • In position for less than 2 years: These are the people who are still trying to prove themselves and who are less likely to have a",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 24",
      "content": "long-standing relationship with their recruiter to the point where they only rely on internal recruiting and overlook other sources of candidates. •Geography: Let's focus on the places we most want to work. • 1st- or 2nd-degree connection: This way, when they look you up, they’ll see some social proof. You can expand this to 3rd-degree connections if needed. Once you have your list, put their LinkedIn URLs into a spreadsheet. Then, do a pass through your targets’ pro# les and see if any of them link to personal websites, social media accounts, blogs, or anything else that will help you # nd common ground with them. Add any useful links in your spreadsheet because we’ll be mining them when we actually write our emails. If you come from a non-traditional background (e.g., you didn’t attend a top school or work at a prestigious company), consider adding startups to your target list, if you’re at all open to working at a startup. Then try to # nd startups who have a founder from a non-traditional background like you—you’d be surprised by how many founders don’t have a traditional pedigree (many end up taking the founder road because they get tired of being overlooked). If you can # nd people like you, it’ll be easier to establish common ground, and you’ll be more likely to get a response. Look up their email addresses Once you have your list of LinkedIn URLs, use a tool like RocketReach to look up their emails. RocketReach is a nice tool for email discovery because 1) it takes LinkedIn URLs as inputs and 2) its email database is generally up-to-date and correct. CHAPTER 7 ▸ GETTING IN THE DOOR 61 Why not reach out on LinkedIn? While recruiters live on LinkedIn, managers generally do not. They may not even like or check LinkedIn much. They live in their email, so that's where you want to target them. If RocketReach fails or you don't wish to pay for it, you might just be able to guess their email address, as email addresses tend to follow common forms: #rstname@company.com, #rstinitial.lastname@company. com, or #rstname.lastname@company.com. Where possible, contact managers via their work email address. 12 It’s okay to fall back to their personal email if you can’t #gure out the work one, though. Outreach emails are not a job application Before we tell you how to write outreach emails, it’s important to understand that they are di$erent from a job application. • Yo u ’r e c o n n e c t i n g w i t h a h u m a n b e i n g , n o t a n A p p l i c a n t Tr a c k i n g S y s t e m . Your goal is to make them think you’re worth talking to. If you were at a party, you wouldn’t come up to a person and immediately start listing frameworks and languages that you know, so don’t do that here. • Not super focused on a speci$c position or team. Job descriptions are written badly, many open roles aren’t listed, and you will never have enough information to make this decision. Be ok with that, and just focus on getting in the door somehow. This means that when you come up with your target list, you don’t have to #nd exactly the right hiring manager. All you need to do is get in the door with someone, and then they’ll route you to someone else. This email isn’t the be-all and end-all of your job search. It won’t get you a job. It will just get you in the door. It doesn’t need to be perfect. You just need to get to the next step. Write succinct, highly personalized emails Now that you have your target list, it’s time to compose a fairly personalized, yet short, email. All too often, candidates write a long, generic cover letter that’s clearly been sent to a ton of people. I get many emails that look like this (in these emails, we left in typos if there were any to begin with): Hello Aline, By way of linkedin search connections, I found through your contact information. I am a Engineering management professional with 16+ years of engineering experience currently on the lookout for a suitable job in Bay Area. As part of Corporate restructuring and leadership changes at Paypal, my job was one of 2400 positions that was eliminated thereby giving me a splendid opportunity to explore outside jobs. In my recent experience at REDACTED, I have played diverse engineering roles including Leading the REDACTED In-store partner engineering organization, Sr Manager of PMO and Chief of Sta$ for a 400+ strong engineering org and other Program Management roles. I am speci#cally looking across most of the Product-oriented technology companies in Bay Area (preference on Retail, E-Commerce, Payments, Hi-tech industries) as Director of Engineering/PMO/Professional Services. I have prior experience on di$erent aspects on technology integrations (Java, REST, API, Oracle, SQL, AWS, EJB, Javascript) and also various management and operational expertise (Managed Services, 12 Recruiters should not contact candidates on their work email address, but that's because they're trying to make the candidate leave their job. You are trying to join the manager, which is why it's okay to use their work email address. 62 BEYOND CRACKING THE CODING INTERVIEW ▸ JOB SEARCHES, STAR T TO FINISH View online materials for Beyond Cracking the Coding Interview at bctci.co Contract management, Business operations, Program Management, Leadership, Strategy planning, Vendor negotiation, Consulting, Product Integrations). I really do appreciate your time and excited to work with you in my search. My detailed resume is attached, if you've time this week, we can catch up over phone or a co$ee to provide you further details. Appreciate your assistance! Thanks, REDACTED ▶Don’t do this! This email sounds generic and has probably been sent to many people. Hi Aline, I am writing to express",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 25",
      "content": "my strong interest in joining the engineering team at interviewing.io. With my extensive experience in engineering, I would love to discuss how I can help Interviewing.io achieve even greater heights. I’ve had success driving growth for companies like REDACTED, Amazon, Tata Group and I believe my skills would be incredibly bene#cial for your team. Quick Highlights: • Achieved a 20% month-over-month improvement in system performance metrics at REDACTED through optimized engineering work&ows and scalable solutions. • Played an integral role in building and deploying data-driven algorithms at Amazon, scaling the seller's GMV by 3X via enhanced platform reliability and feature innovation. • Core skills include Software Development, Distributed Systems, API Design, Cloud Infrastructure (AWS, GCP, Azure), and Machine Learning Engineering. Please #nd my CV here Would you be open to a quick chat this week to explore how I could contribute to Interviewing.io's success? I’m looking forward to the possibility of working with you. Regards, REDACTED ▶ Don’t do this either! There is nothing here about why this candidate is a good #t for interviewing.io, and the bullets aren’t compelling enough on their own. Emails like the above are impersonal and tell me that you didn't really invest time in understanding me and my company. If you didn't invest in me, why should I invest in you? • Don't open the email with how they found you. We really don't care, and you want the #rst line to be meaningful. • Don't be overly formal in how you address the person. Use their $rst name. 13 • Don't get their gender wrong (e.g., referring to a woman as \"sir\"); you’d be surprised how often this happens). • Don't paste in a generic cover letter. These are sure to get ignored—if you’re not going to put in the e$ort to write to me personally, why would I put in the e$ort to read your email? 13 In some cultures, using your target’s #rst name might come o$ as overly informal. Use your best judgment here if outside the U.S. CHAPTER 7 ▸ GETTING IN THE DOOR 63 • Don’t lead with “buzzword soup”. You’re talking to a human and trying to build rapport with them, not subverting an Applicant Tracking System. • Don't forget to include a link to a LinkedIn or a personal website. We don’t recommend attaching your resume, though. It can seem overly formal/somewhat presumptuous if you're trying to build rapport. 14 More broadly, if you want someone to go out on a limb for you, make it dead simple for them to justify expending their social/political capital on you. Hiring managers, as a rule, want to help. Make it a no-brainer for them. There are three components to a great cold email: 1. Common ground with your target: Not every cold email will have common ground; there’s simply not enough information out there about some targets to be able to craft a compelling narrative that’s highly personalized to them. 2. Proof that you’re worthy of their time: It is your job to sell yourself quickly and succinctly. You want your target to feel like they’d be an idiot to pass up the chance to talk to you. 3. A strong call to action: Ask for a meeting or something else. Let's dive into these in more detail. Finding common ground The email below is personal, succinct, and #nds common ground. Not only that, but it conveniently #nds common ground that bene\"ts the candidate (a soft-spot for non-traditional candidates, like themselves!). Aline, I've been reading your blog over the past 6 months and I seriously appreciate your pragmatic, no-nonsense approach to technical recruiting. In your recent article about building technical recruit- ing products, you included a footnote about non-traditional candidates that really resonated with me. I consider myself one of those non-traditional candidates—not always the obvious #t on paper, but I kick ass once I'm in an interview. I would love to work with you if there is an opportunity to do so. If not, perhaps in the future. In either case, thank you for taking a few minutes to read this email and best of luck with interviewing.io. Thanks, REDACTED To #n d c o m m o n g ro u n d, re fe re n c e s o m e t h i n g yo u r t a rg e t c a re s a b o u t. Then either show them that you care about it too or that helping you would #t into their worldview and further that cause. Here are some examples of great ways to build common ground: • Reference a project they worked on (maybe they wrote a blog post about it, mentioned it in a comment on Hacker News, or are a contributor to some open-source project). Then, either talk about relevant work you've done (if there is a genuine connection) or alternatively ask a thoughtful question or two about theirs. •Reference a controversial 15 point of view that they hold, and a%rm it in an authentic way. 14 If you don’t have a LinkedIn or a personal site, then a resume may be better than nothing. But also, creating a LinkedIn pro#le is free, so if you don't have a LinkedIn pro#le, go make one. 15 We mean something like \"spaces are better than tabs\", not something erring into viewpoints that could be o$ensive or discriminatory. 64 BEYOND CRACKING THE CODING INTERVIEW ▸ JOB SEARCHES, STAR T TO FINISH View online materials for Beyond Cracking the Coding Interview at bctci.co •In the absence of something technical, it’s okay to reference something non-technical you've seen on their public pro#les. We've seen candidates connect with strangers based on a shared love of Star Wars or Hearthstone. We understand that you won't always be able to #nd common ground. But if you can, it'll help you a lot, especially if you’re light on social proof or accomplishments. Selling yourself Selling yourself is usually about one",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 26",
      "content": "of two things: •Accomplishments: What have you built or created? •Social proof: Have you worked at a top company or attended a top school? Some people are fortunate enough to have both, but many will have just one. That’s okay. We’ll work with what you have! Accomplishments should answer the following questions. What have you done that most other people haven’t? What have you done that, if you were to tell it to a stranger, would cause them to pause and think you're special or interesting? Below are some examples: •A blog post you wrote about a technical topic did well 16 on Hacker News, Reddit, or social media. •Something you built got some great press when your company announced its last funding round. •You refactored a piece of code at work, and now it runs 100X faster. •You won a company hackathon. •You’re a core contributor to a notable open-source project. •Something you built is being used by a number of other people. Remember, even if you're a new engineer in the #eld, and you don't have job experience yet, you still have accomplishments you can highlight! Social proof is about your pedigree—attending a top school, working at a company known for having a high engineering bar, etc. People won't click on links or open your resume until after they're interested, so you need to get them interested right away. That is: you should spoon-feed them the most impressive-sounding things about you out of the gate. This may feel strange and uncomfortable like you’re bragging. However, we assure you that it’s necessary to get your target’s attention. They ’re not think ing you’re bragging. They’re thinking, “Is this worth my time?” Your job is to convince them that it is. Also, don’t forget to link to your LinkedIn or personal website. Attaching a resume may feel too heavy-handed for a #rst conversation, as we discussed earlier (pg 63). Here's an example of a prospective intern, leveraging both social proof and accomplishments, to write a compelling email. Hello Ms. Lerner, My name is REDACTED, and I am a sophomore at MIT. I wanted to reach out directly to you, as I am looking for a possible opportunity to sharpen my technical skills over this REDACTED and truly love Interviewing.io’s mission in reimagining the art of engineering recruitment! I have extensive experience in software development, having interned at IBM, MIT CSAIL (being featured by Redacted Newspaper 1 and Redacted Newspaper 2), and REDACTED previously (resumes attached 16 Many people think that for something to be worth mentioning, it has to have gone viral. That’s simply not correct – in our niche space, a few hundred likes or a few thousand upvotes is already really impressive. CHAPTER 7 ▸ GETTING IN THE DOOR 65 below), and would love to possibly intern as a Software Engineering or Machine Learning Intern at Interviewing.io REDACTED remotely or in-person. I would also be more than happy to possibly interview for the position to show our capabilities! Genuinely, I would love to join the Interviewing.io team—a community of changemakers—and believe I can add tangible value to a project with my previous SWE/ML background while growing my skills as I enter my Junior year of college. As an entrepreneurial leader, I hope you can resonate with my strong passion for tech and hope you will give me a shot! His email isn't super personalized, but he did make some e$ort to say that what we do at interviewing.io is important. Well done. Formulating a strong call to action A call to action is an invitation for the recipient to do something, such as extend a job interview or start a conversation. Those with more social proof or accomplishments are more likely to be able to be bold and ask for a job interview. Without it, you may need to focus on building common ground and ask for just a conversation. If you’re asking for an interview, just come right out and say it. You can use the intern candidate’s email from earlier as a guide. Asking for a conversation can be tricky. To wit, take a look at the email below. Hi Aline, I've been a big fan of the research you've shared on interviewing.io on things like score variability, Cours- era vs top school e$ects, and judging resumes. You're adding much needed data to a #eld historically #lled with anecdotes and rules of thumb and more people need to know about it. I would love to interview you on what you've identi#ed from interviewing.io on what works (and what doesn't) in terms of identifying engineering talent.Would you be open to scheduling a 30 min call in the next few weeks? Best, REDACTED In this email, the candidate doesn’t ask me about jobs—he just asks to meet to discuss a topic. Indeed, he’s done his research. I write a ton about judging resumes, and it’s a topic I could go on about for hours if you’ll let me. His email read like he was genuinely interested in the subject and that we’d have a good conversation, so of course I responded. You’d be surprised how rare emails like this are. If you can #nd the topic your target cares about and write something that shows earnest, genuine interest, odds are good that they'll respond. With these emails, you’re asking for a conversation, not a job interview—because the conversation is what will hopefully prove to the hiring manager that you’re worth interviewing. Then, once you have a conversa- tion, the hiring manager will walk away with the impression that you’re a competent, thoughtful human being who’s interested in this sort of work. From there, getting a job interview will feel like an afterthought. As such, don’t talk about jobs at all in the email, and in this particular case, don’t attach your resume; that will feel out of place and transactional. You can and should link to your LinkedIn so they know who you are and have some context.",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 27",
      "content": "But spend the bulk of the email building common ground and coming up with an interesting reason for the two of you to talk. You’re not going to land a job from one email, so, as with any seemingly insurmountable goal, it’s important to think of your outreach as a series of steps where you put one foot in front of the other. Like in sales, all you need is to get to a conversation. 66 BEYOND CRACKING THE CODING INTERVIEW ▸ JOB SEARCHES, START TO FINISH View online materials for Beyond Cracking the Coding Interview at bctci.co If your call to action is to set up a time to talk (which it probably should be because it’s speci# c), we recom- mend providing them with a time window. \"Would you want to meet up sometime?\" puts the burden on the recipient to pose a time, while \"Can we talk next Monday at 3pm?\" is problematic because, most likely, they aren't free then. Instead, try something like the candidate above did: \"Would you be available sometime within the next two weeks for a thirty-minute call? I'm free most weekdays between X and Y and can pretty much do any time on weekends if those are better for you.\" How long it takes So, how long does the outreach portion take? Below are the rough steps and our estimates for each one. Depending on the length of your list and how hard-to-# nd your targets are, these numbers may change. 2 days: Create a target list 1 day: Write your # rst draft email template 3 days: Go through your target list and # nd personal tidbits about each target (e.g., blog posts) 2 days: Write outreach to the # rst batch 1 week: Wait for results so you can iterate on your outreach 2 days: Write outreach to the second batch 1 week: Wait for results so you can iterate on your outreach 2 days: Write outreach to the third batch 1 week: Wait for results so you can iterate on your outreach Optimistically, the above adds up to 5 weeks. The hard part about this kind of work is that it comes in stops and starts, and it’s non-deterministic; you're somewhat at the mercy of your recipients and their schedule. We’ll talk in Managing Your Job Search (see \"How to manage timing for practice vs. outreach\" on page 82) about how to time outreach with interview prep; depending on your workload and # nancial situation, you can either run these concurrently or space them out. COLD OUTREACH TEMPLATES Here are two templates you can use for cold outreach. The # rst one gets higher response rates but requires more e$ ort and can't always be used. The second one is weaker but more generic. You can choose what # ts your needs best. We expect both of these templates to be far more e$ ective than throwing your resume into the black hole of online portals. Template: If your target has an online presence This template includes common ground, accomplishments/social proof, and a call to action. It will get you the highest response rates, possibly anywhere from 25 - 50%. However, it can be challenging to use because it requires you to 1) do a deep dive into their online presence and 2) tie what you # nd back to something you’re doing. Sometimes, that tie-in might be tenuous or non-existent (in which case, maybe skip it). Copy/paste this template at bctci.co/outreach-what-to-say-2. Hi {First Name}, I’ve read your work on {some details about their writing}, and I {insert your thoughts on the work}. {If you can make the connection between their work and yours, talk about something similar you’ve been working on.} CHAPTER 7 ▸ GETTING IN THE DOOR 67 {If you cannot, ask them a speci# c, thoughtful question about your work. Don’t worry about making it “the perfect question” like you might when you attend a talk and want to sound smart. Any earnest question will do. You don’t have to use this as a chance to show o$ !} {Finally, close with a sentence or two about you, if you have some social proof or impressive accomplish- ments you can share.} Would you be up for a quick chat this week or next? Best, {Your name} {Insert 1-2 useful links about you. If you have a personal site, that’s great. If not, a LinkedIn will do.} Template: If your target only has a LinkedIn pro\" le The reality is that you won’t always have enough information about your target to # nd common ground. In this case, you’ll lead with accomplishments/social proof and a strong call to action. We expect this template will get you response rates anywhere from 5 - 25%, depending on the strength of your achievements and pedigree. Copy/paste this template at bctci.co/outreach-what-to-say-3. Hi {First Name}, {List 2 things about you. They can be impressive accomplishments of yours or social proof.} I’m really interested in the work you’re doing at {Company}. {If you know what team they’re on and are interested in that speci# c team or are familiar with that team’s accomplishments, great! If not, just write a few earnest sentences about why the company is interesting to you.} Would you be up for a quick chat this week or next? Best, {Your name} {Insert 1-2 useful links about you. If you have a personal site, that’s great. If not, a LinkedIn will do.} Keep your note short. The intent here is to make your target believe you’re worth paying attention to, rather than them doing the easy thing: deleting your email. Regardless of which template you use, just like you have to manage your psychology when you prepare for technical interviews, you have to manage your mindset when doing outreach like this. You have to: •Mentally prepare yourself for the slog of writing personalized emails and doing the requisite research. • Get used to rejection. If you do write good emails",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    },
    {
      "title": "PDF Chunk 28",
      "content": "and target the right people, you’ll have a much better hit rate than when you apply online, but you will still get ghosted a lot, and it will sting much more because, this time, you actually tried. But you know what? If you stick with it and do this right, within a few months, you’ll have a connection to a top-tier company. With your mindset ready, it’s time to dive in and do the work. If you follow our advice, you’ll get an order of magnitude more responses than from applying online, and with this approach, you’ll have at least a hiring manager at that company rooting for you!",
      "content_type": "pdf",
      "source_url": "/Users/nslittle/Desktop/Life/coding/aline-scraper/pdfs/Sneak Peek BCTCI - First 7 Chapters - What's Broken About Coding Interviews, What Recruiters Won't Tell You, How to Get In the Door, and more - June 2025 (1).pdf",
      "author": "",
      "user_id": ""
    }
  ]
}
