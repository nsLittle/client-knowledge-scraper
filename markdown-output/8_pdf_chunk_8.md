# PDF Chunk 8

arr = [6, 5, 4, 7, 9] Output: 4 ▶Example: arr = [5, 6, 7] Output: 5. The prefix sorted in decreasing order is just [5]. ▶Example: arr = [7, 6, 5] Output: 5. The suffix sorted in increasing order is just [5]. PROBLEM 29.4 2"ARRAY 2"SUM Yo u a r e g i v e n t w o n o n - e m p t y a r r a y s o f i n t e g e r s , sorted_arr and unsorted_arr. The ! rst one is sorted, but the second is not. The goal is to ! nd one element from each array with sum 0. If you can ! nd them, return an array with their indices, starting with the element in sorted_arr. Otherwise, return [-1, -1]. Use O(1) extra space and do not modify the input. ▶Example: sorted_arr = [-5, -4, -1, 4, 6, 6, 7] unsorted_arr = [-3, 7, 18, 4, 6] Output: [1, 3]. We can use -4 from the sorted array and 4 from the unsorted array. PROBLEM 29.5 T A R G E T C O U N T D I V I S I B L E B Y K Given a sorted array of integers, arr, a target value, target, and a positive integer, k, return whether the number of occurrences of the target in the array is a multiple of k. ▶Example: arr = [1, 2, 2, 2, 2, 2, 2, 3] target = 2, k = 3 Output: True. 2 occurs 6 times, which is a multiple of 3. ▶Example: arr = [1, 2, 2, 2, 2, 2, 2, 3] target = 2, k = 4 Output: False. 2 occurs 6 times, which is not a multiple of 4. ▶Example: arr = [1, 2, 2, 2, 2, 2, 2, 3] target = 4, k = 3 Output: True. 4 occurs 0 times, and 0 is a multiple of any number. PROBLEM 29.6 R A C E O V E R T A K I N G Yo u a r e g i v e n t w o a r r a y s o f p o s i t i v e i n t e g e r s , p1 and p2, representing players in a racing game. The two arrays are sorted, non-empty, and have the same length, n. The i-th element of each array corresponds to where that player was on the track at the i-th second of the race. We know that: 1. player 1 started ahead (p1[0] > p2[0]), 2. player 2 overtook player 1 once, and 3. player 2 remained ahead until the end (p1[n - 1] < p2[n - 1]). Assume the arrays have no duplicates, and that p1[i] != p2[i] for any index. Return the index at which player 2 overtook player 1. ▶Example: p1 = [2, 4, 6, 8, 10], p2 = [1, 3, 5, 9, 11] CHAPTER 29 ▸ BINARY SEARCH 335 Output: 3 PROBLEM 29.7 S E A R C H I N S O R T E D G R I D Yo u ' r e g i v e n a 2 D g r i d o f i n t e g e r s , grid, where each row is sorted (without duplicates), and the last value in each row is smaller than the ! rst value in the following row. You are also given a target value, target. If the target is in the grid, return an array with its row and column indices. Otherwise, return [-1, -1]. ▶Example: target = 4 grid = [[1, 2, 4, 5], [6, 7, 8, 9]] Output: [0, 2]. The number 4 is found in row 0 column 2. ▶Example: target = 3 grid = [[1, 2, 4, 5], [6, 7, 8, 9]] Output: [-1, -1] PROBLEM 29.8 S E A R C H I N H U G E A R R A Y We are trying to search for a target integer, target, in a sorted array of positive integers (duplicates allowed) that is too big to ! t into memory. We can only access the array through an API, fetch(i), which returns the value at index i if i is within bounds or -1 otherwise. Using as few calls to the API as possible, return the index of the target, or -1 if it does not exist. If the target appears multiple times, return any of the indices. There is no API to get the array's length. PROBLEM SET SOLUTIONS SOLUTION 29.3 V A L L E Y B O T T O M This problem shows that binary search can be used even if the input array is not monotonically sorted. Intuitively, we want to de! ne the 'before' region as the descending pre! x and the 'after' region as the ascend- ing su# x. The tricky part is that an array like [6, 5, 4, 7, 9] can be formed in two ways: •With a descending pre! x [6, 5, 4] and an ascending su# x [7, 9]. •With a descending pre! x [6, 5] and an ascending su# x [4, 7, 9]. We need a clear rule for how to de! ne is_before(). For instance, if we want the 4 to be in the 'before' region, we can say that a number is in the 'before' region if (a) it is the ! rst element, or (b) it's smaller than the previous element. This de! nition is workable, but according to it, an array like [7, 6, 5] only contains 'before' elements; we need to check for that case during preprocessing. With this de! nition, elements in the ‘after’ region are always greater than the previous element, so the small- est value in the entire array will be the last one in the ‘before’ region. 1 def valley_min_index(arr): 2 def is_before(i): 3 return i == 0 or arr[i]