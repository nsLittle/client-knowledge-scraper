# PDF Chunk 5

quiz! Here is an attempted solution, but it has a bug. Can you spot it? 1 def BUGGED_binary_search(arr, target): # DON'T USE IN INTERVIEWS! 2 l, r = 0, len(arr) 3 while l <= r: 4 mid = (l + r) // 2 5 if mid == target: 6 return mid 7 if target > mid: 8 r = mid+1 9 else: 10 l = mid-1 11 return -1 CHAPTER 29 ▸ BINARY SEARCH 327 Check the solution in the footnote. 1 Regardless of what you found, the point is that it is easy to miss errors in a binary search implementation. Here is one way to do it correctly: 1 def binary_search(arr, target): 2 n = len(arr) 3 if n == 0: 4 return -1 5 l, r = 0, n - 1 6 if arr[l] >= target or arr[r] < target: 7 if arr[l] == target: 8 return 0 9 return -1 10 while r - l > 1: 11 mid = (l + r) // 2 12 if arr[mid] < target: 13 l = mid 14 else: 15 r = mid 16 if arr[r] == target: 17 return r 18 return -1 Figure 1. Binary search for target 3. We'll punt on breaking down this solution until we talk about our transition-point recipe (pg 330). BINARY SEARCH HAS SURPRISING APPLICATIONS Imagine that your bike had gotten stolen, and your only chance of getting it back hinged on your ability to explain binary search to a police o# cer. That is the very situation Tom Whipple, a science journalist, found himself in. 2 The rack from which the bike went missing was right under a security camera, but the police told him they didn't have the resources to watch many hours of footage just to identify when the bike was stolen. Tom explained that this wouldn't be necessary: they could skip ahead to the middle of the video and check if the bike was still there. If it was, the bike was stolen during the latter half; if not, it was stolen earlier. This could be repeated to quickly narrow down the time of the crime. In the end, the thief was never caught—the footage was too grainy. Regardless, the story showcases an unconventional use of binary search. We can formalize it into an interview question: PROBLEM 29.2 C C T V F O O T A G E You are given an API called is_stolen(t) which takes a timestamp as input and returns True if the bike is missing at that timestamp and False if it is still there. You're also given two timestamps, t1 and t2, representing when you parked the bike and when you found it missing. Return the timestamp when the bike was ! rst missing, minimizing the number of API calls. Assume that 0 < t1 < t2, is_stolen(t1) is False, and is_stolen(t2) is True. 1 We were not completely honest—there isn't just one bug; there are closer to six, depending on how you count them. (1) r is initialized out of bounds, (2 & 3) we check mid instead of arr[mid] (twice!), (4) we update r when we should be updating l, (5) l should be set to mid+1, not mid-1, and (6) r should be set to mid-1, not mid+1. 2 https://www.thetimes.com/article/i-have-owned-11-bikes-this-is-how-they-were-stolen-d3r553gx3 328 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co Figure 2. SOLUTION 29.2 CCTV FOOTAGE This problem is quite di" erent from Problem 29.1: Search In Sorted Array (pg 326): it doesn't have an array input, and we don't have a target value. In fact, if we tried to use the same binary search code from earlier, we'd have to change almost every line in the algorithm before it would work correctly. That many tweaks make it easy to reintroduce bugs. Nonetheless, we can still use binary search because the range of possible answers can be broken down into two regions: (1) before the bike was stolen and (2) after it was stolen. We are searching for the transition point from 'before' to 'after’: Figure 3. Initially, we don't know where the transition point is, but we can binary search for it: Figure 4. 1 def is_before(val): 2 return not is_stolen(val) 3 4 def fi nd_bike(t1, t2): 5 l, r = t1, t2 6 while r - l > 1: 7 mid = (l + r) // 2 8 if is_before(mid): 9 l = mid 10 else: CHAPTER 29 ▸ BINARY SEARCH 329 11 r = mid 12 return r At the beginning, l is in the 'before' region, and r is in the 'after' region. From there, l never leaves the 'before' region and r never leaves the 'after' region, but they end up next to each other: at the end, l is the last 'before' and r is the ! rst 'after.' Here is the kicker: every binary search solution can be reframed as ! nding a transition point. For instance, Problem 29.1: Search In Sorted Array can be reframed as ! nding the "transition point" from elements smaller than target to elements greater than or equal to target. If we learn a recipe for ! nding transition points, we'll be able to use it for every binary search problem. We don't need specialized recipes for various problem types. T R A N S I T I O N $P O I N T R E C I P E In an important interview—with tensions mounting and anxiety running high—you are not working at total capacity. We joke that you are ~20% dumber than during practice. To counter this, it helps to have a recipe you know well for tricky algorithms like binary search. A good recipe should be easy to remember, have straightforward edge cases, and make it easy to avoid o" -by-one errors. RECIPE 1. TRANSITION"POINT RECIPE transition_point_recipe() defi ne is_before(val) to return whether val is 'before' initialize l and r to