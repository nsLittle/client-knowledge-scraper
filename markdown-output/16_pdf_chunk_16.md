# PDF Chunk 16

problem, we said that all the titles would have length at most 100, so the space complexity is O(100 * k) = O(k). 516 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co 1 def max_no_bad_days(sales): 2 l, r = 0, 0 3 cur_max = 0 4 while r < len(sales): 5 can_grow = sales[r] >= 10 6 if can_grow: 7 r += 1 8 cur_max = max(cur_max, r - l) 9 else: 10 l = r+1 11 r = r+1 12 return cur_max Figure 3. Illustration of the sliding window for max_no_bad_days(). Unlike in the ! xed-length window case, a resetting window stays valid throughout the algorithm. We also introduced a can_grow variable to decide whether to growor reset. 6 When sales[r] is a bad day, we reset the window by moving both l and r past the problematic element. Once the window cannot grow anymore (r == len(sales)), we stop, as we surely won't ! nd a bigger window by shrinking it. We can put these ideas together in a general recipe for resetting window problems. RECIPE 2. RESETTING WINDOW RECIPE. resetting_window(arr): initialize: - l and r to 0 (empty window) - data structures to track window info - cur_best to 0 while we can grow the window (r < len(arr)) if the window is still valid with one more element grow the window (update data structures and increase r) update cur_best if needed else reset window and data structures past the problematic element return cur_best Now that we have seen two types of sliding windows, it is worth mentioning that problems can ! t the criteria for more than one window type. Recall Problem 38.4: "Given the array best_seller and a number k with 1 ≤ k ≤ len(sales), return whether there is any k-day period where every day has thesame best-selling title." We can solve it with a ! xed-length window like we saw, or with a resetting window: 6 You could skip declaring the variable can_grow and put the condition directly in the if statement, but the name "can_grow" makes it clear what the if/else cases correspond to, so it is extra easy for the interviewer to follow. CHAPTER 38 ▸ SLIDING WINDOWS 517 We grow the window when it is (a) empty or (b) the next title is the same as every element in the window. We reset the window when the next element is di" erent from the ones in the window. In that case, rather than skipping over the element that is di" erent; we start growing a new window from that new element. 1 def has_enduring_best_seller_streak(best_seller, k): 2 l, r = 0, 0 3 cur_max = 0 4 while r < len(best_seller): 5 can_grow = l == r or best_seller[l] == best_seller[r] 6 if can_grow: 7 r += 1 8 if r - l == k: 9 return True 10 else: 11 l = r 12 return False This solution improves the extra space to O(1). RESETTING WINDOWS PROBLEM SET Try these problems with AI Interviewer: bctci.co/sliding-windows-problem-set-2 PROBLEM 38.6 M A X S U B A R R A Y S U M Given a non-empty array arr of integers (which can be negative), ! nd the non-empty subarray with the maximum sum and return its sum. ▶Example: arr = [1, 2, 3, -2, 1] Output: 6. The subarray with the maximum sum is [1, 2, 3]. ▶Example: arr = [1, 2, 3, -2, 7] Output: 11. The subarray with the maximum sum is the whole array. ▶Example: arr = [1, 2, 3, -8, 7] Output: 7. The subarray with the maximum sum is [7]. ▶Example: arr = [-2, -3, -4] Output: -2. The subarray cannot be empty. PROBLEM 38.7 L O N G E S T A L T E R N A T I N G S E Q U E N C E Given the array sales, ! nd the longest sequence of days alternating between good days (at least 10 sales) and bad days (fewer than 10 sales). ▶Example: sales = [8, 9, 20, 0, 9] Output: 3. The only good day is day 2, so the subarray [9, 20, 0] alternates from bad to good to bad. ▶Example: arr = [0, 0, 0] Output: 1. Every day is bad, so we cannot find any pair of consecutive days that alternate. 518 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co PROBLEM SET SOLUTIONS SOLUTION 38.6 M A X S U B A R R A Y S U M This is such a classic problem that the resetting window algorithm for it has its own name: Kadane's algorithm. Let's consider the logic for when to grow and shrink our window. If we encounter a positive number, we de! nitely want to grow the window, as it makes the window sum bigger. If we encounter a negative number, should we keep it and keep growing (as in Example 2), or should we reset the window past it (as in Example 3)? The answer depends on the sum of the window elements so far: • If our current window plus the negative element is still positive, it is worth keeping the current window even with the negative element. •If the negative element makes the window sum negative, it is not worth keeping; we should reset it. 7 1 def max_subarray_sum(arr): 2 max_val = max(arr) 3 if max_val <= 0: # Edge case without positive values. 4 return max_val 5 l, r = 0, 0 6 window_sum = 0 7 cur_max = 0 8 while r < len(arr): 9 can_grow = window_sum + arr[r] >= 0 10 if can_grow: 11 window_sum += arr[r] 12 r += 1 13 cur_max = max(cur_max, window_sum) 14 else: 15 window_sum = 0 16 l = r+1 17 r = r+1 18 return cur_max SOLUTION 38.7 L O N G