# PDF Chunk 14

time per iteration. As long as each iteration grows or shrinks the window (or both), a sliding window algorithm takes O(n*T) time, where n is the size of the array we are sliding over and T is the time per iteration. Typically, we will be unlikely to reduce the number of iterations—we must reach the end of the array—so we should focus on reducing T: the time per iteration. We should try to get it down to constant time. In terms of space analysis, remember that the window is not materialized, it is just identi! ed by the two pointers. So, the space analysis will depend on what other information about the window we need to store. FIXED$LENGTH WINDOWS In ! xed-length window problems, we have to ! nd a subarray under the constraint that it has a given length. Such problems, which are fairly common, are on the easier side because there are not many subarrays to consider: for a value k in the range 1 ≤ k ≤ n, an array only has n-k+1 = O(n) subarrays of length k—a lot fewer than O(n 2 ). Recall the ! rst opening problem: PROBLEM 38.1 M O S T W E E K L Y S A L E S Given an array, sales, ! nd the most sales in any 7-day period. ▶Example: sales = [0, 3, 7, 12, 10, 5, 0, 1, 0, 15, 12, 11, 1] 4 Our convention is that l is inclusive and r is exclusive, but this is merely our convention. If you prefer to consider r as inclusive, this is equally correct, but be sure to update the little details like the size of the window (which would now be r - l + 1). Whatever you do, be explicit about your convention and make sure the little details match. 512 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co Output: 44. The 7-day period with the most sales is [5, 0, 1, 0, 15, 12, 11] ▶Example: sales = [0, 3, 7, 12] Output: 0. There is no 7-day period. SOLUTION 38.1 M O S T W E E K L Y S A L E S The fact that we are only looking for windows of length 7 gives us a simple strategy for when to grow and shrink the window: 1. Grow the window until it has length 7. 2. Grow and shrink at the same time so that the length stays at 7. Here is a full solution: 1 def most_weekly_sales(sales): 2 l, r = 0, 0 3 window_sum = 0 4 cur_max = 0 5 while r < len(sales): 6 window_sum += sales[r] 7 r += 1 8 if r - l == 7: 9 cur_max = max(cur_max, window_sum) 10 window_sum -= sales[l] 11 l += 1 12 return cur_max Figure 2. The sliding window of most_weekly_sales(). On top of our window pointers, l and r, we have: • window_sum: the sum of elements in the window, which corresponds to the objective we have to maximize. The key is to update it whenever the window grows or shrinks and not compute it from scratch at each iteration. •cur_max: where we keep the current maximum we have seen so far. Each iteration starts by growing the window, which involves two things: updating window_sum to re% ect that sales[r] is now in the window, and increasing r. The order of these operations matters! After growing the window, we check if it is valid, meaning the window length (r - l) is 7. If it is valid, we check if it is the best one seen so far and update cur_max accordingly. CHAPTER 38 ▸ SLIDING WINDOWS 513 If the window has a length of 7, we end the iteration by shrinking it so that when we grow it in the next itera- tion, it will have the right size again. Like growing, shrinking consists of two actions: updating window_sum and increasing l. The algorithm ends when the window can no longer grow (r == len(sales)). We can put these ideas together in a general recipe for ! xed-length window problems: RECIPE 1. FIXED"LENGTH WINDOW RECIPE. fi xed_length_window(arr, k): initialize: - l and r to 0 (empty window) - data structures to track window info - cur_best to 0 while we can grow the window (r < len(arr)) grow the window (update data structures and increase r) if the window has the correct length (r - l == k) update cur_best if needed shrink the window (update data structures and increase l) return cur_best By "data structures," we mean any information about the window that we need to maintain as we slide it in order to evaluate each window quickly. The data structures that we need change from problem to problem, and they could range from nothing at all to things like sets and maps. In the following problem set, you will have to consider what information to store about the window and how to update it e# ciently. # Maintaining information about the window as it slides is a key idea in designing e# cient sliding windows. NESTED LOOPS ARE TOO SLOW FOR SLIDING WINDOW QUESTIONS INTERVIEW REPLAY View Online:bctci.co/sliding-windows-replay-1 @ 10:36 - 47:30 The Question:Given an array of positive numbers and a positive number k, ! nd the maxi- mum sum of any contiguous subarray of size k. What You'll See:The candidate struggled to identify the problem as a sliding window prob- lem and coded the brute force instead of an optimal answer. Who:Interviewer: Software Engineer at FAANG+ Candidate: College student FIXED-LENGTH WINDOWS PROBLEM SET Try these problems with AI Interviewer: bctci.co/sliding-windows-problem-set-1 We will continue with the bookstore setting. In addition to the sales array, we have an array of strings, best_seller, with the title of the most sold book for each day. Constraints: sales and best_seller have a length of at most 10 6 .