# PDF Chunk 24

count 17 18 def count_exactly_k_drops(arr, k): 19 if k == 0: 20 return count_at_most_k_drops(arr, 0) 21 return count_at_most_k_drops(arr, k) - count_at_most_k_drops(arr, k-1) 22 23 def count_at_least_k_drops(arr, k): 24 n = len(arr) 25 total_count = n*(n+1)//2 26 if k == 0: 27 return total_count 28 return total_count - count_at_most_k_drops(arr, k-1) SOLUTION 38.23 COUNT SUBARRAYS WITH BAD DAYS IN RANGE The same idea for Exactly-K counting problems also applies to a range: 10 1 def count_bad_days_range(sales, k1, k2): 2 if k1 == 0: 3 return count_at_most_k_bad_days(sales, k2) 4 return count_at_most_k_bad_days(sales, k2) - 5 count_at_most_k_bad_days(sales, k1-1) SOLUTION 38.24 COUNT SUBARRAYS WITH ALL REMAINDERS Every number has a remainder of 0, 1, or 2 when divided by 3. The count of subarrays that have a number from each group is equal to the total number of subarrays (n*(n+1)/2) minus the subarrays that have numbers from at most 2 of those groups. For the latter, we use the at-most-k counting technique. 1 def count_all_3_groups(arr): 2 n = len(arr) 3 total_count = n * (n + 1) // 2 4 return total_count - count_at_most_2_groups(arr) 5 6 def count_at_most_2_groups(arr): 7 l, r = 0, 0 8 window_counts = {} 9 count = 0 10 while r < len(arr): 11 can_grow = arr[r] % 3 in window_counts or len(window_counts) < 2 10 This is the same logic behind how we use pre!x sums to answer range sum queries (pg 612). CHAPTER 38 ▸ SLIDING WINDOWS 535 12 if can_grow: 13 if not arr[r] % 3 in window_counts: 14 window_counts[arr[r] % 3] = 0 15 window_counts[arr[r] % 3] += 1 16 r += 1 17 count += r - l 18 else: 19 window_counts[arr[l] % 3] -= 1 20 if window_counts[arr[l] % 3] == 0: 21 del window_counts[arr[l] % 3] 22 l += 1 23 return count We could have made the code a bit more e#cient by replacing the dictionary with an array of length 3, since the set of keys that we are using is {0, 1, 2}. SOLUTION 38.25 COUNT GOOD SUBARRAYS WITH AT LEAST K SALES We can use the 'break down the problem' booster: 1. First, we can use a resetting window to !nd all maximal subarrays without any bad days. Then, we can focus on each subarray we found without worrying about bad days. 2. For each subarray, sub, from Step 1, we need to count the number of subarrays of sub with at least k total sales. To do this, we can use the trick for At-Least-K counting: counting the total number of subar- rays in sub and subtracting the number of subarrays in sub with at most k-1 total sales. KEY TAKEAWAYS If you want to try using a sliding window, your !rst goal should be identifying the constraint and the objective. Based on those, you can choose the most appropriate window type: see the !xed-length window recipe (pg 513), the resetting window recipe (pg 516), the maximum window recipe (pg 520), and the minimum window recipe (pg 526). Once you choose a recipe, the next question is: ▶What information do I need about the window to check its validity and evaluation e#ciently? Based on the answer, we will pick which window data structures to maintain as we slide the window (and remember, if you can't !nd appropriate window data structures, you can always try the binary search guess- and-check technique (pg 338). Finally, we implement the sliding window. We recommend following some conventions such as those described on page 511. Here are some edge cases to keep an eye for: •Make sure to consider the case where no valid window is found, especially for minimization problems. •Make sure not to shrink an empty window or grow a window past the end of the array. Even better, update your own personal Bug List (pg 172) with the edge cases that you tend to forget about. Counting problems are less common, but we can use the trick to adapt the maximum window recipe to At-Most-K counting problems (pg 530). For Exactly-K/At-Least-K counting problems, see the reusable idea for transforming them to At-Most-K problems (pg 532). For maximization problems without the maximum window property (pg 523) or minimization problems without the minimum window property (pg 526), sliding windows may be the wrong technique! Consider other techniques commonly used on subarray problems, like two pointers, pre!x sums, and dynamic programming. 536 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co Sliding window triggers: The input type is just an array of numbers or a string, and maybe a number. The lower bound is linear. Keywords: subarray, substring, length, contiguous, consecutive, range, longest, or shortest. At this point, you should be ready to start adding sliding window problems to your practice rotation. You can ! nd the problems in this chapter and additional problems in the companion AI interviewer. ONLINE RESOURCES Online resources for this chapter include: •A chance to try each problem in this chapter in AI Interviewer •Interview replays that show speci! c mistakes people make with sliding windows problems • Full code solutions for every problem in the chapter in multiple programming languages Try online at bctci.co/sliding-windows.