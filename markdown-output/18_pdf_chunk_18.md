# PDF Chunk 18

▶Example: projected_sales = [10, 5, 8], k = 1 Output: 2. We should boost day 1, resulting in [10, 10, 8] projected sales. PROBLEM 38.11 B O O S T I N G D A Y S M U L T I P L E T I M E S In Problem 38.9, what would change if the boost from the advertising campaign was only 1 book instead of 20, but you can boost the same day more than once? What is the maximum number of consecutive good days in a row we can get? ▶Example: projected_sales = [5, 5, 15, 0, 10], k = 12 Output: 3. We can reach 3 consecutive good ways in two ways: boosting days 0 and 1, so both reach 10 sales, or boosting day 3. ▶Example: projected_sales = [5, 5, 15, 0, 10], k = 15 Output: 4. We can boost days 1 and 3. PROBLEM 38.12 L O N G E S T P E R I O D A T "M O S T K D I S T I N C T Given an array of strings, best_seller, that lists the title of the most sold book for each day, and a number k ≥ 1, ! nd the maximum consecutive days with at most kdistinctbest-selling books. ▶Example: projected_sales = ["book1", "book1", "book2", "book1", "book3", "book1"], k = 2 Output: 4. The subarray ["book1", "book1", "book2", "book1"] contains only 2 distinct titles. Constraints:best_seller has a length of at most 10 6 , and each book title in best_seller has a length of at most 100. PROBLEM SET SOLUTIONS SOLUTION 38.9 A D C A M P A I G N B O O S T This problem introduces a new dimension: we need to make choices that "modify" the window that we are sliding over. This seems complicated at ! rst since there could be many choices. A naive solution would be to consider all possible sets of k days we could pick, but that would be very ine# cient. 8 The key for this type of problem is usually to use the REFRAME THE PROBLEM booster. We want to ! n d a w a y t o reframe it in a way that eliminates the choice aspect. For our problem, instead of choosingk days to turn from bad to good, we can look for the longest window with at mostk bad days because we can pick those bad days and turn them into good days. With this reframing, the question becomes just like Problem 38.8, which we solved previously, but with a generic limit of k bad days instead of 3. # When a problem asks you to choose k elements to change (or % ip, remove, etc.), the problem can often be reframed in terms of ! nding a window with at most k elements that need to be changed. 8 If k is a constant, the number of subsets of size k, denoted (n choose k), is O(n k ). The worst case is when k is n/2, as (n choose n/2) = O(2 n /√n). Once k gets larger than n/2, the number of possibilities starts decreasing. For instance, there are only n subsets of size n-1. 522 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALO G OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co SOLUTION 38.10 AD CAMPAIGN WITH SMALL BOOSTS We can REFRAME THE PROBLEM as: "!nd the longest window with at most k values between 5 and 9 and 0 values less than 5." Then, it becomes a standard maximum window problem. SOLUTION 38.11 BOOSTING DAYS MULTIPLE TIMES First, we never want to boost a day beyond 10 projected sales, since we only care about the day being 'good.' The 'cost' of turning a day with x sales into a good day is max(10-x, 0). Thus, we can REFRAME THE PROBLEM as: "Find the longest window where the sum of max(10-x, 0) over each element x in the window is at most k." Then, it becomes a standard maximum window problem. 1 def max_consecutive_with_k_boosts(projected_sales, k): 2 l, r = 0, 0 3 used_boosts = 0 4 cur_max = 0 5 while r < len(projected_sales): 6 can_grow = used_boosts + max(10 - projected_sales[r], 0) <= k 7 if can_grow: 8 used_boosts += max(10 - projected_sales[r], 0) 9 r += 1 10 cur_max = max(cur_max, r - l) 11 elif l == r: 12 r += 1 13 l += 1 14 else: 15 used_boosts -= max(10 - projected_sales[l], 0) 16 l += 1 17 return cur_max SOLUTION 38.12 LONGEST PERIOD AT"MOST K DISTINCT We need to keep track of the number of distinct books in the window. Again, we can use a frequency map from book titles in the window to their number of occurrences. When we shrink the window, if a count goes down to 0, we remove the corresponding key from the map. This way, the size of the map re%ects the number of distinct elements in the window, and the window is valid if the map's size is at most k. 1 def max_at_most_k_distinct(best_seller, k): 2 l, r = 0, 0 3 window_counts = {} 4 cur_max = 0 5 while r < len(best_seller): 6 can_grow = best_seller[r] in window_counts or len(window_counts) + 1 <= k 7 if can_grow: 8 if not best_seller[r] in window_counts: 9 window_counts[best_seller[r]] = 0 10 window_counts[best_seller[r]] += 1 11 r += 1 12 cur_max = max(cur_max, r - l) 13 else: 14 window_counts[best_seller[l]] -= 1 15 if window_counts[best_seller[l]] == 0: 16 del window_counts[best_seller[l]] 17 l += 1 18 return cur_max CHAPTER 38 ▸ SLIDING WINDOWS 523 LIMITATIONS OF MAXIMUM WINDOWS All the problems we solved with a maximum window (as well as a resetting window) have this property: Growing an invalid window never makes it valid. We call this the maximum window property, and it is critical—without it, the maximum window recipe may not work. The intuition is that, without