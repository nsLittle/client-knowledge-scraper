# PDF Chunk 22

this idea: 530 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co 1 def count_at_most_k_bad_days(sales, k): 2 l, r = 0, 0 3 window_bad_days = 0 4 count = 0 5 while r < len(sales): 1 can_grow = sales[r] >= 10 or 2 window_bad_days < k 3 if can_grow: 4 if sales[r] < 10: 5 window_bad_days += 1 6 r += 1 7 count += r - l 8 else: 9 if sales[l] < 10: 10 window_bad_days -= 1 11 l += 1 12 return count Figure 6. Sliding window for count_at_most_k_bad_days(sales, 2). Every time we grow the window, we show all the valid subarrays that we add to the running count (16 in total). Note that the code is exactly the same as max_at_most_3_bad_days() from the previous section except for computing count instead of cur_max (and k instead of 3). # If a problem has the maximum window property, the maximum window recipe also works for At-Most-K counting problems. Whenever we add an element to the window, we add to the running count all the valid subarrays ending at that element. Fortunately, At-Most-K counting problems are a bit of a 'freebie' because we can reuse the maximum window recipe. In the next section, we'll see a trick that makes Exactly-K counting problems equally easy! As mentioned, this only works if the problem has the maximum window property. For instance, if we allow negative numbers in the array in this problem, we cannot use the algorithm anymore. EXACTLY-K COUNTING PROBLEM 38.19 C O U N T S U B A R R A Y S W I T H E X A C T L Y K B A D D A Y S Given an array, sales, count the number of subarrays with exactlyk bad days (days with fewer than 10 sales). ▶Example: sales = [0, 20, 5], k = 1 Output: 4. The subarrays [0], [0, 20], [20, 5], and [5] have 1 bad day each. SOLUTION 38.19 C O U N T S U B A R R A Y S W I T H E X A C T L Y K B A D D A Y S This time, we will start with the solution and then break it down: 1 def count_exactly_k_bad_days(sales, k): 2 if k == 0: 3 return count_at_most_k_bad_days(sales, 0) 4 return count_at_most_k_bad_days(sales, k) - CHAPTER 38 ▸ SLIDING WINDOWS 531 5 count_at_most_k_bad_days(sales, k-1) We re-used the At-Most-K counting function count_at_most_k_bad_days() from the previous section. For k == 0, 'at most 0' and 'exactly 0' are the same. For k == 1, the code works because the number of subarrays with exactly 1 bad day is equal to the number of subarrays with at most 1 bad day (meaning 0 or 1 bad days) minus the number of subarrays with at most 0 bad days. This applies to any higher k as well! For example, Figure 7 shows an example sales array and all 16 subarrays with at most 2 bad days. Of those, 10 have at most 1 bad day, meaning there are 16 - 10 = 6 subarrays with exactly 2 bad days. By the same logic, there are 10 - 2 = 8 subarrays with exactly 1 bad day. Figure 7. The set of all subarrays with at most 2 bad days, which contains the set of subarrays with at most 1 bad day, which contains the set of subarrays with no bad days. Since we need to make two calls to the At-Most-K solution, the runtime is twice as long, which is still O(n). Exactly-K counting problems can also be solved in linear time with pre! x sums: see Problem 38.6: Max Subarray Sum (pg 517). The pre! x-sums approach works even if the array has negative numbers. AT -L E A S T -K CO U N T I N G PROBLEM 38.20 COUNT SUBARRAYS WITH AT LEAST K BAD DAYS Given an array, sales, count the number of subarrays with at leastk bad days (days with fewer than 10 sales). ▶Example: sales = [0, 20, 5], k = 1 Output: 5. The subarrays [0], [0, 20], [20, 5], and [5] have 1 bad day each, and the subarray [0, 20, 5] has 2. SOLUTION 38.20 C O U N T S U B A R R A Y S W I T H A T L E A S T K B A D D A Y S We will see how to reuse the At-Most-K counting solution once again. First, we need to know the total number of subarrays. What's the total number of subarrays? An array of length n has (n+1)*n/2 non-empty subarrays. Each subarray is de! ned by a pair of indices, [start, end]. There are n 2 [i, j] pairs where i and j are valid indices (0 ≤ i, j < n). Of those, there are n pairs where i == j, which de! ne single-element subarrays. Of the remaining n 2 - n pairs, half have i < j and half have i > j. 532 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co The latter half does not identify valid subarrays, so we don't count them. In total, we have n + (n 2 - n)/2 = (n+1)*n/2 subarrays. The subarrays with at least k bad days are those with k bad days, those with k+1 bad days, those with k+2 bad days, and so on. Therefore, to count the subarrays with at least k bad days, we can start with the count of allsubarrays (of which there are n*(n+1)/2) and subtract the number of subarrays with at most k-1 bad days. Something we already saw how to compute! 1 def count_at_least_k_bad_days(sales, k): 2 n = len(sales) 3 total_subarrays = n*(n+1)//2 4 if k == 0: 5 return total_subarrays 6 return total_subarrays -