# PDF Chunk 4

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .629 Reference Materials . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .630 My Notes & Reminders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .639 You can access all of our online materials and bonus chapters here: Talk with the authors, get help if you're stuck, and geek out with us on Discord. bctci.cobctci.co/discord Get $50 Off on Mock Interviews Practice anonymously on interviewing.io with FAANG interviewers: bctci.co/discount-X3A4 I TECHNICAL README This chart represents how we see the landscape of interview questions: Figure 1. Landscape of Interview Questions, for someone who prepares with BCtCI. Our goal with this book is twofold: 1. Teach you the 80% most common topics and ideas used in interview problems. That's what Part VII: The Catalog of Technical Topics, is all about. The remaining 20% are niche topics. PRINCIPLES AND CATALOG ▸ TECHNICAL README 169 2. Teach you problem-solving strategies so you can ! gure out 80% of questions on your own, even if you haven't seen the idea before. This is what the problem-solving boosters (Chapter 24: Problem-Solving Boosters, pg 249) are for. The remaining 20% of questions rely on tricks (ideas that are really hard to come up with on your own if you haven't seen them before). 1 Combining these two, after going through the book, you should be able to tackle all but 20% * 20% = 4% of questions, which are those based on niche topics and requiring tricks. But if that happens, you've been truly unlucky. THE PRINCIPLES AND THE CATALOG Besides solving problems, we want to help you practice e" ectively and know how to navigate an interview setting. This is covered in Part VI: Principles of Coding Interviews (pg 166). It includes: •Study Plan: A detailed study plan for how to practice using this book's materials. •Universal Rubric: How you're evaluated by interviewers. •Interview Checklist: Breaking down each step you should take in a coding interview. •Big-O Analysis: In-depth coverage of the "language" of technical interviews. •Problem-Solving Strategies: Boundary thinking, trigger thinking, and problem-solving boosters. The second part is a Catalog of data structures and algorithms topics. We've broken the technical topics into tiers, with Tier 1 being the highest priority. •Tier 1: Essential topics from sets & maps to trees and graphs. •Tier 2: Intermediate topics like heaps, sliding windows, and pre! x sums. • Tier 3: Niche (online-only) topics that didn't warrant a spot in the physical book because they don’t come up that often (this is where we enter the niche 20% territory). The online-only chapters can be found at bctci.co/bonus. Chapter 18: How to Practice (pg 170) should be your entry point to the rest of the book. TOPICS, RECIPES, AND REUSABLE IDEAS There are three related concepts you'll ! nd as you peruse the Catalog: topics, reusable ideas, and recipes. Here's a quick de! nition to keep them straight: •Topic: A chapter from the Catalog, like Binary Search. • Reusable Idea: A coding idea that can typically be used across problems (and even across topics). They are tactical tips worth remembering, such as "pass indices, not strings in recursive code to avoid using extra space." You'll typically ! nd them next to the ! rst problem where they are used (look for the icon). •Coding Recipe: A pseudo-code template related to a speci! c topic that can be used as a building block to solve similar problems with small tweaks. Questions, comments, or bugs? Report bugs at bctci.co/bugs or geek out with the authors on Discord: bctci. co/discord. 1 Our mantra? If you encounter something once, it’s a trick; if you encounter it repeatedly, it’s a tool. CHAPTER 29 A I interviewer, replays, and more materials for this chapter at bctci.co/binary-search I CHAPTER 29 I CHAPTER 29 II BINARY SEARCH ▶Prerequisites: None When it comes to binary search, software engineers are split in half: One camp thinks it's too basic to be an interview question, and the other dreads it because they always mess up the index manipulation. The ! rst group overlooks the fact that binary search has many uses beyond the basic "! nd a value in a sorted array." Far from it, binary search has many non-obvious applications, which we'll cover in this chapter. For the second group, we'll provide a recipe focusing on simplicity and reusability across applications—even the unconventional ones we just foreshadowed. BINARY SEARCH IS EASY TO MESS UP Let's start with something simple—the classic binary search setting—and then build up to harder problems. PROBLEM 29.1 S E A R C H I N S O R T E D A R R A Y Given a sorted array of integers, arr, and a target value, target, return the target's index if it exists in the array or -1 if it doesn't. ▶Example: arr = [-2, 0, 3, 4, 7, 9, 11], target = 3 Output: 2. ▶Example: arr = [-2, 0, 3, 4, 7, 9, 11], target = 2 Output: -1. SOLUTION 29.1 S E A R C H I N S O R T E D A R R A Y We assume most engineers are familiar with the basic premise of binary search: two pointers move inward from the ends of a sorted array, closing in on the target by checking if the midpoint is too small or too large. Pop