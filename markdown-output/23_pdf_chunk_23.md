# PDF Chunk 23

count_at_most_k_bad_days(sales, k-1) #If the At-Most-K version of a counting problem has the maximum window property, it can be reused to solve the At-Least-K version. REUSABLE IDEA: TRANSFORM EXACTLY-K/AT-LEAST-K COUNTING TO AT-MOST-K COUNTING If the At-Most-K version of a counting problem has the maximum window property, it can be reused to solve the Exactly-K and At-Least-K versions. 1. 'Exactly k' is equivalent to 'at most k' minus 'at most k - 1'. 2. 'At Least k' is equivalent to 'total count' (n*(n+1)/2) minus 'at most k - 1'. The At-Most-K version can be solved by tweaking the maximum window template, as in Solution 18. There are counting problems that do not ! t into any of the At-Most-K / Exactly-K / At-Least-K categories. We should tackle such problems on a case-by-case basis. Here is an example: PROBLEM 38.21 C O U N T S U B A R R A Y S W I T H G O O D S T A R T A N D E N D I N G Given an array, sales, return the number of subarrays that start and end on a good day (a day with at least 10 sales). SOLUTION 38.21 C O U N T S U B A R R A Y S W I T H G O O D S T A R T A N D E N D I N G For this particular problem, the key property to leverage is that each distinct pair of good days in sales contributes 1 to the ! nal count. Thus, the answer is g*(g + 1)/2, where g is the number of good days in sales. COUNTING PROBLEM SET Try these problems with AI Interviewer: bctci.co/sliding-windows-problem-set-5 PROBLEM 38.22 C O U N T S U B A R R A Y S W I T H D R O P S Given an array of integers, arr, and an integer k, count how many subarrays have (1) at most k drops, (2) exactly k drops, and (3) at least k drops. A drop is a sequence of two consecutive numbers where the ! rst is larger than the second. ▶Example: arr = [1, 2, 3], k = 1 Output: (1) 6. The array has no drops, so every subarray has 0 drops. CHAPTER 38 ▸ SLIDING WINDOWS 533 (2) 0. The array has no drops. (3) 0. The array has no drops. ▶Example: arr = [3, 2, 1], k = 1 Output: (1) 5. [3, 2] and [2, 1] have 1 drop and [3], [2], and [1] have 0 drops. (2) 2. [3, 2] and [2, 1] have exactly 1 drop. (3) 3. [3, 2] and [2, 1] have 1 drop and [3, 2, 1] has 2 drops. PROBLEM 38.23 C O U N T S U B A R R A Y S W I T H B A D D A Y S I N R A N G E Given the array sales and two numbers k1 and k2 with 0 ≤ k1 ≤ k2, count the number of subarrays with at leastk1 bad days and at mostk2 bad days (days with fewer than 10 sales). ▶Example: sales = [0, 20, 5], k1 = 2, k2 = 2 Output: 1. [0, 20, 5] has 2 bad days. ▶Example: sales = [0, 20, 5], k1 = 1, k2 = 2 Output: 5. [0, 20, 5] has 2 bad days, and [0], [0, 20], [20, 5], and [5] have 1 bad day. PROBLEM 38.24 C O U N T S U B A R R A Y S W I T H A L L R E M A I N D E R S Given an array of positive integers, arr, return the number of subarrays that have at least one of each of the following: •a multiple of 3, •a number with remainder 1 when divided by 3, and •a number with remainder 2 when divided by 3. ▶Example: arr = [9, 8, 7] Output: 1. [9, 8, 7] counts because 9 % 3 is 0, 7 % 3 is 1, and 8 % 3 is 2. ▶Example: arr = [1, 2, 3, 4, 5] Output: 6. The subarrays are [1, 2, 3], [2, 3, 4], [3, 4, 5], [1, 2, 3, 4], [2, 3, 4, 5], and [1, 2, 3, 4, 5]. ▶Example: arr = [1, 3, 4, 6, 7, 9] Output: 0. There are no numbers with remainder 2 when divided by 3. PROBLEM 38.25 C O U N T G O O D S U B A R R A Y S W I T H A T L E A S T K S A L E S Given an array, sales, and a positive integer k, return the number of subarrays with no bad days and at least k total sales (bad days are days with fewer than 10 sales). ▶Example: arr = [15, 20, 5, 30, 25], k = 50 Output: 1. The subarrays with no bad days are [15], [15, 20], [20], [30], [30, 25], and [25]. Of those, only [30, 25] has at least 50 sales. PROBLEM SET SOLUTIONS SOLUTION 38.22 C O U N T S U B A R R A Y S W I T H D R O P S This is a direct application of the techniques we discussed. 1 def count_at_most_k_drops(arr, k): 2 l, r = 0, 0 534 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALO G OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co 3 window_drops = 0 4 count = 0 5 while r < len(arr): 6 can_grow = r == 0 or arr[r] >= arr[r-1] or window_drops < k 7 if can_grow: 8 if r > 0 and arr[r] < arr[r-1]: 9 window_drops += 1 10 r += 1 11 count += r - l 12 else: 13 if arr[l] > arr[l+1]: 14 window_drops -= 1 15 l += 1 16 return