# PDF Chunk 15

Each book title in best_seller has a length of at most 100. 514 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co PROBLEM 38.2 M O S T S A L E S I N K D A Y S Given the array sales and a number k with 1 ≤ k ≤ len(sales), ! nd the most sales in any k-day period. Return the ! rst day of that period (days start at 0). If there are multiple k-day periods with the most sales, return the ! rst day of the ! rst one. ▶Example: sales = [8, 1, 3, 7], k = 2 Output: 2. The subarray of length 2 with maximum sum is [3, 7], which starts at index 2. PROBLEM 38.3 U N I Q U E B E S T S E L L E R S T R E A K Given the array best_seller and a number k with 1 ≤ k ≤ len(sales), return whether there is any k-day period where each day has a di" erent best-selling title. ▶Example: best_seller = ["book3", "book1", "book3", "book3", "book2", "book3", "book4", "book3"], k = 3 Output: True. There is a 3-day period without a repeated value: ["book2", "book3", "book4"]. ▶Example: best_seller = ["book3", "book1", "book3", "book3", "book2", "book3", "book4", "book3"], k = 4 Output: False. There are no 4-day periods without a repeated value. PROBLEM 38.4 E N D U R I N G B E S T S E L L E R S T R E A K Given the array best_seller and a number k with 1 ≤ k ≤ len(sales), return whether there is any k-day period where every day has thesame best-selling title. ▶Example: best_seller = ["book3", "book1", "book3", "book3", "book2"], k = 3 Output: False. ▶Example: best_seller = ["book3", "book1", "book3", "book3", "book2"], k = 2 Output: True. PROBLEM SET SOLUTIONS SOLUTION 38.2 M O S T S A L E S I N K D A Y S We can reuse our solution to the previous problem, tweaking it slightly: replacing 7 with k and tracking the position of the best window in addition to its sum. SOLUTION 38.3 U N I Q U E B E S T S E L L E R S T R E A K In this problem, we need to check each window of length k for duplicate titles. Checking for duplicates in an array can be done in linear time using a hash map, assuming we can hash each element in constant time (recall that 'checking for duplicates' is a trigger for hash sets and maps). As mentioned, e# cient sliding window algorithms usually maintain information about the window. In this case, the information we need is a frequency map (the reusable idea from pg 348): a hash map from the titles in the window to the number of times that they appear in the window. So, for a window like ["book3", "book1", "book3"], the map would be {"book3": 2, "book1": 1}. We can update this map in O(1) time whenever the window grows or shrinks. CHAPTER 38 ▸ SLIDING WINDOWS 515 We remove book titles from the map if their count goes back down to 0. This way, the size of the map always represents the number of unique keys (book titles) in the window, and the window satis! es the constraint if the map size is k. The extra space of our solution is O(k). 5 1 def has_unique_k_days(best_seller, k): 2 l, r = 0, 0 3 window_counts = {} 4 while r < len(best_seller): 5 if not best_seller[r] in window_counts: 6 window_counts[best_seller[r]] = 0 7 window_counts[best_seller[r]] += 1 8 r += 1 9 if r - l == k: 10 if len(window_counts) == k: 11 return True 12 window_counts[best_seller[l]] -= 1 13 if window_counts[best_seller[l]] == 0: 14 del window_counts[best_seller[l]] 15 l += 1 16 return False #Frequency maps are often useful in sliding window problems. SOLUTION 38.4 E N D U R I N G B E S T S E L L E R S T R E A K This problem can be solved exactly the same way as the previous one, just by changing the window validity condition from len(window_counts) == k to len(window_counts) == 1. However, this solution requires O(k) extra space for the frequency map. Can you think of a constant-space solution? We'll see one in the next section about the next type of sliding windows: resetting windows. RESETTING WINDOWS We call the next type of sliding window "resetting windows." It is for problems where a bigger window is usually better, but a singleelement in the array can make the whole window invalid. Our approach will be simple: grow the window if we can, and otherwise reset it to empty past the problematic element. Recall the second opening bookstore problem: PROBLEM 38.5 L O N G E S T G O O D D A Y S T R E A K Given an array, sales, ! nd the most consecutive days with no bad days (fewer than 10 sales). ▶Example: sales = [0, 14, 7, 12, 10, 20] Output: 3. The subarray [12, 10, 20] has no bad days. SOLUTION 38.5 L O N G E S T G O O D D A Y S T R E A K This is a resetting window problem because if we encounter a bad day, whatever window we have so far needs to be discarded. This gives us a simple strategy for when to grow and shrink the window: 1. If the next day is good, grow the window. 2. If the next day is bad, skip it and reset the window. 5 Don't forget that when storing strings in a map, the space complexity of the map is not just the number of strings, as we also need to factor in the length of the strings. For this