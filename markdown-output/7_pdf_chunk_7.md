# PDF Chunk 7

A R E S T E L E M E N T In a sorted array of integers (duplicates allowed), ! nd the last occurrence of a given target value. If the target does not exist, return the index of the next closest value (it could be smaller or larger than the target). [1, 3, 5, 6, 7, 7, 8, 11, 13, 21], target = 7 QUESTION 6 DECK CUT Yo u ' r e g i v e n a n a r r a y t h a t c o n t a i n s e a c h n u m b e r f r o m 1 to 52 once, representing a deck of playing cards. The deck started in order, but it was then "cut," meaning that a random number of cards was taken from the top (the front of the array) and moved as a block to the bottom (the back of the array). Determine the index where you must "cut" the deck again to return to sorted order (that is, the index with the 52). [36, 37, 38, ..., 50, 51, 52, 1, 2, 3, ..., 33, 34, 35] PROBLEM SET SOLUTIONS In the solutions below, we circled which of the two pointers we should return at the end. ANSWER 1 GIT COMMITS 332 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co ANSWER 2 SQUARED TARGET We should return arr[l], since the last number in the 'before' region is the largest number that still works. ANSWER 3 FIRST NON"NEGATIVE Including 0 in the 'before' region would be a mistake: if there are multiple zeros, l would point to the last one, but the goal is to return the ! rst one. ANSWER 4 FIRST 'P' The ‘before’ region consists of words that start with a–o and the ‘after’ region consists of words that start with p–z. If there are words that start with ‘p’, the ! rst one will be at index r. Including words that start with 'p' in the 'before' region would be incorrect: if we inserted another word starting with 'p,' like "pear," l would point to the last word starting with 'p' rather than the ! rst one. ANSWER 5 NEAREST ELEMENT Post-processing requires a bit of thought. If the target is in the array, it will be at l. We can peek at arr[l] and return l if it is the target. Otherwise, we need to ! nd the closest value to it, which could be at l or r. We return either l or r, based on whether arr[l] or arr[r] is closer. ANSWER 6 DECK CUT Trick question! This doesn' t require binar y search as the answer is always 52 - deck[0]. Still, we could ! nd the transition point from 52 back to 1 with a binary search. The 'before' region would be numbers ≥deck[0]. The l pointer would end up at the 52 and the r pointer at the 1. We would return l. VALIDATION & DRAWING ADVICE Visualizing the binary search in an interview is helpful both for you and your interviewer. Instead of trying to verbally explain what you're doing, show them in the shared editor. Our suggestions are similar to the Two Pointers chapter (pg 296): CHAPTER 29 ▸ BINARY SEARCH 333 •Write each pointer (l, r, and m for the midpoint) on its own line so you can move them independently with ease. •Writing indices on the top of the array makes it faster to do midpoint calculations. •You can also draw the transition point between 'before' and 'after.' Instead ofTr y [1, 2, 2, 3, 3, 4, 5, 8, 8] ^ ^ ^ left mid right 0 1 2 3 4 5 6 7 8 [1 2 2 3 3 4|5 8 8] l r m m = (0+8)/2 So, which inputs should you validate and visualize? Consider the following edge cases, when applicable: •The range is empty. •The range only has 'before' elements. •The range only has 'after' elements. •The target is not in the array. •The target is in the array multiple times. ANALYSIS But o# cer, it is O(log n)! In the Big O analysis chapter , we de! ned log 2 (n) as roughly the number of times we need to halve a number to reach 1. Binary search halves the search range at each step, so binary search converges in O(log n) iterations, where n is the size of the range (e.g., t2 - t1 in Problem 29.2: CCTV Footage (pg 327). 5 Some binary search implementations stop early when arr[mid] == target. For simplicity, our recipe doesn't have that, which means that it takes O(log n) time even in the best case. That's ! ne—we mainly care about the worst case. Don't forget to factor in the time it takes to compute is_before() in the runtime calculation if it is not constant! Finally, the extra space is O(1). Binary search can also be implemented recursively, in which case the extra space increases to O(log n) for the call stack. BINARY SEARCH PROBLEM SET Try these problems with AI Interviewer: bctci.co/binary-search-problem-set-1 Let's tackle some problems that require creative approaches for using binary search. The transition-point recipe should prove useful! PROBLEM 29.3 V A L L E Y B O T T O M A valley-shaped array is an array of integers such that: •it can be split into a non-empty pre! x and a non-empty su# x, •the pre! x is sorted in decreasing order, 5 See page 219 for why we "drop" the base of the logarithm in big O notation. 334 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co •the su# x is sorted in increasing order, •all the elements are unique. Given a valley-shaped array, arr, return the smallest value. ▶Example: