# PDF Chunk 12

return num_pours * b <= a 5 6 # Exponential search (repeated doubling until we find an upper bound). 7 k = 1 8 while is_before(k * 2): 9 k *= 2 10 11 # Binary search between k and k*2 12 l, r = k, k * 2 13 while r-l > 1: 14 gap = r - l 15 half_gap = gap >> 1 # Bit shift instead of division 16 mid = l + half_gap 17 if is_before(mid): 18 l = mid 19 else: 20 r = mid 21 return l SOLUTION 29.11 MIN PAGES PER DAY For a given value daily_limit, we pose the question: Can I !nish all the chapters in time reading at most daily_limit pages a day? We can guess and check for the answer to this question. Since we can only !nish one chapter per day, the maximum answer is the longest chapter (20 pages in the example). The minimum is 1 page per day. We can binary search between these bounds and simulate reading the guessed amount of pages per day. If the guess allows us to !nish within the given days, we try a smaller number. If it takes too many days, we try a larger number. 1 def days_to_finish(page_counts, daily_limit): 2 days = 0 3 for pages in page_counts: 4 days += math.ceil(pages / daily_limit) 5 return days 6 7 def is_before(page_counts, daily_limit, days): 8 return days_to_finish(page_counts, daily_limit) <= days SOLUTION 29.12 TIDE AERIAL VIEW We can binary search for the transition point where it goes from majority above water to majority underwater. The 'before' pictures are < 0.5 water, and the 'after' pictures are ≥ 0.5 water. The answer will be the last 'before' or the !rst 'after.' However, if you constructed the is_before() function to just loop through the matrix, counting the number of cells underwater, you missed something! Besides doing a binary search across the range of pictures, we can CHAPTER 29 ▸ BINARY SEARCH 343 speed up the count of underwater cells by also doing a binary search on each row: the rows are monotonic, with all 1's followed by all 0's. 1 def get_ones_in_row(row): 2 if row[0] == 0: 3 return 0 4 if row[-1] == 1: 5 return len(row) 6 7 def is_before_row(idx): 8 return row[idx] == 1 9 10 l, r = 0, len(row) 11 while r - l > 1: 12 mid = (l + r) // 2 13 if is_before_row(mid): 14 l = mid 15 else: 16 r = mid 17 return r 1 def is_before(picture): 2 water = 0 3 for row in picture: 4 water += get_ones_in_row(row) 5 total = len(picture[0])**2 6 return water/total < 0.5 Checking the number of ones in a row takes O(log n) time. Checking the number of ones in an entire grid takes O(n log n) time. The total time is O(n log n log k), where k is the number of pictures. BINARY SEARCH GONE WRONG INTERVIEW REPLAY View Online:bctci.co/binary-search-replay-2 @ 2:45 - 26:07:00 The Question:Write an algorithm to compute the square root of a given non-negative number What You'll See:The candidate struggled to implement a working version of binary search, and each change led to further problems with the algorithm. Who: Interviewer: Software Engineer at Meta Candidate: 7 years exp. CONCLUSIONS Binary Search triggers: The input is a sorted array/string. The brute force involves repeated linear scans. We are given an optimization problem that's hard to optimize directly. Keywords: sorted, threshold, range, boundary, ! nd, search, minimum/maximum, ! rst/last, small- est/largest. Binary search is often a step or a possible optimization in more complicated algorithms. Binary search is so common that it can (and will) be seen alongside almost every other Catalog topic, like Graphs (Problem 36.9: First Time All Connected, pg 468), Sliding Windows (Chapter 38: Longest Repeated Substring, pg 523), and Greedy Algorithms (Problem 41.6: Time Traveler Max Year, pg 593). The key idea in this chapter is that we can reframe every binary search problem as ! nding a transition point. This way, we only need one recipe for every scenario—the transition-point recipe (pg 329)—and we can focus our energy on more complicated parts of the code. 344 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co At this point, you should be ready to start adding binary search problems to your practice rotation. You can ! nd the problems in this chapter and additional problems in the companion AI interviewer. ONLINE RESOURCES Online resources for this chapter include: •A chance to try each problem in this chapter in AI Interviewer • Interview replays that show speci! c mistakes people make with binary search problems • Full code solutions for every problem in the chapter in multiple programming languages Try online at bctci.co/binary-search. CHAPTER 38 A I interviewer, replays, and more materials for this chapter at bctci.co/sliding-windows I CHAPTER 38 I CHAPTER 38 II SLIDING WINDOWS ▶Prerequisites: None In this chapter, we will use the sliding window technique to tackle problems about ! nding or counting subarrays. 1 We will use the following setting for problems throughout this chapter: a bookstore is looking at the number of book sales. The sales for each day are stored in an array of non-negative integers called sales. We say a good day is a day with at least 10 sales, while a bad day is a day with fewer than 10 sales. An interviewer could ask questions such as the following: •Find the most sales in any 7-day period (Problem 1). •Find the most consecutive days with no bad days (Problem 5). •Find the longest period of time with at most 3 bad days (Problem 8). •Find the shortest period of time with more than 20 sales, if any (Problem 14). •Count the number of subarrays of sales with at most 10 bad days (Problem 18). •Count the number of subarrays of sales with exactly 10 bad days (Problem