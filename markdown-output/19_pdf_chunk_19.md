# PDF Chunk 19

it, we may have to grow through invalid solutions in order to get to the optimal one, making it hard to know when to grow or shrink. For example, consider a simpli! ed version of Problem 43.7: Longest Subarray With Sum K (pg 618): Given an array of integers, which may be negative, return if any subarray adds up to 0. This problem looks like a maximum window problem because it asks for the longest subarray satisfying a constraint, but we can't follow the typical maximum window policy of "grow when you can, shrink when you must." For instance, if the input starts with [1, 4, -2, -2, 5, ...] and we (somehow) grow the window up to [1, 4, -2, -2], should we shrink it in order to ! nd a valid window of length 3, or keep growing because there may be a longer solution with the initial 1, like [1, 4, -2, -2, 5, -6]? It is impossible to say. For problems without the maximum window property, it is better to ditch the sliding window approach entirely and think of di" erent approaches. A linear-time algorithm may also be less realistic (although it is possible for this particular problem using pre! x sums, pg 618). #Sliding windows often don't work with negative values. 9 Finally, there are also problems that have the maximum window property, meaning that the maximum window recipe gives the optimal answer, but it is just really hard to implement e# ciently. Here is an example of a classic problem: PROBLEM 38.13 L O N G E S T R E P E A T E D S U B S T R I N G Given a string, s, return the longest substring that appears more than once in s (overlapping is allowed) or the empty string if there is none. ▶Example: s = "murmur" Output: "mur" ▶Example: s = "murmurmur" Output: "murmur" ▶Example: s = "aaaa" Output: "aaa" SOLUTION 38.13 L O N G E S T R E P E A T E D S U B S T R I N G This can be seen as a maximum window problem because we are looking for the longest window with some property. Further, it has the maximum window property: if a substring is not repeated, it won't suddenly become repeated if we make it longer. The challenge for this problem is assessing whether a substring is valid or not is not easy because it depends on what is outsidethe window instead of what is inside of it. For problems like this, where the maximum window recipe works but is hard to implement e# ciently, we recommend trying something other than sliding windows. 9 Kadane's algorithm (Solution 38.6: Max Subarray Sum (pg 518) for the maximum subarray sum problem is an excep- tion. 524 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co For this particular problem, we can try the guess-and-check technique we learned in the Binary Search chapter (pg 338). That is, we can try to binary search over the length of the optimal window. This approach starts by asking: "If I somehow knew the length of the optimal window, would that make the problem easier?" The answer is often yes because then we can use the ! xed-length window recipe, which is the most straightforward one. In this case, the ! xed-length window version of the problem is "For a given k, is there a substring of length k that appears more than once?" If we can solve this e# ciently, we can then binary search for the transition point in the range of values of k where the answer goes from "yes" to "no". The ! xed-length window version can be solved in O(n) time using a rolling hash (bctci.co/set-and-map-implementations, Rolling Hash Algorithm section), leading to O(n log n) total time. # When a problem has the maximum window property, but you cannot ! nd an e# cient way to check if the window is valid or evaluate the window, consider using the guess-and-check technique. For an 'extra' factor of O(log n) in the runtime, it turns the problem into a potentially easier ! xed-length window problem. MINIMUM WINDOWS Minimum window problems are the opposite of maximum window problems. We try to ! nd a window as short as possible, but the constraint restricts how small valid windows can be. We'll use 'minimum windows', which grow when they must and shrink when they can. Recall the fourth opening bookstore problem: PROBLEM 38.14 SHORTEST PERIOD WITH OVER 20 SALES Given an array, sales, return the length of the shortest period of time with over 20 sales, or -1 if there isn't any. ▶Example: sales = [5, 10, 15, 5, 10] Output: 2. The subarray [10, 15] has over 20 sales. ▶Example: sales = [5, 10, 4, 5, 10] Output: 4. [5, 10, 4, 5] and [10, 4, 5, 10] have over 20 sales. ▶Example: sales = [5, 5, 5, 5] Output: -1. There is no subarray with more than 20 sales. SOLUTION 38.14 SHORTEST PERIOD WITH OVER 20 SALES This is a minimum window problem because we are trying to ! nd a window as short as possible. For minimum window problems, the empty window is invalid (in this problem, because it has fewer than 20 sales). We need to grow it until it becomes valid, similar to how we did for ! xed-length window problems. We can follow this strategy for when to grow and shrink the window: 1. If the window has 20 sales or fewer: grow it. 2. Otherwise, shrink it to look for a shorter one with over 20 sales. CHAPTER 38 ▸ SLIDING WINDOWS 525 1 def shortest_over_20_sales(sales): 2 l, r = 0, 0 3 window_sum = 0 4 cur_min = math.inf 5 while True: 6 must_grow = window_sum <= 20 7 if must_grow: 8 if r == len(sales): 9 break