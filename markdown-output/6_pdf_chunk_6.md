# PDF Chunk 6

the fi rst and last values in the range handle edge cases: - the range is empty - l is 'after' (the whole range is 'after') - r is 'before' (the whole range is 'before') while l and r are not next to each other (r - l > 1) mid = (l + r) / 2 if is_before(mid) l = mid else r = mid return l (the last 'before'), r (the fi rst 'after'), or something else, depending on the problem The point of the initialization and the initial edge cases is to get to a setting that looks like the ! rst row of Figure 4: lmust be in the 'before' region, and rmust be in the 'after' region. The three edge cases are designed to ensure this. Once we get to that point, the main while loop is the same for every problem—no tweaking needed! The loop has the following invariants, which are guarantees that make our lives easier: • From start to end, l is in the 'before' region, and r is in the 'after' region. They are never equal and never cross over. 3 •The midpoint is always strictly between l and r (l < mid < r), which guarantees we always make progress (we don't need to worry about in! nite loops). •When we exit the loop, l and r are always next to each other. 3 If we were a little more willing to buck conventions, we'd rename from l and r to b and a, since they always map to 'before' and 'after' values. However, you might get odd looks from an interviewer if you do this! 330 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co Something that is typically tricky with binary search is the exit condition of the loop. Here, we keep going until l and r are next to each other (i.e., until the 'unknown' region in Figure 4 is empty), which happens when r - l is 1. That's why the condition says r - l > 1. 4 Another tricky part is knowing what to return. With this recipe, we just need to reason about the transition point: do we need the ! nal 'before' or the ! rst 'after'? We recommend starting by de! ning the is_before() function. Keep in mind that, for binary search to work, we must de! ne it in such a way that the search range is monotonic: all the 'before' elements must appear before all the 'after' elements. That's why binary search doesn't work on unsorted arrays. Revisiting Solution 29.1 Here is how we applied the recipe in Solution 29.1: we de! ned the 'before' region as the elements <target, and the 'after' region as the elements ≥target. In the initialization, we have the three edge cases from the recipe to ensure that l is 'before' and r is 'after': 1 if n == 0: 2 return -1 3 l, r = 0, n - 1 4 if arr[l] >= target or arr[r] < target: 5 if arr[l] == target: 6 return 0 7 return -1 The while loop is just like the recipe, except that we didn't factor out is_before() into a helper function: 1 while r - l > 1: 2 mid = (l + r) // 2 3 if arr[mid] < target: 4 l = mid 5 else: 6 r = mid Finally, when we ! nd the transition point, we consider what that means: l is at the largest value smaller than the target, and r is at the smallest value greater than or equal to the target. So, if the target is in the array at all, it must be at index r. 1 if arr[r] == target: 2 return r 3 return -1 What to do at the end depends on how we de! ne the 'before' region. We could have also de! ned 'before' as "less than or equal to the target," in which case, at the end, we would have to check the element at l instead of r. This recipe is a bit like a one-size-! ts-all pair of socks. While more concise (but less reusable) implementations may exist for some problems, there is value in needing only one easy-to-remember recipe. TRANSITION-POINT PROBLEM SET For each of the following problems: •Reframe it as ! nding a transition point by de! ning 'before' and 'after' regions. •Find the location of l and r after ! nding the transition point for the given example input. 4 We could have also written this in other ways, like r > l + 1. One way to remember the formula for the number of elements between l and r, r-l-1, is that it looks like a sleepy cat. CHAPTER 29 ▸ BINARY SEARCH 331 •Identify what to return after ! nding the transition point. You don't need to code anything yet—focus on the transition logic. QUESTION 1 GIT COMMITS Find the ! rst commit that fails a test in a sequence of Git commits. We know the test was passing for every commit until it started failing at some point. ["pass", "pass", "pass", "pass", "fail", "fail", "fail"] QUESTION 2 SQUARED TARGET Given a sorted array of positive integers and a target value, ! nd the largest number in the array that can be squared and still be less than or equal to the target, if any. Return the number (not its index). [2, 3, 4, 5, 6, 7, 8, 11, 20, 21, 23, 25, 25], target = 36 QUESTION 3 FIRST NON"NEGATIVE Return the index of the ! rst non-negative integer in a sorted array (duplicates allowed), if any. [-21, -15, -9, -5, -5, -1, -1, 0, 0, 4, 7, 12, 21] QUESTION 4 FIRST 'P' Find the ! rst word that begins with 'p' in an array of words in dictionary order, if any. ["apple", "banana", "peach", "strawberry"] QUESTION 5 N E