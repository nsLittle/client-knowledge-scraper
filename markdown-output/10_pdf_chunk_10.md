# PDF Chunk 10

range is unknown, we can ! nd it e# ciently with repeated doubling. This is often useful in the guess-and-check technique (e.g., Problem 29.10: Water Re! lling, pg 340). G U E S S $A N D $C H E C K T E C H N I Q U E Since I was unable to come up with any approach, I knew the solution was going to be Binary Search. Anonymous Leetcode User, 2023 As the stolen bike story illustrates, binary search is often used in problems where it is not an obvious choice. Now that we have a solid recipe for any binary search problem, we will discuss the guess-and-check tech- nique, which allows us to use binary search on many optimization problems. Recall that an optimization problem is one where you are asked to ! nd some minimum or maximum value, subject to some constraint. For example, consider the following problem: PROBLEM 29.9 M I N "S U B A R R A Y "S U M S P L I T Given a non-empty array with n positive integers, arr, and a number k with 1 ≤ k ≤ n, the goal is to split arr into k non-empty subarrays so that the largest sum across all subarrays is minimized. Return the largest sum across all k subarrays after making it as small as possible. Each subarray must contain at least one value. ▶Example: arr = [10, 5, 8, 9, 11], k = 3 Output: 17. There are six ways of splitting the array into three subarrays. The optimal split is: [10, 5], [8, 9], and [11]. The largest sum among the three subarrays is 17. ▶Example: arr = [10, 10, 10, 10, 10], k = 2 Output: 30. SOLUTION 29.9 M I N "S U B A R R A Y "S U M S P L I T This is an optimization problem because we have a goal and a constraint: we are trying to minimize the largest subarray sum, subject to having at most k subarrays. Without the constraint, we would just put every element in its own subarray. A naive solution that tries every way of splitting the array into k subarrays would take exponential time. 7 There is a dynamic programming solution that takes O(n*k) time (pg 572). Here, we'll use a di" erent approach. Given a value, max_sum, we can ask: Is there a way to split arr into k subarrays such that every subarray has sum at most max_sum? •For max_sum < max(arr), the answer is "no" (some numbers are too big to be in a subarray, even by themselves). 7 You need to choose k out of n-1 possible splitting points, so there are (n-1 choose k) options, which is O((n-1) k ) = O(n k ) for any constant value of k. If k is n/2, the number becomes exponential on n (O(2 n /√n) to be exact, but you don't need to worry about where that formula comes from). Once k gets larger than n/2, the number of possibilities starts decreasing (if we are picking more than half the points, we can think about picking the points not to split at, of which there are fewer than n/2). CHAPTER 29 ▸ BINARY SEARCH 339 •For max_sum == sum(arr), the answer is "yes" (any split will do). We can binary search for the transition point where the answer goes from "no" to "yes" with our transition point recipe. The value x corresponding to the !rst "yes" is the value of the optimal solution. To i m p l e m e n t o u r is_before(max_sum) function, we need to be able to compute the answer to the ques- tion. Thankfully, it is much easier than the original problem: we can grow each subarray up until the point where its sum would exceed max_sum. At that point, we start a new subarray, and so on. If we need more than k subarrays, the answer is "no." Otherwise, the answer is "yes." 1 # "Is it impossible to split arr into k subarrays, each with sum <= max_sum?" 2 def is_before(arr, k, max_sum): 3 splits_required = get_splits_required(arr, max_sum) 4 return splits_required > k 5 6 # Returns the minimum number of subarrays with a given maximum sum. 7 # Assumes that max_sum >= max(arr). 8 def get_splits_required(arr, max_sum): 9 splits_required = 1 10 current_sum = 0 11 for num in arr: 12 if current_sum + num > max_sum: 13 splits_required += 1 14 current_sum = num # Start a new subarray with the current number. 15 else: 16 current_sum += num 17 return splits_required 18 19 def min_subarray_sum_split(arr, k): 20 l, r = max(arr), sum(arr) # Range for the maximum subarray sum. 21 if not is_before(arr, k, l): 22 return l 23 while r - l > 1: 24 mid = (l + r) // 2 25 if is_before(arr, k, mid): 26 l = mid 27 else: 28 r = mid 29 return r Let S be the sum of arr. Binary search will take O(log S) steps to converge, and each is_before() check takes O(n) time. The total runtime is O(n log S). Depending on whether O(k) or O(log S) is larger, DP or binary search will be better. Neither dominates the other. To re c a p, t h e guess-and-check technique involves narrowing in on the value of the optimal solution by guessing the midpoint and checking whether it's too high or too low. To start, we need lower and upper bounds for the value of the optimal solution (if the bounds are not obvious, exponential search can help). For minimization problems (like Problem 29.9: Min-Subarray-Sum Split), there is often a transition point where smaller values do not satisfy the constraint, but larger values do. Conversely, for maximization problems, there is often a transition point where larger values do not satisfy the constraint, but smaller values do. When should I use the guess-and-check technique?