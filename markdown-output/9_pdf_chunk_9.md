# PDF Chunk 9

< arr[i-1] 4 l, r = 0, len(arr)-1 5 if is_before(r): 6 return arr[r] 7 while r - l > 1: 8 mid = (l + r) // 2 336 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALO G OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co 9 if is_before(mid): 10 l = mid 11 else: 12 r = mid 13 return arr[l] Interestingly, in the variation of this problem where we allow duplicates in the input, binary search does not work: if mid lands on a value that is the same as the previous one and the next one, we can't tell if we are in the descending pre!x or the ascending su#x. 6 SOLUTION 29.4 2"ARRAY 2"SUM This problem, which is a variant of the classic 2-sum problem, shows binary search as a building block of a broader algorithm. Let n1 be the length of the sorted array and n2 the length of the unsorted array. The "only O(1) extra space" constraint means that we can't use a map-based solution, which would take O(n1) or O(n2) space. Instead, we can iterate through the numbers in the unsorted array and, for each one, binary search for its inverse in the sorted array. The total runtime will be O(n2 * log n1). 1 def two_array_two_sum(sorted_arr, unsorted_arr): 2 for i, val in enumerate(unsorted_arr): 3 idx = binary_search(sorted_arr, -val) 4 if idx != -1: 5 return [idx, i] 6 return [-1, -1] We omit the binary search step because it is the same as Solution 1. SOLUTION 29.5 TA R G E T CO U N T D I V I S I B L E BY K The key is to !nd the !rst and last occurrence of the target, first and last. If present, the number of occur- rences of the target is last - first + 1. We can check if this number is multiple of k. If the target is in the array, we can !nd first and last with a binary search for each: •one de!ning 'before' as '< target' and returning r, •one de!ning 'before' as '< target + 1' and returning l. The runtime is O(2*log n) = O(log n). SOLUTION 29.6 RACE OVERTAKING We say an index is 'before' if player 2 has not overtaken player 1 yet. That is: 1 def is_before(i): 2 return p1[i] > p2[i] According to the statement, index 0 is 'before' and index n-1 is 'after,' so we don't need to worry about the initial edge cases. We just need to !nd the transition point and return r. SOLUTION 29.7 SEARCH IN SORTED GRID We could solve this problem in two steps: 1. Binary search over the rows to !nd a single row that may contain the target. 2. Binary search over the row. 6 In fact, for this variant, we cannot do better than O(n) time. The array could consist of all 1's and a single 0, which could be anywhere and can only be found with a linear scan. CHAPTER 29 ▸ BINARY SEARCH 337 While this works, a trick that makes the implementation easier is to imagine that we "% atten" the grid into a single, long array with all the rows consecutively: Figure 5. This would be a sorted array with R*C elements. We can binary search over this '% attened-grid' array without actually creating it. We'd start with l = 0 and r = R*C - 1. To de! ne the is_before() function, we must map the '% attened-grid’ array index to the actual grid coordinates on the % y: 1 def is_before(grid, i, target): 2 num_cols = len(grid[0]) 3 row, col = i // num_cols, i % num_cols 4 return grid[row][col] < target Once we ! nd the transition point, we have to map r back to grid coordinates to check if the target is there and return them. REUSABLE IDEA: GRID FLATTENING If we want to iterate or search through a grid with dimensions RxC as if it was a 'normal' array of length R*C, we can use the following mapping from grid coordinates to "% attened-grid array" coordinates: [r, c] → r * C + c and the reverse mapping to go from "% attened-grid array" coordinates to grid coordinates: i → [i // C, i % C] For instance, cell [1, 2] in Figure 5 (the 9) becomes index 1 * 4 + 2 = 6, and, conversely, index 6 becomes cell [6 // 4, 6 % 4] = [1, 2]. SOLUTION 29.8 S E A R C H I N H U G E A R R A Y Leveraging the break down the problem booster, we can break the problem into two. One problem is quickly ! nding the target in a huge array. Binary search is an obvious choice here, but it leads to the second problem: our left pointer can start at zero, but where do we start our right pointer without knowing the length of the array? A silly way to solve this would be to keep trying one index after another until the API eventually returns -1. Instead, we can double our index at each step. If the length is n, we'll reach it in approximately log 2 (n) steps. The rest of the problem is a straightforward application of the transition-point recipe. 1 def fi nd_through_api(target): 2 def is_before(idx): 3 return fetch(idx) < target 4 l, r = 0, 1 5 # Step 1: Get the rightmost boundary 6 while fetch(r) != -1: 7 r *= 2 8 # Step 2: Binary search 9 # ... 338 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co The total runtime is O(log n), where n is the size of the huge array. REUSABLE IDEA: EXPONENTIAL SEARCH Whenever we need to search for a value in a range, but the upper bound (or even lower bound) of the