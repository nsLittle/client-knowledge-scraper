# PDF Chunk 21

the window length. A window is valid if the count for each letter is at least as big as the count in s2. The key information we need to maintain about the window is a frequency map counting how many times each letter from s2 is missing. We can also keep a separate count of the number of distinct letters that are missing. When this counter is at 0, the window is valid. 1 def shortest_with_all_letters(s1, s2): 2 l, r = 0, 0 3 missing = {} 4 for c in s2: 5 if not c in missing: 6 missing[c] = 0 7 missing[c] += 1 8 distinct_missing = len(missing) 9 cur_min = math.inf 10 while True: 11 must_grow = distinct_missing > 0 12 if must_grow: 13 if r == len(s1): 14 break 15 if s1[r] in missing: 16 missing[s1[r]] -= 1 528 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALO G OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co 17 if missing[s1[r]] == 0: 18 distinct_missing -= 1 19 r += 1 20 else: 21 cur_min = min(cur_min, r - l) 22 if s1[l] in missing: 23 missing[s1[l]] += 1 24 if missing[s1[l]] == 1: 25 distinct_missing += 1 26 l += 1 27 return cur_min if cur_min != math.inf else -1 SOLUTION 38.16 SMALLEST RANGE WITH K ELEMENTS This is an interesting problem because we are not looking for a subarray of the input but rather a window on the values in the array. Nonetheless, we can still use a minimum window to !nd this range. First, we sort the input since we do not care about the original order, and it will help us !nd values in arr that are close together. After sorting, the problem can be REFRAMED as follows: Find the window containing at least k elements, minimizing the di"erence between its maximum and minimum. Now that we have a constraint and an objective for the window, this is a standard minimum window problem. Thanks to sorting, the minimum and maximum in the window are easy to calculate as they are the !rst and last elements. Sorting is the runtime bottleneck in this solution, so it takes O(n log n) time instead of O(n) as usual. 1 def smallest_range_with_k_elements(arr, k): 2 arr.sort() 3 l, r = 0, 0 4 best_low, best_high = 0, math.inf 5 while True: 6 must_grow = (r - l) < k 7 if must_grow: 8 if r == len(arr): 9 break 10 r += 1 11 else: 12 if arr[r - 1] - arr[l] < best_high - best_low: 13 best_low, best_high = arr[l], arr[r - 1] 14 l += 1 15 return [best_low, best_high] SOLUTION 38.17 STRONG START AND ENDING It is not obvious at all how a problem about maximizing pre!x and su#x lengths is related to minimum windows, but we will show a clever trick to REFRAME THE PROBLEM into a minimum window problem. What is between a pre!x and a su#x? A window! Finding a pre!x and a su#x is the twin problem of !nding the subarray between them. The next question is: "If we look for a subarray instead of for a pre!x and a su#x, what property should the subarray have?" Let's say projected_sales has B bad days in total. We know we can %ip k of them into good days, so we will end up with B - k bad days (if B - k is 0 or negative, we can convert all bad days into good days, so CHAPTER 38 ▸ SLIDING WINDOWS 529 the answer is the length of the input array). If we can ! nd the smallestwindow with B - k bad days, then we can % ip every bad day outside the window and maximize the pre! x and su# x without bad days. With this reframing, the problem becomes a standard minimum window problem. EXTRA CREDIT: COUNTING PROBLEMS By this point, we have seen many sliding window problems in which the constraint that the window must satisfy is of the form "at most/at least/exactly k of something." In this section, we talk about how to count the number of subarrays under a constraint like that, including the ! nal three opening bookstore problems. AT -M O S T -K CO U N T I N G PROBLEM 38.18 C O U N T S U B A R R A Y S W I T H A T M O S T K B A D D A Y S Given an array, sales, count the number of subarrays with at most k bad days (days with fewer than 10 sales). ▶Example: sales = [0, 20, 5], k = 1 Output: 5. [20] has 0 bad days, and [0], [0, 20], [20, 5], and [5] have 1 bad day each. SOLUTION 38.18 C O U N T S U B A R R A Y S W I T H A T M O S T K B A D D A Y S We can leverage an interesting property about the maximum window recipe: if a problem has the maximum window property (pg 523), whenever we grow the window by adding an element arr[r - 1], the new window is the longest valid window that ends at arr[r - 1]. This means that the valid subarrays ending at arr[r - 1] are those starting at arr[l], arr[l + 1], and so on, up to arr[r - 1] itself. Thus, there are r - l valid subarrays ending arr[r - 1]. As we saw in the Problem-Solving Boosters chapter, we can often leverage properties into algorithmic ideas. In this case, we can follow the maximum window recipe—as if we were trying to ! nd the longest window with at most k bad days—and whenever we grow the window by adding an element arr[r - 1], we add r - l to a running count of valid subarrays. Here is a full solution based on