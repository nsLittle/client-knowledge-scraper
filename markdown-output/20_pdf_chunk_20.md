# PDF Chunk 20

10 window_sum += sales[r] 11 r += 1 12 else: 13 cur_min = min(cur_min, r - l) 14 window_sum -= sales[l] 15 l += 1 16 if cur_min == math.inf: 17 return -1 18 return cur_min Figure 5. Illustration of the sliding window of short- est_over_20_sales(). Unlike the other recipes, we initialize the result (cur_min) to in! nity because we update it by taking the minimum. At the end, we need to check if it is still in! nity, which means that we didn't ! nd any valid windows. It is a common mistake to forget this ! nal check! In the main loop, we start each iteration by declaring a variable must_grow (instead of can_grow for maxi- mum windows) which indicates if the currentwindow is invalid. If we must grow, there is one edge case to consider: if r == len(sales), we ran out of elements to grow, so we break out of the loop. We have this edge case for minimum windows but not maximum windows because the while-loop condition is di" erent: we don't stop as soon as r gets to the end because it might still be possible to make the window smaller and get a better answer. If must_grow is false, then we have a valid window, so we update the current minimum ! r s tand then shrink the window to see if we can make it even smaller. We can put these ideas together in a general recipe for minimum window problems. 526 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co RECIPE 4. MINIMUM WINDOW RECIPE. minimum_window(arr): initialize: - l and r to 0 (empty window) - data structures to track window info - cur_best to infi nity while true if the window must grow to become valid if the window cannot grow (r == len(arr)) break grow the window (update data structures and increase r) else update cur_best if needed shrink the window (update data structures and increase l) return cur_best Recall that maximum windows only work for problems that have what we call the maximum window property? For the minimum window recipe to work, we need the opposite property: Shrinking an invalid window never makes it valid. We call this the minimum window property. It means that if the current window is invalid, we de! nitely need to grow it. SUCCESSFULLY SOLVES MINIMUM SLIDING WINDOW PROBLEM INTERVIEW REPLAY View Online:bctci.co/sliding-windows-replay-2 @ 4:15 - 43:23 The Question: Find the smallest substring in s containing all characters of t (including duplicates). What You'll See:The candidate successfully applied a minimum sliding window solution. Who:Interviewer: Sta" Software Engineer at Meta Candidate: 1 year exp. Outcome:The candidate got the job at Amazon! MINIMUM WINDOWS PROBLEM SET Try these problems with AI Interviewer: bctci.co/sliding-windows-problem-set-4 PROBLEM 38.15 S H O R T E S T W I T H A L L L E T T E R S Given a string, s1, and a shorter but non-empty string, s2, return the length of the shortest substring of s1 that has every letter in s2 (as many times as they appear in s2). If there is no such substring, return -1. ▶Example: s1 = "helloworld", s2 = "well" Output: 5. The substring "ellow" in s1 has all the letters in s2. ▶Example: s1 = "helloworld", s2 = "weelll" Output: -1. s1 does not have 2 e's. PROBLEM 38.16 S M A L L E S T R A N G E W I T H K E L E M E N T S Given an array of integers, arr, and an integer k with 1 ≤ k ≤ len(arr), return a pair of values, [low, high], with low ≤ high, representing the smallest range such that there are at least k elements in arr with values at least low and at most high. If there are multiple valid answers, return any of them. CHAPTER 38 ▸ SLIDING WINDOWS 527 ▶Example: arr = [1, 2, 5, 7, 8], k = 3 Output: [5, 8]. The range has 3 elements in arr (5, 7, and 8) and it is smaller than other ranges with 3 elements, such as [1, 5]. ▶Example: arr = [5, 5, 2, 2, 8, 8], k = 3 Output: [2, 5]. The range has 4 elements in arr (5, 5, 2, and 2) and there is no smaller range with at least 3 elements. [5, 8] is also a valid answer. ▶Example: arr = [0], k = 1 Output: [0, 0]. PROBLEM 38.17 S T R O N G S T A R T A N D E N D I N G We have an array, projected_sales, with the number of book sales we expect each day of the fall season. We would like to start and close the season strong. We want to have as many consecutive good days as possible starting from day 0 and as many consecutive good days as possible ending on the last day (a good day is a day with at least 10 sales). We can pick k days to boost with advertising, which we expect to boost the sales on those speci! c days by at least 20. What's the maximum number of combined initial good days and ! nal good days we can have? ▶Example: projected_sales = [10, 0, 0, 0, 10, 0, 0, 10], k = 2 Output: 5. We should boost days 5 and 6 so that the projected sales after boosting are [10, 0, 0, 0, 10, 20, 20, 10]. This way, we have 1 initial and 4 final good days. ▶Example: arr = [0, 10, 0, 10], k = 1 Output: 3. We can boost either day 0 or day 2. PROBLEM SET SOLUTIONS SOLUTION 38.15 S H O R T E S T W I T H A L L L E T T E R S This is a minimum window problem since we have to minimize