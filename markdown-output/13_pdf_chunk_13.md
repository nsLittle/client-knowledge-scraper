# PDF Chunk 13

19). •Count the number of subarrays of sales with at least 10 bad days (Problem 20). All these questions receive an array as input, sales. The ! rst four ask us to ! nd a subarray, while the last three ask us to count subarrays, making them ideal candidates for the sliding window technique. In this chapter, we will cover variants of the sliding window technique to tackle each of the mentioned problems and more. The basic idea of a sliding window is to consider a subarray (the "window"), marked by left (l) and right (r) pointers. We move or "slide" the window to the right by increasing the l and r pointers, all while computing some value about the current window. 23 1 Beyond DS&A, the term 'sliding window' is also used in network protocols like TCP (https://en.wikipedia.org/wiki/ Transmission_Control_Protocol) and in machine learning architectures like convolutional neural networks (https:// en.wikipedia.org/wiki/Convolutional_neural_network). 2 A sliding window is a special case of the two-pointer technique. Like in the Two Pointers chapter, we use the terms "pointer" and "index" interchangeably. 3 Sliding windows are usually not useful for problems about subsequences because they don't have a good way of dealing with "skipping" elements. Subsequence problems are more commonly tackled with other techniques that we will see later, like dynamic programming or backtracking. Sliding Windows 510 BEYOND CRACKING THE CODING INTERVIEW ▸ CATALOG OF TECHNICAL TOPICS View online materials for Beyond Cracking the Coding Interview at bctci.co Figure 1. Window 1 is a subarray from l = 4 (included) to r = 10 (excluded). We can slide it and get Window 2 by increasing l and r. THE ELEMENTS OF A SLIDING WINDOW PROBLEM Problems where sliding windows may be useful tend to involve the following: •You have to ! nd a subarray of an input array. • This subarray must satisfy some constraint, which separates the subarrays into valid and invalid. Examples of constraints: »The length must be k (for some given value k). »The sum must be at least / at most / exactly k. »It must contain or not contain speci! c elements. »It must not contain repeated elements. •There is usually an objective that makes some subarrays "better" than others. For example: »Maximize/minimize the length of the window. »Maximize/minimize the sum of the elements in the window. »Maximize/minimize the number of distinct elements in the window. •Less commonly, if there is no objective, the goal may be to count the number of valid subarrays. For instance, in the ! rst bookstore problem, the constraint is "the length of the subarray must be 7," and the objective is to maximize the sum. In the last one, the constraint is "at least 10 bad days," and there is no objective since it is a counting problem. Can you identify the constraints and objectives for the other bookstore problems? BRUTE FORCE BASELINE Most sliding window problems can be solved with a brute force algorithm that checks every subarray one by one. If the subarray is valid, then we check if it's the best one so far. The brute force solution is correct, but we'd ideally like a more optimized solution. Before diving into how to do this, it can be useful to consider what our upper bound, lower bound, and target runtimes might be (see the Boundary Thinking chapter). • Upper bound: O(n 3 ) will be the most common brute force upper bound across sliding window prob- lems, where n is the length of the input array. There are O(n 2 ) subarrays to search through. For each of those, checking whether it is valid and the best so far in a naive way could take O(n) time. • Lower bound: if we don't look at every element in the input, we won't even know what some substrings look like, so O(n) is the natural lower bound. • Ta rg e t : t h e s l i d i n g w i n d ow te c h n i q u e o f te n a l l ows u s to re a c h a l i n e a r r u nt i m e, s o we s h o u l d a i m fo r t h at. CHAPTER 38 ▸ SLIDING WINDOWS 511 H O W T O S L I D E A W I N D O W To make things easy to remember, we follow some conventions for initializing and updating all sliding windows in this chapter: 1. The window goes from the element at index l (inclusive) to the element at index r(exclusive). This means: »the window is empty when l == r, »r points to the ! rst element after the window (if any), and »the length of the window is r - l. 2. We always initialize l and r to 0, meaning the window starts empty. 3. We grow the window by incrementing r. We can only grow it when r < len(arr). 4. We shrink the window by incrementing l. We can only shrink it when l < r. 5. We always have 0 ≤ l ≤ r ≤ len(arr). Consistency enables us to predict what our possible o" -by-one errors are likely to be. For instance, r - l always means "the size of the window," and l == r always means "the window is empty," without worrying about o" -by-one errors. 4 ANALYZING SLIDING WINDOWS Every sliding window consists of a main loop, where, at each iteration, we either grow or shrink the window, or both. Since r never decreases and runs from 0 to n, our window can only grow n times. By this same token, the window can only shrink (by increasing l) n times. This means that any properly implemented sliding window does at most O(2n) = O(n) iterations. To get the total runtime, we need to multiply the number of iterations, O(n), by the